# 汇编语言程序设计

## 微型计算机基础

### 数制

#### 数制

用进位的方法进行计数的体制称为 **进位计数制**。

设一个 $R$ 进制的的数 $N:(N)_R$, 该数制的三要素有：

+ 数码：0~R-1，进位规律：逢 R 进 1，借 1 当 R
+ 位权：$R^i$，数码在一个数中的位置不同，其大小就不同。$i$ 为数码所在的位置，称为 **数位**。
+ 基数：数码的进制数 $R$ ，也称为底数。
  + 十进制（D）：Decimal
  + 二进制（B）：Binary
  + 八进制（O）：Octal
  + 十六进制（H）：Hexadecimal

| 计数制   | 数码 | 位权   | 基数 | 举例                      |
| -------- | ---- | ------ | ---- | ------------------------- |
| 十进制   | 0~9  | $10^i$ | 10   | $(123)_{10}$ $(45.321)_D$ |
| 二进制   | 0~1  | $2^i$  | 2    | $(1010)_2$ $(1001.101)_B$ |
| 八进制   | 0~7  | $8^i$  | 8    | $(567)_8$ $(765)_O$       |
| 十六进制 | 0~F  | $16^i$ | 16   | $({2A2B})_{16}$           |

#### 进制转换

非十进制-> 十进制：按 **位权** 展开后相加（各位上的数字乘位权后相加）

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220830084154.png" alt="image-20220830084154761" style="zoom:67%;" />

十进制-> 非十进制：基数乘除法（整数除基取余数倒序排、小数乘基取整数正序排）

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220830084108.png" alt="image-20220830084108819" style="zoom: 67%;" />

#### 精度

1. $n$ 位 $R$ 进制的小数精度为：$R^{-n}$

2. 确定转换进度，要求转换后的精度不低于原精度（原精度数值大）

#### 常见进制转化

$Bin\to Oct(Hex)$：

+ 三(四)位一段，不足补零
+ 整数向左，小数向右

$Oct(Hex)\to Bin$：

+ 一位翻三(四)，不足补零
+ 整数向左，小数向右

$Oct\to Hex： Oct\to Bin\to Hex$

### 码制（编码的制式）

由于数字系统只能识别 0 和 1，为了表示更多的数字、符号和字母，我们需要引入编码的概念。即用一定为数的二进制数字来表示这些信息。编码所得的每组符号称为 **代码或者码字**，代码中的每个符号称为 **基本代码或码元**。

#### 字符的编码–ASCII 码

采用美国标准信息交换码（ASCII）对字符进行编码。使用 **七位二进制编码** 来表示一个字符。该编码方案中共有 128 个字符。

> 由于一个字节为 8 位，所以将 ASCII 的最高位置为 1。（或者作为奇偶校验位）

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/ASCII.png" alt="image-20220830084643343" style="zoom:80%;" />

+ 比如在键盘键入“A”，则输入的二进制串为$0100 \ 0001 B$，即$41H$
+ $0\sim 9$ 的 ASCII 码为 $30H\sim 39H$
+ $A \sim F$的 ASCII 码为$41H \sim 46H$
+ 回车符的 ASCII 码为 $ODH$
+ 换行符的 ASCII 码为 $OAH$



#### 十进制数的二进制编码–BCD 码

> 这种编码技术，最常用于 [会计系统](https://zh.wikipedia.org/wiki/會計系統) 的设计里，因为会计制度经常需要对很长的数字做准确的计算。相对于一般的 [浮点式](https://zh.wikipedia.org/w/index.php?title=浮點式&action=edit&redlink=1) 记数法，采用 BCD 码，既可保存数值的精确度，又可使电脑免除作浮点运算所耗费的时间。此外，对于其他需要高精确度的计算，BCD 编码亦很常用。
>
> BCD 码的主要优点是在机器格式与人可读的格式之间转换容易，以及十进制数值的高精度表示。BCD 码的主要缺点是增加了实现算术运算的电路的复杂度，以及存储效率低。



BCD 码有多种形式，最常用的是 8421BCD 码，它是用 4 位二进制数对一个十进制数进行编码，这 4 位二进制码的值就是被编码的一位十进制数的值。8421BCD 码是十进制代码中最常用的一种。在这种编码方式中，每一位二值代码的“1”都代表一个固定数值。将每位“1”所代表的十进制数加起来就可以得到它所代表的十进制数码。因为代码中从左至右看每一位“1”分别代表字“8”“4”“2”“1”，故得名 8421 码。其中每一位“1”代表的十进制数称为这一位的权。因为每位的权都是固定不变的，所以 8421 码是 **恒权码**。

+ 用四位二进制数 $b_3b_2b_1b_0$ 来表示十进制数的 0~9 十个数码，$b_3 \to 8, b_2 \to 4 , b_1 \to 2, b_0 \to 1$

+ 修正：在加法运算中：加 6（0110）
  + 相加后得到非法码（大于 1001）
  + 相加后产生进位
  + 若加 6 修正后，产生非法码，则再加 6。
+ BCD 码在计算机中的存储分为紧凑型和非紧凑型两种：
  + 紧凑型 BCD 码：$(37)D = 0011,0111B$
  + 非紧凑型 BCD 码：$(37)D = 0000,0011B \quad 0000,0111B$


| 十进数  |  8421   |
| :-----: | :-----: |
| （M10） | D C B A |
|    0    | 0 0 0 0 |
|    1    | 0 0 0 1 |
|    2    | 0 0 1 0 |
|    3    | 0 0 1 1 |
|    4    | 0 1 0 0 |
|    5    | 0 1 0 1 |
|    6    | 0 1 1 0 |
|    7    | 0 1 1 1 |
|    8    | 1 0 0 0 |
|    9    | 1 0 0 1 |

#### 有符号数的编码–原、反、补码

无符号数：计算机中的数均放在 **寄存器** 中，通常称寄存器的位数为 **机器字长**。**所谓无符号数，即没有符号的数**，在寄存器中的每一位均可用来存放数值。当存放有符号数时，则需留出位置存放符号。因此，在机器字长相同时，无符号数与有符号数所对应的数值范围是不同的。比如用一个八位的寄存器保存无符号数，则可以表示 $0\sim 255$。

##### 机器数与真值

因为计算机没有办法直接识别正负号，所以需要将正负号转化为数字来存储。保存在计算机中将正负号“数字化”之后的数称为 **机器数**，而 **真值** 是我们日常生活中包含了正负号的数值。注意：以下内容默认都为 2 进制数

##### 原码表示法

原码是机器数中最简单的一种表示形式，符号位为 0 表示正数，符号位为 1 表示负数，**数值位即真值的绝对值**，故原码表示又称为带符号的绝对值表示。为了书写方便以及区别整数和小数，约定整数的符号位与数值位之间用逗号隔开；小数的符号位与数值位之间用小数点隔开。由此可得原码的定义：
$$
[x]_{\text {原}}=\left\{\begin{array}{cc}
0, \ x & 2^{n}> x \geqslant 0 \\
2^{n}-x & 0 \geqslant x > -2^{n}
\end{array}\right.
$$
例如，当 $x= -1110$ 时，$[x]_{\text {原}} = 2^4 - (-1110) = 1,1110$

对于小数部分：
$$
[x]_{\text {原 }}=\left\{\begin{array}{cc}
x & 1 > x \geqslant 0 \\
1-x & 0 \geqslant x >-1
\end{array}\right.
$$
例如，当 $x= +0.1101$ 时，$[x]_{\text {原}} = 0.1101$，注意这里两个 $0.$ 的含义不同，后者表示正数+区分符

+ 不难发现，对于$0$而言，$[+0000] _{\text {原}} = 0,0000 ;\ [-0000]_{\text {原}} = 1,0000$，两者并不相同

+ 原码特点：简单且直观，但运算复杂。当两个操作数符号不同且要作加法运算时，先要判断两数绝对值大小，然后将绝对值大的数减去绝对值小的数，结果的符号以绝对值大的数为准。而且用到的是减法器实现。

  

##### 补码表示法

为了解决原码在计算中的问题，即用一个与负数等价的正数表示负数，使得运算中只需要加法器。

所谓补数，就是其本身加上 **模**。正数的补数是其自身，负数的补数是其本身加上模，当一个正数和一个负数互为补数的时候，其绝对值之和为模数。那么对于 2 进制数而言，模就是 $2^n$，但是为了能表示正负，即负数的首位为 1，选择将模设置为 $2^{n+1}$。
$$
[x]_{\text {补 }}= \begin{cases}0,\ x & 2^{n}> x \geqslant 0 \\ 2^{n+1}+x & 0 > x \geqslant-2^{n} \quad\left(\bmod 2^{n+1}\right)\end{cases}
$$
例如，$x = -1011000$，则 $[x]_{\text{补}} = 2^{7+1} + (-1011000) = 1,0101000$

小数：
$$
[x]_{\text {补 }}= \begin{cases}x & 1 > x \geqslant 0 \\ 2+x & 0 > x \geqslant-1 \quad(\bmod 2)\end{cases}
$$

例如，$x = -0.1100000$，则 $[x]_{\text{补}} = 2+(-0.1100000) = 1.0100000$

+ 我们也可以通过口诀“**原码取反（变为反码）再加 1**”快速计算一个数的补码
+ 不难发现，对于$0$而言，$[+0000] _{\text {补}} = 0,0000 ;\ [-0000]_{\text {补}} = 2^{4+1} - 0000 = 100000 -0000 = 0,0000$，最高位溢出舍去，所以补码的 0 表现形式是一致的
+ $-1$的补码为全$1$

##### 反码表示法

反码通常用来作为由原码求补码或者由补码求原码的中间过渡。反码的定义如下：
$$
[x]_{\text {反 }}=\left\{\begin{array}{ll}
0,\  x & 2^{n}> x \geqslant 0 \\
\left(2^{n+1}-1\right)+x & 0 \geqslant x >-2^{n}\left(\bmod 2^{n+1}-1\right)
\end{array}\right.
$$
小数：
$$
[x]_{\text {反 }}= \begin{cases}x & 1 > x \geqslant 0 \\ \left(2-2^{-n}\right)+x & 0 \geqslant x >-1 \quad\left(\bmod \left(2-2^{-n}\right)\right)\end{cases}
$$
例如，$x = -0.1010$，则
$$
\begin{align*}
[x]_{\text{反}} &= (2 - 2 ^{-4}) + (-0.1010)) \\
&= (10 - 0.0001) -0.1010 \\
&= 1.1111 - 0.1010 \\
&= 1.0101 
\end{align*}
$$

+ 简而言之为，符号位不变，正数不变，负数取反
+ 不难发现，对于$0$而言，$[+0000] _{\text {反}} = 0,0000 ;\ [-0000]_{\text {反}} = 2^{4+1}-1 - 0000 = 11111 - 0000 = 1,1111$，两者并不一致。

##### 小结

1. 最高位为符号位，书写上用“,”或“.”将数值部分与符号位分隔开
2. 对于正数，原码 = 反码 = 补码
3. 对于负数，符号位为 1。其数值部分原码取反得反码，反码加 1 得补码
4. 设机器数字长为 $n$，整数定点机表示
   1. 原码表示范围：$[-(2^{n-1}-1),+(2^{n-1}-1)]$
   2. 反码表示范围：$[-(2^{n-1}-1),+(2^{n-1}-1)]$
   3. 补码表示范围：$[-2^{n-1},+(2^{n-1}-1)]$

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8E%9F%E5%8F%8D%E8%A1%A5%E5%B0%8F%E7%BB%93.png" alt="image-20220726222748948" style="zoom:80%;" />

##### 补码加减法

整数加法： $[A]_{\text {补 }}+[B]_{\text {补 }}=[A+B]_{\text {补 }}\left(\bmod 2^{n+1}\right)$

小数加法： $[A]_{\text {补 }}+[B]_{\text {补 }}=[A+B]_{\text {补 }}(\bmod 2)$

整数减法： $[A-B]_{\text {补 }}=[A+(-B)]_{\text {补 }}=[A]_{\text {补 }}+[-B]_{\text {补 }}\left(\bmod 2^{n+1}\right)$ 

小数减法： $[A-B]_{\text {补 }}=[A+(-B)]_{\text {补 }}=[A]_{\text {补 }}+[-B]_{\text {补 }}(\bmod 2)$

+ 注意 **符号位需要参与计算**，丢弃符号位的进位（保存在进位标志寄存器中）

##### 溢出判断

1. 一位符号位判断：参加操作的两个数（减法时即为被减数和“求补”以后的减数）符号相同，其结果的符号与原操作数的符号不同，即为溢出。换言之，数值部分最高位的进位 $\oplus$ 符号位的进位 = 1 即为溢出。

2. 两位符号位判溢出：首先使用变形补码，其公式如下。简而言之，对于正数其变形补码（符号位）为 $00$，对于负数其变形补码（符号位）为 $11$。数值部分可以用原本的取反加一计算。
   $$
   [x]_\text{补}= \begin{cases}x & 1 > x \geq 0 \\ 4+x & 0 > x \geq-1(\bmod 4)\end{cases}
   $$

$$
[x]_{\text {补 }}= \begin{cases}0,\ x & 2^{n}> x \geqslant 0 \\ 2^{n+2}+x & 0 > x \geqslant-2^{n} \quad\left(\bmod 2^{n+2}\right)\end{cases}
$$

+ 在用变形补码作加法时，2 位符号位要连同数值部分一起参加运算，而且 **高位符号位产生的进位自动丢失**，便可得正 确结果。变形补码判断溢出的原则是：**当 2 位符号位不同时，表示溢出**，否则，无溢出。不论是否发生溢出，高位符号位永远代表其结果真正的符号。

3. 使用加法器中的进位标志 $CF$ 和溢出标志 $OF$ 进行判断，再结合操作数类型后由程序员判断
   1. 对无符号数而言，$OF=1$ 无影响，$CF =1$ 溢出
   2. 对有符号数无影响，$CF=1$ 无影响，$OF =1 $ 溢出

### 微型计算机系统的组成

计算机系统由硬件和软件两大部分组成，硬件是构成计算机的设备实体，软件是指为了运行、管理和维修计算机而编制的各种程序

#### 硬件组成

按照冯诺依曼的计算机体系逻辑结构的思想，将计算机分为五个部分：控制器、存储器、运算器、输入设备和输出设备

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%B1%87%E7%BC%96-%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC.png" alt="image-20220901082744690" style="zoom:80%;" />

其中，**运算器** 和 **控制器** 构成 **CPU** 的主要部分（还有一部分寄存器），CPU 与存储系统、I/O 接口、电源系统等组成了计算机系统的 **主机**，输入输出设备被称为 **外设**。

+ 存储器：具有记忆功能的部件，是能够接收、保存和取出信息（程序、数据和文件）的设备。这里所讲的存储器是指计算机系统的内部存储器，也称为主存储器（Main Memory），简称为内存或主存。用来存放指令和数据
+ 运算器：进行算术运算和逻辑运算的部件
+ 控制器：负责对指令进行译码，产生整个指令系统所需要的全部操作的控制信号，控制运算器、存储器和输入输出接口等部件完成指令规定的操作
+ 输入设备：输入设备通过输入接口电路将程序和数据输入内存。最常见的输入设备有键盘和鼠标
+ 输出设备：CPU 通过输出接口电路将程序运行的结果、程序和数据送到输出设备上。最常见的输出设备有显示器和打印机

#### 软件组成

不配置软件的计算机称为“裸机”，仅有裸机是不能做任何事情的，必须有软件的配合。软件又分为系统软件和应用软件两大类。

+ 系统软件：系统软件是指控制和协调计算机及外设、支持应用软件开发和运行且无需用户干预的各种程序的集合
  + 面向计算机管理的软件，如操作系统
  + 数据库管理系统
  + 语言处理程序
+ 应用软件：应用软件是计算机用户在各自的业务领域中开发和使用的各种软件，是为解决某一实际问题而编制的程序

#### 硬件结构

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220901084435.png" alt="image-20220901084435703" style="zoom:80%;" />

1. 总线

   总线是连接 CPU 与存储器、I/O 接口的公共导线，是各部件信息传输的公共通道。微型计算机系统有 3 种总线，它们是 **地址总线**、**数据总线** 和 **控制总线**

   + 地址总线传输地址信息，用来寻址存储单元和 I/O 端口。地址总线的“宽度”决定了 **系统内存的最大容量**。一个 cpu 有 $n$ 根地址线, 则该 cpu 的地址总线宽度为 $n$, 最多可以寻址 $2^n$ 内存单元。8088/8086 有$20$根地址线，能寻址$1MB$内存
   + 数据总线传输数据信息，数据总线的宽度决定了 cpu 与其他器件进行数据传送时的 **一次性数据传送量**。16 根总线一次可以传送 $2$ 字节($16bit$)
   + CPU 对外部器件的控制是通过控制总线来进行的。控制总线是一些不同控制线的集合。控制总线的宽度决定了 CPU 对系统中其他器件的控制能力

| 处理器 | 地址总线 | 数据总线 |
| ------ | -------- | -------- |
| 8088   | 20       | 内 16 外 8  |
| 80286  | 24       | 16       |
| 80486  | 32       | 32       |

2. 存储器

构成存储器的存储介质，目前主要采用半导体器件和磁性材料。一个双稳态半导体电路或磁性材料的 **存储元**，均可以存储一位二进制代码，称为 `1b`。这个二进制代码位是存储器中最小的存储单位，称为一个存储位或存储元。若干个存储元可以组成一个 **存储单元**（通常为 8 个 `bit` 组成一个字节），许多存储单元可以组成一个 **存储体**。存储体和地址译码电路、读写控制电路等一起构成 **存储器**

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220901092339.png" alt="image-20220901092339615" style="zoom: 50%;" />

每个存储单元都有一个唯一的标识符，这个标识符称为该存储单元的 **地址**。在计算机中，地址用一串二进制数来表示，为方便起见，书写格式通常采用 **十六进制形式**。通常，用 KB($2^{10}B$)、MB($2^{20}B$)或 GB($2^{30}B$)作为存储器的 **容量单位**。

按照存储器的读写功能分类：

+ 随机存储器：RAM 为随机（读/写）存储器，即通常所讲的内存。所谓 **静态 RAM**：集成度低，信息稳定，读写速度快，可以组成高速缓冲存储器 Cache；所谓 **动态 RAM**：集成度高，容量大，缺点是信息存储不稳定，只能保持几个毫秒，为此要不断进行“信息再生”，即进行 “刷新”操作。 内存条就是用动态 RAM 制作的。

+ 只读存储器：ROM 只读存储器多与 BIOS 相关（Basic Input/Output System，基本输入/输出系统），主板上的 ROM 存储这主板的 BIOS，显卡上的 ROM 存储显卡的 BIOS。


3. I/O 接口

   设备控制器是 CPU 与 I/O 设备之间的接口，它接收 CPU 发来的命令，去控制 I/O 设备工作

   当 CPU 要操作 I/O 设备时，首先要启动这个设备，一方面将启动命令发送给设备控制器，另一方面通过地址线将 I/O 设备的地址发给设备控制器，设备控制器的 I/O 逻辑对收到的地址进行译码，再根据所译出的命令对相应的设备进行操作。

   

#### 计算机的工作过程

程序是指令的有序集合，而指令是以二进制代码的形式出现的。把执行一项信息处理任务的程序代码，以字节为单位，按顺序存放在存储器的一段连续的存储区域内，这就是冯诺依曼 **程序存储** 的概念。简单地讲，微型计算机的工作过程是取指令（代码）$\to$ 分析指令（译码）$\to$ 执行指令的不断循环过程

1. 取指令

   从存储器某个地址单元中取出要执行的指令代码送到 CPU 内部的 **指令寄存器** 暂存

2. 分析指令

   称为指令译码，把保存在指令寄存器中的指令代码送到 **指令译码器**，译出该指令对应的微操作信号，控制各个部件

3. 取操作数

   发出取数据命令，到存储器取出所需的操作数

4. 执行指令

   根据指令译码，向各个部件发出相应控制信号，完成指令规定的各种操作

5. 保存结果

   如果需要保存计算或信息处理结果，则把结果保存到指定的存储器单元或者其他目的地
