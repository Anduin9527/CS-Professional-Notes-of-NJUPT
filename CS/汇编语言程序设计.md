# 汇编语言程序设计

## 微型计算机基础

### 数制

#### 数制

用进位的方法进行计数的体制称为 **进位计数制**。

设一个 $R$ 进制的的数 $N:(N)_R$, 该数制的三要素有：

+ 数码：0~R-1，进位规律：逢 R 进 1，借 1 当 R
+ 位权：$R^i$，数码在一个数中的位置不同，其大小就不同。$i$ 为数码所在的位置，称为 **数位**。
+ 基数：数码的进制数 $R$ ，也称为底数。
  + 十进制（D）：Decimal
  + 二进制（B）：Binary
  + 八进制（O）：Octal
  + 十六进制（H）：Hexadecimal

| 计数制   | 数码 | 位权   | 基数 | 举例                      |
| -------- | ---- | ------ | ---- | ------------------------- |
| 十进制   | 0~9  | $10^i$ | 10   | $(123)_{10}$ $(45.321)_D$ |
| 二进制   | 0~1  | $2^i$  | 2    | $(1010)_2$ $(1001.101)_B$ |
| 八进制   | 0~7  | $8^i$  | 8    | $(567)_8$ $(765)_O$       |
| 十六进制 | 0~F  | $16^i$ | 16   | $({2A2B})_{16}$           |

#### 进制转换

非十进制-> 十进制：按 **位权** 展开后相加（各位上的数字乘位权后相加）

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220830084154.png" alt="image-20220830084154761" style="zoom:67%;" />

十进制-> 非十进制：基数乘除法（整数除基取余数倒序排、小数乘基取整数正序排）

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220830084108.png" alt="image-20220830084108819" style="zoom: 67%;" />

#### 精度

1. $n$ 位 $R$ 进制的小数精度为：$R^{-n}$

2. 确定转换进度，要求转换后的精度不低于原精度（原精度数值大）

#### 常见进制转化

$Bin\to Oct(Hex)$：

+ 三(四)位一段，不足补零
+ 整数向左，小数向右

$Oct(Hex)\to Bin$：

+ 一位翻三(四)，不足补零
+ 整数向左，小数向右

$Oct\to Hex： Oct\to Bin\to Hex$

### 码制（编码的制式）

由于数字系统只能识别 0 和 1，为了表示更多的数字、符号和字母，我们需要引入编码的概念。即用一定为数的二进制数字来表示这些信息。编码所得的每组符号称为 **代码或者码字**，代码中的每个符号称为 **基本代码或码元**。

#### 字符的编码–ASCII 码

采用美国标准信息交换码（ASCII）对字符进行编码。使用 **七位二进制编码** 来表示一个字符。该编码方案中共有 128 个字符。

> 由于一个字节为 8 位，所以将 ASCII 的最高位置为 1。（或者作为奇偶校验位）

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/ASCII.png" alt="image-20220830084643343" style="zoom:80%;" />

+ 比如在键盘键入“A”，则输入的二进制串为$0100 \ 0001 B$，即$41H$
+ $0\sim 9$ 的 ASCII 码为 $30H\sim 39H$
+ $A \sim F$的 ASCII 码为$41H \sim 46H$
+ 回车符的 ASCII 码为 $ODH$
+ 换行符的 ASCII 码为 $OAH$



#### 十进制数的二进制编码–BCD 码

> 这种编码技术，最常用于 [会计系统](https://zh.wikipedia.org/wiki/會計系統) 的设计里，因为会计制度经常需要对很长的数字做准确的计算。相对于一般的 [浮点式](https://zh.wikipedia.org/w/index.php?title=浮點式&action=edit&redlink=1) 记数法，采用 BCD 码，既可保存数值的精确度，又可使电脑免除作浮点运算所耗费的时间。此外，对于其他需要高精确度的计算，BCD 编码亦很常用。
>
> BCD 码的主要优点是在机器格式与人可读的格式之间转换容易，以及十进制数值的高精度表示。BCD 码的主要缺点是增加了实现算术运算的电路的复杂度，以及存储效率低。



BCD 码有多种形式，最常用的是 8421BCD 码，它是用 4 位二进制数对一个十进制数进行编码，这 4 位二进制码的值就是被编码的一位十进制数的值。8421BCD 码是十进制代码中最常用的一种。在这种编码方式中，每一位二值代码的“1”都代表一个固定数值。将每位“1”所代表的十进制数加起来就可以得到它所代表的十进制数码。因为代码中从左至右看每一位“1”分别代表字“8”“4”“2”“1”，故得名 8421 码。其中每一位“1”代表的十进制数称为这一位的权。因为每位的权都是固定不变的，所以 8421 码是 **恒权码**。

+ 用四位二进制数 $b_3b_2b_1b_0$ 来表示十进制数的 0~9 十个数码，$b_3 \to 8, b_2 \to 4 , b_1 \to 2, b_0 \to 1$

+ 修正：在加法运算中：加 6（0110）
  + 相加后得到非法码（大于 1001）
  + 相加后产生进位
  + 若加 6 修正后，产生非法码，则再加 6。
+ BCD 码在计算机中的存储分为紧凑型和非紧凑型两种：
  + 紧凑型 BCD 码：$(37)D = 0011,0111B$
  + 非紧凑型 BCD 码：$(37)D = 0000,0011B \quad 0000,0111B$


| 十进数  |  8421   |
| :-----: | :-----: |
| （M10） | D C B A |
|    0    | 0 0 0 0 |
|    1    | 0 0 0 1 |
|    2    | 0 0 1 0 |
|    3    | 0 0 1 1 |
|    4    | 0 1 0 0 |
|    5    | 0 1 0 1 |
|    6    | 0 1 1 0 |
|    7    | 0 1 1 1 |
|    8    | 1 0 0 0 |
|    9    | 1 0 0 1 |

#### 有符号数的编码–原、反、补码

无符号数：计算机中的数均放在 **寄存器** 中，通常称寄存器的位数为 **机器字长**。**所谓无符号数，即没有符号的数**，在寄存器中的每一位均可用来存放数值。当存放有符号数时，则需留出位置存放符号。因此，在机器字长相同时，无符号数与有符号数所对应的数值范围是不同的。比如用一个八位的寄存器保存无符号数，则可以表示 $0\sim 255$。

##### 机器数与真值

因为计算机没有办法直接识别正负号，所以需要将正负号转化为数字来存储。保存在计算机中将正负号“数字化”之后的数称为 **机器数**，而 **真值** 是我们日常生活中包含了正负号的数值。注意：以下内容默认都为 2 进制数

##### 原码表示法

原码是机器数中最简单的一种表示形式，符号位为 0 表示正数，符号位为 1 表示负数，**数值位即真值的绝对值**，故原码表示又称为带符号的绝对值表示。为了书写方便以及区别整数和小数，约定整数的符号位与数值位之间用逗号隔开；小数的符号位与数值位之间用小数点隔开。由此可得原码的定义：
$$
[x]_{\text {原}}=\left\{\begin{array}{cc}
0, \ x & 2^{n}> x \geqslant 0 \\
2^{n}-x & 0 \geqslant x > -2^{n}
\end{array}\right.
$$
例如，当 $x= -1110$ 时，$[x]_{\text {原}} = 2^4 - (-1110) = 1,1110$

对于小数部分：
$$
[x]_{\text {原 }}=\left\{\begin{array}{cc}
x & 1 > x \geqslant 0 \\
1-x & 0 \geqslant x >-1
\end{array}\right.
$$
例如，当 $x= +0.1101$ 时，$[x]_{\text {原}} = 0.1101$，注意这里两个 $0.$ 的含义不同，后者表示正数+区分符

+ 不难发现，对于$0$而言，$[+0000] _{\text {原}} = 0,0000 ;\ [-0000]_{\text {原}} = 1,0000$，两者并不相同

+ 原码特点：简单且直观，但运算复杂。当两个操作数符号不同且要作加法运算时，先要判断两数绝对值大小，然后将绝对值大的数减去绝对值小的数，结果的符号以绝对值大的数为准。而且用到的是减法器实现。

  

##### 补码表示法

为了解决原码在计算中的问题，即用一个与负数等价的正数表示负数，使得运算中只需要加法器。

所谓补数，就是其本身加上 **模**。正数的补数是其自身，负数的补数是其本身加上模，当一个正数和一个负数互为补数的时候，其绝对值之和为模数。那么对于 2 进制数而言，模就是 $2^n$，但是为了能表示正负，即负数的首位为 1，选择将模设置为 $2^{n+1}$。
$$
[x]_{\text {补 }}= \begin{cases}0,\ x & 2^{n}> x \geqslant 0 \\ 2^{n+1}+x & 0 > x \geqslant-2^{n} \quad\left(\bmod 2^{n+1}\right)\end{cases}
$$
例如，$x = -1011000$，则 $[x]_{\text{补}} = 2^{7+1} + (-1011000) = 1,0101000$

小数：
$$
[x]_{\text {补 }}= \begin{cases}x & 1 > x \geqslant 0 \\ 2+x & 0 > x \geqslant-1 \quad(\bmod 2)\end{cases}
$$

例如，$x = -0.1100000$，则 $[x]_{\text{补}} = 2+(-0.1100000) = 1.0100000$

+ 我们也可以通过口诀“**原码取反（变为反码）再加 1**”快速计算一个数的补码
+ 不难发现，对于$0$而言，$[+0000] _{\text {补}} = 0,0000 ;\ [-0000]_{\text {补}} = 2^{4+1} - 0000 = 100000 -0000 = 0,0000$，最高位溢出舍去，所以补码的 0 表现形式是一致的
+ $-1$的补码为全$1$

> 设字长 = $8$ 位，$X=(80)_{16}$，当 X 为补码时，其真值的十进制表示为（   ）
>
> 解：
>
> 已知补码求原码，则求补码的补码：
>
> $(1000\ 0000) \to (1111 \ 1111) \to (1\ 0000 \ 0000) \to -0 \to -128$

##### 反码表示法

反码通常用来作为由原码求补码或者由补码求原码的中间过渡。反码的定义如下：
$$
[x]_{\text {反 }}=\left\{\begin{array}{ll}
0,\  x & 2^{n}> x \geqslant 0 \\
\left(2^{n+1}-1\right)+x & 0 \geqslant x >-2^{n}\left(\bmod 2^{n+1}-1\right)
\end{array}\right.
$$
小数：
$$
[x]_{\text {反 }}= \begin{cases}x & 1 > x \geqslant 0 \\ \left(2-2^{-n}\right)+x & 0 \geqslant x >-1 \quad\left(\bmod \left(2-2^{-n}\right)\right)\end{cases}
$$
例如，$x = -0.1010$，则
$$
\begin{align*}
[x]_{\text{反}} &= (2 - 2 ^{-4}) + (-0.1010)) \\
&= (10 - 0.0001) -0.1010 \\
&= 1.1111 - 0.1010 \\
&= 1.0101 
\end{align*}
$$

+ 简而言之为，符号位不变，正数不变，负数取反
+ 不难发现，对于$0$而言，$[+0000] _{\text {反}} = 0,0000 ;\ [-0000]_{\text {反}} = 2^{4+1}-1 - 0000 = 11111 - 0000 = 1,1111$，两者并不一致。

##### 小结

1. 最高位为符号位，书写上用“,”或“.”将数值部分与符号位分隔开
2. 对于正数，原码 = 反码 = 补码
3. 对于负数，符号位为 1。其数值部分原码取反得反码，反码加 1 得补码
4. 设机器数字长为 $n$，整数定点机表示
   1. 原码表示范围：$[-(2^{n-1}-1),+(2^{n-1}-1)]$
   2. 反码表示范围：$[-(2^{n-1}-1),+(2^{n-1}-1)]$
   3. 补码表示范围：$[-2^{n-1},+(2^{n-1}-1)]$

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8E%9F%E5%8F%8D%E8%A1%A5%E5%B0%8F%E7%BB%93.png" alt="image-20220726222748948" style="zoom:80%;" />

##### 补码加减法

整数加法： $[A]_{\text {补 }}+[B]_{\text {补 }}=[A+B]_{\text {补 }}\left(\bmod 2^{n+1}\right)$

小数加法： $[A]_{\text {补 }}+[B]_{\text {补 }}=[A+B]_{\text {补 }}(\bmod 2)$

整数减法： $[A-B]_{\text {补 }}=[A+(-B)]_{\text {补 }}=[A]_{\text {补 }}+[-B]_{\text {补 }}\left(\bmod 2^{n+1}\right)$ 

小数减法： $[A-B]_{\text {补 }}=[A+(-B)]_{\text {补 }}=[A]_{\text {补 }}+[-B]_{\text {补 }}(\bmod 2)$

+ 注意 **符号位需要参与计算**，丢弃符号位的进位（保存在进位标志寄存器中）

##### 溢出判断

1. 一位符号位判断：**参加操作的两个数（减法时即为被减数和“求补”以后的减数）符号相同，其结果的符号与原操作数的符号不同，即为溢出**。换言之，数值部分最高位的进位 $\oplus$ 符号位的进位 = 1 即为溢出。

2. 两位符号位判溢出：首先使用变形补码，其公式如下。简而言之，对于正数其变形补码（符号位）为 $00$，对于负数其变形补码（符号位）为 $11$。数值部分可以用原本的取反加一计算。
   $$
   [x]_\text{补}= \begin{cases}x & 1 > x \geq 0 \\ 4+x & 0 > x \geq-1(\bmod 4)\end{cases}
   $$

$$
[x]_{\text {补 }}= \begin{cases}0,\ x & 2^{n}> x \geqslant 0 \\ 2^{n+2}+x & 0 > x \geqslant-2^{n} \quad\left(\bmod 2^{n+2}\right)\end{cases}
$$

+ 在用变形补码作加法时，2 位符号位要连同数值部分一起参加运算，而且 **高位符号位产生的进位自动丢失**，便可得正 确结果。变形补码判断溢出的原则是：**当 2 位符号位不同时，表示溢出**，否则，无溢出。不论是否发生溢出，高位符号位永远代表其结果真正的符号。

3. 使用加法器中的进位标志 $CF$ 和溢出标志 $OF$ 进行判断，再结合操作数类型后由程序员判断
   1. 对无符号数而言，$OF=1$ 无影响，$CF =1$ 溢出
   2. 对有符号数无影响，$CF=1$ 无影响，$OF =1 $ 溢出

### 微型计算机系统的组成

计算机系统由硬件和软件两大部分组成，硬件是构成计算机的设备实体，软件是指为了运行、管理和维修计算机而编制的各种程序

#### 硬件组成

按照冯诺依曼的计算机体系逻辑结构的思想，将计算机分为五个部分：控制器、存储器、运算器、输入设备和输出设备

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%B1%87%E7%BC%96-%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC.png" alt="image-20220901082744690" style="zoom:80%;" />

其中，**运算器** 和 **控制器** 构成 **CPU** 的主要部分（还有一部分寄存器），CPU 与存储系统、I/O 接口、电源系统等组成了计算机系统的 **主机**，输入输出设备被称为 **外设**。

+ 存储器：具有记忆功能的部件，是能够接收、保存和取出信息（程序、数据和文件）的设备。这里所讲的存储器是指计算机系统的内部存储器，也称为主存储器（Main Memory），简称为内存或主存。用来存放指令和数据
+ 运算器：进行算术运算和逻辑运算的部件
+ 控制器：负责对指令进行译码，产生整个指令系统所需要的全部操作的控制信号，控制运算器、存储器和输入输出接口等部件完成指令规定的操作
+ 输入设备：输入设备通过输入接口电路将程序和数据输入内存。最常见的输入设备有键盘和鼠标
+ 输出设备：CPU 通过输出接口电路将程序运行的结果、程序和数据送到输出设备上。最常见的输出设备有显示器和打印机

#### 软件组成

不配置软件的计算机称为“裸机”，仅有裸机是不能做任何事情的，必须有软件的配合。软件又分为系统软件和应用软件两大类。

+ 系统软件：系统软件是指控制和协调计算机及外设、支持应用软件开发和运行且无需用户干预的各种程序的集合
  + 面向计算机管理的软件，如操作系统
  + 数据库管理系统
  + 语言处理程序
+ 应用软件：应用软件是计算机用户在各自的业务领域中开发和使用的各种软件，是为解决某一实际问题而编制的程序

#### 硬件结构

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220901084435.png" alt="image-20220901084435703" style="zoom:80%;" />

1. 总线

   总线是连接 CPU 与存储器、I/O 接口的公共导线，是各部件信息传输的公共通道。微型计算机系统有 3 种总线，它们是 **地址总线**、**数据总线** 和 **控制总线**

   + 地址总线传输地址信息，用来寻址存储单元和 I/O 端口。地址总线的“宽度”决定了 **系统内存的最大容量**。一个 cpu 有 $n$ 根地址线, 则该 cpu 的地址总线宽度为 $n$, 最多可以寻址 $2^n$ 内存单元。8088/8086 有$20$根地址线，能寻址$1MB$内存
   + 数据总线传输数据信息，数据总线的宽度决定了 cpu 与其他器件进行数据传送时的 **一次性数据传送量**。16 根总线一次可以传送 $2$ 字节($16bit$)
   + CPU 对外部器件的控制是通过控制总线来进行的。控制总线是一些不同控制线的集合。控制总线的宽度决定了 CPU 对系统中其他器件的控制能力
   + 从信息流向的角度讲，**地址总线通常是单向总线**，地址信息由 CPU 发出。**数据总线是双向总线**。**控制总线也是双向总线**，其中大部分控制线是单向控制线，它们是 CPU 发出的操作命令，或者是其他部件向 CPU 提出的请求信号，只有少数控制线是双向控制线。

| 处理器 | 地址总线 | 数据总线   |
| ------ | -------- | ---------- |
| 8088   | 20       | 内 16 外 8 |
| 80286  | 24       | 16         |
| 80486  | 32       | 32         |

2. 存储器

构成存储器的存储介质，目前主要采用半导体器件和磁性材料。一个双稳态半导体电路或磁性材料的 **存储元**，均可以存储一位二进制代码，称为 `1b`。这个二进制代码位是存储器中最小的存储单位，称为一个存储位或存储元。若干个存储元可以组成一个 **存储单元**（通常为 8 个 `bit` 组成一个字节），许多存储单元可以组成一个 **存储体**。存储体和地址译码电路、读写控制电路等一起构成 **存储器**

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220901092339.png" alt="image-20220901092339615" style="zoom: 50%;" />

每个存储单元都有一个唯一的标识符，这个标识符称为该存储单元的 **地址**。在计算机中，地址用一串二进制数来表示，为方便起见，书写格式通常采用 **十六进制形式**。通常，用 KB($2^{10}B$)、MB($2^{20}B$)或 GB($2^{30}B$)作为存储器的 **容量单位**。

按照存储器的读写功能分类：

+ 随机存储器：RAM 为随机（读/写）存储器，即通常所讲的内存。所谓 **静态 RAM**：集成度低，信息稳定，读写速度快，可以组成高速缓冲存储器 Cache；所谓 **动态 RAM**：集成度高，容量大，缺点是信息存储不稳定，只能保持几个毫秒，为此要不断进行“信息再生”，即进行 “刷新”操作。 内存条就是用动态 RAM 制作的。

+ 只读存储器：ROM 只读存储器多与 BIOS 相关（Basic Input/Output System，基本输入/输出系统），主板上的 ROM 存储这主板的 BIOS，显卡上的 ROM 存储显卡的 BIOS。


3. I/O 接口

   设备控制器是 CPU 与 I/O 设备之间的接口，它接收 CPU 发来的命令，去控制 I/O 设备工作

   当 CPU 要操作 I/O 设备时，首先要启动这个设备，一方面将启动命令发送给设备控制器，另一方面通过地址线将 I/O 设备的地址发给设备控制器，设备控制器的 I/O 逻辑对收到的地址进行译码，再根据所译出的命令对相应的设备进行操作。

   

#### 计算机的工作过程

程序是指令的有序集合，而指令是以二进制代码的形式出现的。把执行一项信息处理任务的程序代码，以字节为单位，按顺序存放在存储器的一段连续的存储区域内，这就是冯诺依曼 **程序存储** 的概念。简单地讲，微型计算机的工作过程是取指令（代码）$\to$ 分析指令（译码）$\to$ 执行指令的不断循环过程

1. 取指令

   从存储器某个地址单元中取出要执行的指令代码送到 CPU 内部的 **指令寄存器** 暂存

2. 分析指令

   称为指令译码，把保存在指令寄存器中的指令代码送到 **指令译码器**，译出该指令对应的微操作信号，控制各个部件

3. 取操作数

   发出取数据命令，到存储器取出所需的操作数

4. 执行指令

   根据指令译码，向各个部件发出相应控制信号，完成指令规定的各种操作

5. 保存结果

   如果需要保存计算或信息处理结果，则把结果保存到指定的存储器单元或者其他目的地

## 80X86 微处理器

一些常用名词：

+ 字长（数据宽度）：微处理器一次可以直接处理的二进制数码的 **位数**，它通常取决于微处理器内部 **通用寄存器** 的位数和 **数据总线** 的宽度
+ 寻址能力：指 CPU 能直接存取数据的 **内存地址** 的范围，它由 CPU 的 **地址总线** 的数目决定
+ 主频（时钟频率）：用来表示微处理器的运行速度，主频越高 ，表明微处理器运行越快，主频的单位是 MHz、GHz
+ MIPS（Millions of Instruction Per Second）：每秒钟能执行多少百万条指令
+ 微处理器的集成度：微处理器芯片上集成的晶体管数目

### 16 位微处理器内部结构

> Intel 8086 CPU 与随后推出的 8088 CPU 比较类似。8086CPU 是 16 位微处理器，它有 16 根数据线和 20 根地址线，所以可寻址的地址空间是 $2^{20}B = 1MB$。8088CPU 的内部寄存器、内部运算部件以及内部操作都是按 16 位设计的，但对外的数据总线只有 8 位，在处理一个 16 位数据时，8088 需要两步操作，因而称 8088 是准 16 位微处理器。后来推出的 80286，它的内部结构除了具备 8086/8088 最基本的功能外，还增加了虚拟存储、特权保护、任务管理等功能，所以支持多用户和多任务系统。

#### 内部结构

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/8086/8088%E7%BB%93%E6%9E%84.png" alt="image-20220906091341708" style="zoom:80%;" />

+ **总线接口单元** 由段寄存器（`CS`、`DS`、`SS`、`ES`）、指令指针寄存器（`IP`)、内部暂存器、指令队列、地址加法器及总线控制电路组成。它的主要作用是负责执行所有的外部总线操作
+ **执行单元** 由通用寄存器、运算数暂存器、算术逻辑单元（`ALU`）、标志寄存器（`FLAGS`）及 `EU` 控制电路组成。它的主要作用是分析和执行指令
+ 指令队列主要使 `EU` 和 `BIU` 并行工作，取指令操作、分析指令操作重叠进行，从而形成了 **两级指令流水线结构**，减少了 CPU 为取指令而必须等待的时间，提高了 CPU 的利用率，加快了整机运行速度，也降低了对存储器存取速度的要求

#### 寄存器结构

##### 通用寄存器

8086/8088 微处理器的执行单元中有 8 个 **16 位** 的通用寄存器，这些寄存器都可以存放数据或地址，并能进行 **16 位和 8 位** 的数据运算

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220906092902.png" alt="通用寄存器" style="zoom:67%;" />

+ 数据寄存器
  + `AX` 称为累加器（Accumulator）使用频度最高，用于算术、逻辑运算以及与外设传送信息
  + `BX` 称为基址寄存器（Basc Address Rcgister）常用作存放存储器地址
  + `CX` 称为计数器（Counter）作为循环和串操作等指令中的隐含计数器
  + `DX` 称为数据寄存器（Data Register）常用来存放双字长数据的高 16 位，或存放外设端口地址
  + 这四个数据寄存器可作为两个独立的 **8 位寄存器** 使用，低位字节的寄存器分别称为 `AL,BL,CL,DL`，高位字节的寄存器分别称为 `AH,BH,CH,DH`
+ 变址寄存器
  + `SI` 称为源变址寄存器（Source Index）
  + `DI` 是目的变址寄存器（Destination Index）
  + 常用于存储器变址寻址方式提供地址。在串操作类指令中，用于存放串首或串尾数据单元的偏移地址
+ 指针寄存器
  + `SP` 为堆栈指针寄存器（Stack Pointer），指示堆栈段栈顶的位置（偏移地址）
  + `BP` 为基址指针寄存器（Base Pointer）
  + `SP` 和 `BP` 寄存器与 `SS` 段寄存器联合使用以确定堆栈段中的存储单元地址

##### 段寄存器

CPU 内部有 4 个段寄存器。8086/8088 CPU 对寻址的 $1MB$ 内存区域是分段管理的，定义的代码段用于存放指令代码，数据段和附加数据段用于存放数据，堆栈段是按照先进后出的访问原则组织起来的一段内存区域。这 4 个段寄存器为存储器分段管理技术提供了硬件支持

+ `CS` 称为代码段寄存器，用于存放 **代码段** 的 **段基址**
+ `DS` 称为数据段寄存器；`ES` 称为附加段寄存器，两者都用于存放 **数据段** 和 **附加数据段** 的 **段基址**
+ `SS` 称为堆栈段寄存器，用于存放 **堆栈段** 的 **段基址**

##### 指令指针寄存器

`IP`（Instruction Pointer）为指令指针寄存器，指示内存中指令的位置。随着指令的执行，IP 将自动修改以指示下一条指令所在位置。`IP` 是一个 **专用寄存器**，与 `CS` 联合使用以确定下一条指令的存储单元地址

##### 标志寄存器

执行单元 `EU` 中有一个标志寄存器 `FLAGS`，16 位的 `FLAGS` 可分为标志位和控制位，**标志位** 指明程序运行时微处理器的实时状态；**控制位** 由程序设计者设置，以控制 CPU 进行某种操作

### 32 位微处理器内部结构

> Pentium 微处理器的内部寄存器长度都为 $32$ 位，但外部数据总线不像 80386 和 **80486** 那样是 $32$ 位，而是 $64$ 位，总线传输速度高达 $66MHz$。同时它具有 $32$ 位地址总线，可直接寻址 $4GB$ 的物理内存空间。它有两条相对独立的指令并行流水线，即 U 流水线和 V 流水线

#### 内部结构

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220906094633.png" alt="image-20220906094633289" style="zoom:80%;" />

+ **总线接口单元** 实现 CPU 与系统总线的连接，其中包括 64 位数据线、32 位地址线和众多控制信号线，以此实现相互之间的信息交换，并产生相应的总线周期信号
+ **分段分页单元** 完成将各种地址映射到内存物理地址的功能
+ **高速缓存** 即 Cache，是容量较小、速度很高的可读写 RAM，用来存放 CPU 最近要使用的数据和指令，Cache 可以加快 CPU 存取数据的速度，减轻总线负担。在 Pentium 微处理器内部，指令 Cache 和数据 Cache 是分开的，目的是提高访问的 **命中率**
+ **指令预取部件** 每次可以取两条指令，如果是简单指令，并且后一条指令不依赖前一条指令的执行结果，那么，指令预取部件便将两条指令分别送到 U 流水线和 V 流水线独立执行
+ **指令 Cache、指令预取部件** 将原始指令送到指令译码器，分支目标缓冲器则在遇到分支转移指令时用来预测转移是否发生
+ **浮点处理单元** 主要用于浮点运算，内含专用的加法器、乘法器和除法器，加法器和乘法器均能在 3 个时钟周期内完成相应的运算，除法器则在每个时钟周期产生 2 位二进制商
+ **控制 ROM** 中含有 Pentium 微处理器的微代码，控制部件直接控制流水线操作。

#### 寄存器结构

80486 内部寄存器分为四类：基本结构寄存器、浮点寄存器、系统级寄存器、调试测试寄存器。应用程序只能访问基本结构寄存器和浮点寄存器。这里只介绍基本结构寄存器，**除了标志寄存器外，其余寄存器的命名和使用方法都没有改变**。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220906095449.png" alt="image-20220906095449778" style="zoom:80%;" />

##### 通用寄存器

能进行 32 位运算的寄存器分别称为 `EAX`、`EBX`、`ECX`、`EDX`、`ESI`、`EDI`、`EBP` 和 `ESP`。其中 `EAX`、`EBX`、`ECX`、`EDX` 的 **低 16 位** 构成了 16 位微处理器中的通用寄存器（去掉 E），然后 **低 16 位** 又可以进一步拆成 **两个 8 位** 通用寄存器。

##### 段寄存器

**6 个 16 位的段寄存器** 用于指示代码和数据所用的地址空间。代码段寄存器 `CS`、堆栈段寄存器 `SS`、`DS`、`ES`、`FS` 和 `GS` 都称为数据段寄存器，除 `CS` 用于指示指令代码的地址空间外，其他段寄存器都用于指示 **数据** 的地址空间。当微处理器工作在 **实地址模式** 下，这些段寄存器提供的内容就是 **16 位的段基址**

| 逻辑段 | 段基址存放 | 偏移地址存放                     | 初始值               |
| ------ | ---------- | -------------------------------- | -------------------- |
| 代码段 | CS         | IP                               | 操作系统赋值         |
| 堆栈段 | SS         | SP                               | 程序员或操作系统赋值 |
| 数据段 | DS         | 根据不同的寻址方式选择 BX、SI、DI | 程序员赋值           |
| 附加段 | ES/FS/GS   | 根据不同的寻址方式选择 BX、SI、DI | 程序员赋值           |

##### 指令指针寄存器

`EIP` 中存放相对于代码段寄存器 `CS` 的基址的偏移量。`EIP` 的低 16 位可作为独立使用的寄存器，称为 `IP`, 它在实地址模式下，与 `CS` 组合后，形成 20 位的物理地址

##### 标志寄存器

标志寄存器是 32 位的寄存器，称为 `EFLAGS`。`EFLAGS` 中的位同样分为状态标志位和控制标志位两类：

+ 状态标志位指明程序运行时的微处理器的实时状态，这种状态会像某种先决条件一样影响后面的操作。有 SF、ZF、PF、CF、AF 和 OF
+ 控制标志位由程序设计者设置，有 DF、 IF、 TF。每个控制标志都对某一种特定的功能起控制作用
+ `EFLAGS` 的低位也可作为一个独立的标志寄存器 `FLAGS`（又称为程序状态字 `PSW`）来使用。

### 32 位微处理器工作模式

> 80x86 系列的 32 位微处理器（80386 及其后继处理器）支持 16 位和 32 位指令系统，32 位指令系统是在 16 位指令系统的基础上扩展而成的。32 位处理器有 3 种工作模式：实地址模式（Real Address Mode)、保护虚拟地址模式(Protected Virtual Address Mode)和虚拟 8086 模式，简称为实模式、保护模式和虚拟 86 模式。

#### 32 位微处理器地址空间

80X86 系列的 32 位微处理器有 3 个明确的存储地址空间，它们是 **物理空间**、**虚拟空间** 和 **线性空间**。

+ 物理空间是计算机中主存储器的实际空间，也称为主存空间，相应的地址称为 **物理地址** 或 **主存地址**。任一存储单元都具有唯一的一个物理地址。对主存的访问最终必须通过物理地址来实现。32 位微处理器有两个独立的物理空间：一个是 **物理存储空间**，另一个是 **物理 I/O 空间**。80X86 的物理 I/O 空间由$2^{16}(64K)$个地址组成。它与存储地址不重叠
  + 8086：20 根地址线，寻址范围$1M$
  + 80486：32 根地址线，寻址范围$4GB$

+ **虚拟空间又称为逻辑空间**，是应用程序员编写程序的空间，此空间对应的存储器称为虚拟存储器，该存储空间对应的地址称为虚拟地址或逻辑地址。该空间可比主存实际能提供的空间大很多，即使主存空间不够大，也能运行程序员编写的程序
+ 32 位微处理器通过 **分段部件** 把虚拟空间变换为 32 位的 **线性空间**，如果分页部件未被选用（实模式），线性地址就是物理地址

#### 32 位微处理器工作模式

##### 实地址模式

> 在实模式下，32 位微处理器与它的前款处理器 16 位的 8086 兼容，所以为 8086、80286 编写的程序不需要做任何修改，就可以在 32 位微处理器的实模式下运行，且速度更快。除此之外，在实模式下，还能有效地使用 8086 所没有的寻址方式、32 位寄存器和大部分指令。在实模式下，32 位微处理器具有与 8086 同样的基本体系结构。

实地址的特点：

1. 加电、复位之后，486 自动工作在实模式，系统在 DOS 管理下
2. 在实模式下，微处理器的地址线仅低 20 根启动，所以 486 只能访问最低端的 $1M$ 内存（$00000H\sim FFFFFH$）
3. 存储管理部件对存储器只进行分段管理，**没有分页功能（线性地址即为物理地址）**，每一逻辑段的最大容量为 $64K$
4. 该模式下，段寄存器中存放段基址

实地址物理地址形成: star:

实地址模式下，物理地址的地址信息是 20 位的二进制代码，以 16 进制表示是 $00000H\sim FFFFFH$ 中的一个单元，CPU 访问存储器时，地址总线上送出的是 20 位物理地址。但是由于之前的 8086/8088 处理的数据总线宽度只有 16 位，无法传输 20 位的地址，所以在 **编程（虚拟）空间** 引入了 **逻辑地址**，即 **段地址：偏移地址** 的模式，即用 4 个 16 进制表示物理地址。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220906103752.png" alt="image-20220906103752489" style="zoom:67%;" />

系统将内存分为若干个逻辑段（最大 $64K$），在同一逻辑段中，各单元的 16 位段地址是相同的，偏移地址是该单元相对于段首的 16 位地址偏移量。系统默认时，段都起始于 16 字节的边界，即段起始物理地址为 $XXXX0H$

+ 计算方法：将段地址左移 4 位后与偏移地址相加
  > 段寄存器 `CS` 内容为 $1000H$，偏移地址在 `IP` 寄存器中，为 $2345H$
  >
  > <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220906104115.png" alt="image-20220906104115472" style="zoom: 50%;" />

+ 物理地址唯一，逻辑地址不唯一（取决于分段的方式）

#### 保护虚拟地址模式

特点：

1. 486 支持多任务操作系统
2. 486 可以访问 4G 物理存储空间
3. CPU 内部的存储管理部件对存储器采用分段和分页管理。可以将磁盘等存储设备有效映射到内存，使逻辑地址空间大大超过实际的物理地址空间，这样使主存储器容量似乎很大
4. 既能进行 16 位运算，也能进行 32 位运算。

保护机制：高级别的程序可以访问同级或低级的数据段，反之则不行

#### 虚拟 8086 模式

> 32 位微处理器允许在实模式和保护模式下执行 8086 的应用程序。后者为系统设计人员提供了 32 位微处理器保护模式的全部功能，因而具有更大的灵活性。保护模式的功能之一是能够在保护和多任务的环境中直接执行实模式的 8086 软件，这个特性称为虚拟 8086 模式，又简称为虚拟 86 模式，这不是一种实际的处理器方式，而是一种准操作方式。虚拟 8086 模式具有保护方式下的任务属性。

1. 可以执行 8086 的应用程序
2. 段寄存器的用法和实模式一样，即段寄存器内容左移 $4$ 位加上偏移地址即为线性地址
3. 存储器寻址空间为 $1MB$
