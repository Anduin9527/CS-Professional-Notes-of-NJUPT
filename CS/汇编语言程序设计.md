# 汇编语言程序设计

## 微型计算机基础

### 数制

#### 数制

用进位的方法进行计数的体制称为 **进位计数制**。

设一个 $R$ 进制的的数 $N:(N)_R$, 该数制的三要素有：

+ 数码：0~R-1，进位规律：逢 R 进 1，借 1 当 R
+ 位权：$R^i$，数码在一个数中的位置不同，其大小就不同。$i$ 为数码所在的位置，称为 **数位**。
+ 基数：数码的进制数 $R$ ，也称为底数。
  + 十进制（D）：Decimal
  + 二进制（B）：Binary
  + 八进制（O）：Octal
  + 十六进制（H）：Hexadecimal

| 计数制   | 数码 | 位权   | 基数 | 举例                      |
| -------- | ---- | ------ | ---- | ------------------------- |
| 十进制   | 0~9  | $10^i$ | 10   | $(123)_{10}$ $(45.321)_D$ |
| 二进制   | 0~1  | $2^i$  | 2    | $(1010)_2$ $(1001.101)_B$ |
| 八进制   | 0~7  | $8^i$  | 8    | $(567)_8$ $(765)_O$       |
| 十六进制 | 0~F  | $16^i$ | 16   | $({2A2B})_{16}$           |

#### 进制转换

非十进制-> 十进制：按 **位权** 展开后相加（各位上的数字乘位权后相加）

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220830084154.png" alt="image-20220830084154761" style="zoom:67%;" />

十进制-> 非十进制：基数乘除法（整数除基取余数倒序排、小数乘基取整数正序排）

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220830084108.png" alt="image-20220830084108819" style="zoom: 67%;" />

#### 精度

1. $n$ 位 $R$ 进制的小数精度为：$R^{-n}$

2. 确定转换进度，要求转换后的精度不低于原精度（原精度数值大）

#### 常见进制转化

$Bin\to Oct(Hex)$：

+ 三(四)位一段，不足补零
+ 整数向左，小数向右

$Oct(Hex)\to Bin$：

+ 一位翻三(四)，不足补零
+ 整数向左，小数向右

$Oct\to Hex： Oct\to Bin\to Hex$

### 码制（编码的制式）

由于数字系统只能识别 0 和 1，为了表示更多的数字、符号和字母，我们需要引入编码的概念。即用一定为数的二进制数字来表示这些信息。编码所得的每组符号称为 **代码或者码字**，代码中的每个符号称为 **基本代码或码元**。

#### 字符的编码–ASCII 码

采用美国标准信息交换码（ASCII）对字符进行编码。使用 **七位二进制编码** 来表示一个字符。该编码方案中共有 128 个字符。

> 由于一个字节为 8 位，所以将 ASCII 的最高位置为 1。（或者作为奇偶校验位）

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/ASCII.png" alt="image-20220830084643343" style="zoom:80%;" />

+ 比如在键盘键入“A”，则输入的二进制串为$0100 \ 0001 B$，即$41H$
+ $0\sim 9$ 的 ASCII 码为 $30H\sim 39H$
+ $A \sim F$的 ASCII 码为$41H \sim 46H$
+ 回车符的 ASCII 码为 $ODH$
+ 换行符的 ASCII 码为 $OAH$



#### 十进制数的二进制编码–BCD 码

> 这种编码技术，最常用于 [会计系统](https://zh.wikipedia.org/wiki/會計系統) 的设计里，因为会计制度经常需要对很长的数字做准确的计算。相对于一般的 [浮点式](https://zh.wikipedia.org/w/index.php?title=浮點式&action=edit&redlink=1) 记数法，采用 BCD 码，既可保存数值的精确度，又可使电脑免除作浮点运算所耗费的时间。此外，对于其他需要高精确度的计算，BCD 编码亦很常用。
>
> BCD 码的主要优点是在机器格式与人可读的格式之间转换容易，以及十进制数值的高精度表示。BCD 码的主要缺点是增加了实现算术运算的电路的复杂度，以及存储效率低。



BCD 码有多种形式，最常用的是 8421BCD 码，它是用 4 位二进制数对一个十进制数进行编码，这 4 位二进制码的值就是被编码的一位十进制数的值。8421BCD 码是十进制代码中最常用的一种。在这种编码方式中，每一位二值代码的“1”都代表一个固定数值。将每位“1”所代表的十进制数加起来就可以得到它所代表的十进制数码。因为代码中从左至右看每一位“1”分别代表字“8”“4”“2”“1”，故得名 8421 码。其中每一位“1”代表的十进制数称为这一位的权。因为每位的权都是固定不变的，所以 8421 码是 **恒权码**。

+ 用四位二进制数 $b_3b_2b_1b_0$ 来表示十进制数的 0~9 十个数码，$b_3 \to 8, b_2 \to 4 , b_1 \to 2, b_0 \to 1$

+ 修正：在加法运算中：加 6（0110）
  + 相加后得到非法码（大于 1001）
  + 相加后产生进位
  + 若加 6 修正后，产生非法码，则再加 6。
+ BCD 码在计算机中的存储分为紧凑型和非紧凑型两种：
  + 紧凑型 BCD 码：$(37)D = 0011,0111B$
  + 非紧凑型 BCD 码：$(37)D = 0000,0011B \quad 0000,0111B$


| 十进数  |  8421   |
| :-----: | :-----: |
| （M10） | D C B A |
|    0    | 0 0 0 0 |
|    1    | 0 0 0 1 |
|    2    | 0 0 1 0 |
|    3    | 0 0 1 1 |
|    4    | 0 1 0 0 |
|    5    | 0 1 0 1 |
|    6    | 0 1 1 0 |
|    7    | 0 1 1 1 |
|    8    | 1 0 0 0 |
|    9    | 1 0 0 1 |

#### 有符号数的编码–原、反、补码

无符号数：计算机中的数均放在 **寄存器** 中，通常称寄存器的位数为 **机器字长**。**所谓无符号数，即没有符号的数**，在寄存器中的每一位均可用来存放数值。当存放有符号数时，则需留出位置存放符号。因此，在机器字长相同时，无符号数与有符号数所对应的数值范围是不同的。比如用一个八位的寄存器保存无符号数，则可以表示 $0\sim 255$。

##### 机器数与真值

因为计算机没有办法直接识别正负号，所以需要将正负号转化为数字来存储。保存在计算机中将正负号“数字化”之后的数称为 **机器数**，而 **真值** 是我们日常生活中包含了正负号的数值。注意：以下内容默认都为 2 进制数

##### 原码表示法

原码是机器数中最简单的一种表示形式，符号位为 0 表示正数，符号位为 1 表示负数，**数值位即真值的绝对值**，故原码表示又称为带符号的绝对值表示。为了书写方便以及区别整数和小数，约定整数的符号位与数值位之间用逗号隔开；小数的符号位与数值位之间用小数点隔开。由此可得原码的定义：
$$
[x]_{\text {原}}=\left\{\begin{array}{cc}
0, \ x & 2^{n}> x \geqslant 0 \\
2^{n}-x & 0 \geqslant x > -2^{n}
\end{array}\right.
$$
例如，当 $x= -1110$ 时，$[x]_{\text {原}} = 2^4 - (-1110) = 1,1110$

对于小数部分：
$$
[x]_{\text {原 }}=\left\{\begin{array}{cc}
x & 1 > x \geqslant 0 \\
1-x & 0 \geqslant x >-1
\end{array}\right.
$$
例如，当 $x= +0.1101$ 时，$[x]_{\text {原}} = 0.1101$，注意这里两个 $0.$ 的含义不同，后者表示正数+区分符

+ 不难发现，对于$0$而言，$[+0000] _{\text {原}} = 0,0000 ;\ [-0000]_{\text {原}} = 1,0000$，两者并不相同

+ 原码特点：简单且直观，但运算复杂。当两个操作数符号不同且要作加法运算时，先要判断两数绝对值大小，然后将绝对值大的数减去绝对值小的数，结果的符号以绝对值大的数为准。而且用到的是减法器实现。

  

##### 补码表示法

为了解决原码在计算中的问题，即用一个与负数等价的正数表示负数，使得运算中只需要加法器。

所谓补数，就是其本身加上 **模**。正数的补数是其自身，负数的补数是其本身加上模，当一个正数和一个负数互为补数的时候，其绝对值之和为模数。那么对于 2 进制数而言，模就是 $2^n$，但是为了能表示正负，即负数的首位为 1，选择将模设置为 $2^{n+1}$。
$$
[x]_{\text {补 }}= \begin{cases}0,\ x & 2^{n}> x \geqslant 0 \\ 2^{n+1}+x & 0 > x \geqslant-2^{n} \quad\left(\bmod 2^{n+1}\right)\end{cases}
$$
例如，$x = -1011000$，则 $[x]_{\text{补}} = 2^{7+1} + (-1011000) = 1,0101000$

小数：
$$
[x]_{\text {补 }}= \begin{cases}x & 1 > x \geqslant 0 \\ 2+x & 0 > x \geqslant-1 \quad(\bmod 2)\end{cases}
$$

例如，$x = -0.1100000$，则 $[x]_{\text{补}} = 2+(-0.1100000) = 1.0100000$

+ 我们也可以通过口诀“**原码取反（变为反码）再加 1**”快速计算一个数的补码
+ 不难发现，对于$0$而言，$[+0000] _{\text {补}} = 0,0000 ;\ [-0000]_{\text {补}} = 2^{4+1} - 0000 = 100000 -0000 = 0,0000$，最高位溢出舍去，所以补码的 0 表现形式是一致的

##### 反码表示法

反码通常用来作为由原码求补码或者由补码求原码的中间过渡。反码的定义如下：
$$
[x]_{\text {反 }}=\left\{\begin{array}{ll}
0,\  x & 2^{n}> x \geqslant 0 \\
\left(2^{n+1}-1\right)+x & 0 \geqslant x >-2^{n}\left(\bmod 2^{n+1}-1\right)
\end{array}\right.
$$
小数：
$$
[x]_{\text {反 }}= \begin{cases}x & 1 > x \geqslant 0 \\ \left(2-2^{-n}\right)+x & 0 \geqslant x >-1 \quad\left(\bmod \left(2-2^{-n}\right)\right)\end{cases}
$$
例如，$x = -0.1010$，则
$$
\begin{align*}
[x]_{\text{反}} &= (2 - 2 ^{-4}) + (-0.1010)) \\
&= (10 - 0.0001) -0.1010 \\
&= 1.1111 - 0.1010 \\
&= 1.0101 
\end{align*}
$$

+ 简而言之为，符号位不变，正数不变，负数取反
+ 不难发现，对于$0$而言，$[+0000] _{\text {反}} = 0,0000 ;\ [-0000]_{\text {反}} = 2^{4+1}-1 - 0000 = 11111 - 0000 = 1,1111$，两者并不一致。

##### 小结

1. 最高位为符号位，书写上用“,”或“.”将数值部分与符号位分隔开
2. 对于正数，原码 = 反码 = 补码
3. 对于负数，符号位为 1。其数值部分原码取反得反码，反码加 1 得补码
4. 设机器数字长为 $n$，整数定点机表示
   1. 原码表示范围：$[-(2^{n-1}-1),+(2^{n-1}-1)]$
   2. 反码表示范围：$[-(2^{n-1}-1),+(2^{n-1}-1)]$
   3. 补码表示范围：$[-2^{n-1},+(2^{n-1}-1)]$

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8E%9F%E5%8F%8D%E8%A1%A5%E5%B0%8F%E7%BB%93.png" alt="image-20220726222748948" style="zoom:80%;" />

##### 补码加减法

整数加法： $[A]_{\text {补 }}+[B]_{\text {补 }}=[A+B]_{\text {补 }}\left(\bmod 2^{n+1}\right)$

小数加法： $[A]_{\text {补 }}+[B]_{\text {补 }}=[A+B]_{\text {补 }}(\bmod 2)$

整数减法： $[A-B]_{\text {补 }}=[A+(-B)]_{\text {补 }}=[A]_{\text {补 }}+[-B]_{\text {补 }}\left(\bmod 2^{n+1}\right)$ 

小数减法： $[A-B]_{\text {补 }}=[A+(-B)]_{\text {补 }}=[A]_{\text {补 }}+[-B]_{\text {补 }}(\bmod 2)$

+ 注意 **符号位需要参与计算**，丢弃符号位的进位（保存在进位标志寄存器中）

##### 溢出判断

1. 一位符号位判断：参加操作的两个数（减法时即为被减数和“求补”以后的减数）符号相同，其结果的符号与原操作数的符号不同，即为溢出。换言之，数值部分最高位的进位 $\oplus$ 符号位的进位 = 1 即为溢出。

2. 两位符号位判溢出：首先使用变形补码，其公式如下。简而言之，对于正数其变形补码（符号位）为 $00$，对于负数其变形补码（符号位）为 $11$。数值部分可以用原本的取反加一计算。
   $$
   [x]_\text{补}= \begin{cases}x & 1 > x \geq 0 \\ 4+x & 0 > x \geq-1(\bmod 4)\end{cases}
   $$

$$
[x]_{\text {补 }}= \begin{cases}0,\ x & 2^{n}> x \geqslant 0 \\ 2^{n+2}+x & 0 > x \geqslant-2^{n} \quad\left(\bmod 2^{n+2}\right)\end{cases}
$$

+ 在用变形补码作加法时，2 位符号位要连同数值部分一起参加运算，而且 **高位符号位产生的进位自动丢失**，便可得正 确结果。变形补码判断溢出的原则是：**当 2 位符号位不同时，表示溢出**，否则，无溢出。不论是否发生溢出，高位符号位永远代表其结果真正的符号。

3. 使用加法器中的进位标志 $CF$ 和溢出标志 $OF$ 进行判断，再结合操作数类型后由程序员判断
   1. 对无符号数而言，$OF=1$ 无影响，$CF =1$ 溢出
   2. 对有符号数无影响，$CF=1$ 无影响，$OF =1 $ 溢出

