

## 引论

### 程序设计语言的翻译机制

1. 汇编程序：源语言是某种 **汇编语言**，其目标语言是 **机器语言** 的 **翻译程序** 被称为汇编程序。汇编程序一般对源程序进行两遍扫描来完成翻译。第一遍进行 **存储分配**，构造出第二遍扫描时用的各种表格；第二遍 **用机器操作码代替源程序中的符号**

2. 编译程序：是将高级语言写的源程序翻译成目标语言（汇编语言、机器语言）的程序。这种翻译过程称为编译

3. 解释程序：将高级语言写的源程序作为输入数据，但并不产生目标程序，而是边解释边执行源程序本身的一种程序。解释程序主要优点是易于为用户提供调试功能，对源程序的语法分析及出错处理都很及时，修改调试也很方便，但是解释程序执行速度较慢，运行效率低。**跨平台** 无需额外操作

#### 典型的翻译机制

1. `C` 语言翻译机制：纯编译

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/C%E8%AF%AD%E8%A8%80%E7%BF%BB%E8%AF%91%E6%9C%BA%E5%88%B6.png" alt="image-20220902204754550" style="zoom:67%;" />

   

2. `JAVA` 翻译机制：先编译后解释

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220902204841.png" alt="image-20220902204841227" style="zoom:67%;" />

   

3. `C#` 翻译机制：先编译再编译

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220902204941.png" alt="image-20220902204941370" style="zoom:67%;" />

   

从上述对源程序的处理过程可以看出现代高级程序设计语言编译程序的发展趋势：从“一次编译”非托管到“编译+解释”或“编译+编译”的二次托管。

### 编译程序概述

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220902205116.png" alt="image-20220902205116218" style="zoom:80%;" />

#### 编译程序流程

1. 词法分析
   1. 扫描源程序进行读符号，删除无用字符（如空格、注释等）
   2. 将一个个有独立意义的单词识别出来，并且转换成 **统一长度的内部编码**
   3. 建立有关表格（如名字特征表、常数表），进行词法检查以供语法和语义分析用

2. 语法分析
   1. 将词法分析后所有单词组成句子，根据不同高级语言不同语法规则来分析这些句子乃至程序是否正确

3. 语义分析和中间代码生成
   1. 根据语义分析语句的含义，可将源程序表示成一种内部形式（中间语言）或直接生成目标程序
   2. 中间代码的形式有很多种，包含：后缀表达式、三元式、四元式等

4. 代码优化
   1. 生成中间代码的目标是为了实现代码优化，以便生成更高质量的目标代码

5. 目标代码生成
   1. 目标代码生成就是将中间语言代码转换成机器语言程序或汇编语言程序，最后完成翻译


#### 编译程序的前端和后端

与源语言相关的部分被称为编译前端，包括 **词法分析、语法分析、语义分析及中间代码** 生成 3 个阶段；与目标语言相关的部分被称为编译后端，包括 **代码优化和目标代码生成** 2 个阶段。将编译程序划分为编译前端和编译后端，不仅有利于代码优化，而且对目标代码的生成和移植更有利

1. 可以给同一个编译前端配不同的编译后端，这样就能在不同的计算机上构造出同一语言的编译程序。例如，`Java`
2. 可以给不同的编译前端配同一编译后端，这样就可以在同一计算机上生成多种语言的编译程序。例如，被广泛使用的 `GCC`，其编译前端是多种程序设计语言的不同分析器。`GCC` 以这些语言的源程序文件作为输入，经过词法分析、语法分
   析和语义分析，产生一种抽象语法树（Abstract Syntax Tree：AST）形式的中间代码；`GCC` 的编译后端对 **AST** 形式的中间代码进行分析处理，最终产生目标代码

#### 编译程序的分遍

+ 一遍扫描编译程序：

  在编译程序的工作过程中，词法分析、语法分析、语义分析及中间代码生成、代码优化、目标代码生成这 5 个阶段的工作可以只对源程序进行一次扫描，也可以对源程序或等价源程序进行若干次扫描。对源程序或等价源程序进行相关的加工处理工作，称为遍（Pass)。

+ 多遍扫描编译程序：

  把源程序分为几遍来编译，每遍只完成编译程序中的一部分或几部分工作，称为多遍的编译程序

  优点：加工充分；出错处理细致；目标程序质量高
  缺点：编译时间长，开销大

### 编译程序的构造方法

#### 编写编译程序的一般方法

1. 机器语言和汇编语言直接编写

   优点：针对具体机器，充分发挥计算机系统功能；生成的程序效率高

   缺点：难读难写；易出错、难维护；生产效率低

2. 使用高级语言进行编写
   并非所有高级语言都适合编写编译程序。能够编写编译程序或其他系统软件的高级语言称为 **系统程序设计语言**。例如，`Pascal`、`C`、`C++`、`Java` 等

3. 编译程序的自动生成

   源语言的定义以及机器语言的描述输入到软件中，自动生成该语言编译程序

   词法分析程序：`Lex`、`Flex` 等

   语法分析程序：`Yacc`、`ANTLR` 等

#### 构造编译程序的开发技术

##### T 型图

一个编译程序通常会涉及 3 种语言：源语言、目标语言和书写语言。源语言和目标语言体现了编译程序的功能，书写语言描述了编译程序所需的 **运行环境**。三者之间的关系可用 T 型图来表示，左上角是源语言 S，右上角是目标语言 D，底部是书写语言 W。该 T 型图代表源语言 S 的编译程序，意思是“书写语言 W 编写的源语言 S 的编译程序，其目标语言是 D”，简记为 $C_W^{S\sim D}$

##### 自编译

如果一种高级语言与之相应的编译程序也能直接用 **该语言本身写出来**，具有这种性质的语言称为自编译语言。一般说来，自编译语言不但可以用来书写其自身的编译程序，而且也能用来书写其他语言的编译程序

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220908144309.png" alt="image-20220908144309744" style="zoom:80%;" />

##### 自展

自展技术是利用自编译技术，将一个功能较小的编译程序，一级一级扩充而变成一个功能较强的编译程序。自展过程，实际上就是用低级语言先实现一个简单的编译器，然后用这个编译器的语言再去编写一个更高级的编译器的过程。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220908144400.png" alt="image-20220908144400345" style="zoom:80%;" />

##### 交叉编译

如果 A 机器上的编译程序能产生 B 机器语言的目标代码，那么这种程序被称为交叉编译程序。

1. 首先需要有一个可以在 A 机器上编译高级语言 L 的编译器①
2. 接下来使用 L 语言写一个能够产生 B 机器语言目标代码的编译程序②
3. 然后通过 L 语言的编译程序就可以生成在 A 机器上可以运行的产生 B 机器代码的编译程序③

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220908144506.png" alt="image-20220908144506055" style="zoom:80%;" />

##### 移植

移植技术是编译程序开发中一项十分重要的技术。移植就是把一台计算机上的软件移植到另一台计算机上去。移植方法有多种，下面简单地介绍两种典型的方法。

1. 综合几种型号的计算机硬件特性，抽象出一种通用的汇编语言。每种型号的计算机上配有一个简单的汇编程序，用来把通用的汇编语言书写的程序翻译成机器语言程序。采用这种方法抽象一种通用的汇编语言较为困难，因为这个通用的汇编语言既要便于书写编译程序，又要能够在各种不同型号的计算机上高效运行。

2. 利用交叉编译技术将一台计算机上由自编译语言编写的编译程序移植到另一台计算机上。假设在 A 机器上已有一个可运行的高级语言 L 的编译程序，只要我们编写一个用 L 书写的产生 B 机器语言的 L 的编译程序

   1. 首先需要有一个可以在 A 机器上编译高级语言 L 的编译器①
   2. 接下来使用 L 去写一个能够产生 B 机器语言目标代码的编译程序②
   3. 然后通过 L 语言的编译程序就可以生成在 A 机器上可以运行的产生 B 机器代码的编译程序③
   4. 最后使用编译程序③编译一遍②就可以得到能在 B 机器上运行的 B 机器代码的编译程序④

   <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220908144718.png" alt="image-20220908144718535" style="zoom:80%;" />

#### 编译技术的应用

1. 文本编辑器
2. 文本格式化工具
3. 文本检索工具
4. 文本处理与加密工具
5. 情感分析
6. 网页浏览器

## 形式语言的基本知识

> 乔姆斯基将语言形式地定义为由一个 **字母表** 的字母组成的一些串的集合。对于任意一个语言，有一个字母表，可以在字母表上按照一定的形成规则定义一个 **文法**，这个文法所产生的所有句子组成的集合就是这个文法所产生的语言。

### 字母表和符号串

#### 基本概念

+ 字母表（符号集）是符号的 **有穷非空集合**，通常记为$\Sigma, V$
+ 字母表中的元素称为 **符号**，符号是字母表中不能再分解的最小单位
+ 设$\Sigma$是一个字母表，$\forall x\in \Sigma^*$，则$x$称为$\Sigma$上的一个* *符号串**。符号串是字母表中符号的一个有穷序列
+ 符号串$s$的长度，记作$\lvert s \rvert$，指$s$中符号的个数
+ 符号串集合，如果集合$A$中的所有元素都是字母表$\Sigma$上的符号串，则称$A$为字母表$\Sigma$上定义的符号串集合。也可以称$A$为字母表$\Sigma$上定义的某种语言

#### 字母表基本运算

1. 字母表乘积（product）

   字母表 $\Sigma_1$ 和字母表 $\Sigma_2$ 相乘：
   $$
   \Sigma_1 \Sigma_2 = \left\{ab\mid a\in \Sigma_1, b\in \Sigma_2\right\}
   $$
   + 可以用笛卡尔积理解，例如$\{0,1\}\{a, b\}=\{0 a, 0 b, 1 a, 1 b\}$

2. 字母表幂运算（power）
   $$
   \left\{\begin{array}{l}
   \sum^0 =\{\varepsilon\} \\
   \sum^n =\sum^{n-1} \sum, {n} \geq 1
   \end{array}\right.
   $$

   + 字母表的$n$次幂，即长度为$n$的 **符号串** 构成的集合

3. 字母表正闭包（positive closure）
   $$
   \Sigma^{+}=\Sigma \cup \Sigma^2 \cup \Sigma^3 \cup \ldots
   $$

   + 实际上就是长度为正数的 **符号串** 构成的集合

4. 字母表克林闭包（Kleene closure）
   $$
   \Sigma^{*}=\Sigma ^0 +\Sigma^+=\Sigma ^0 \cup \Sigma \cup \Sigma^2 \cup \Sigma^3 \cup \ldots
   $$

   + 实际上就是任意长度的 **符号串** 构成的集合

#### 符号串基本运算

1. 符号串连接（concatenation)

   如果 $x$ 和 $y$ 是符号串，那么 $x$ 和 $y$ 的连接就是把 $y$ 附加到 $x$ 后面而形成的串，记作 $xy$

   + 值得注意的是：**空串**$\varepsilon$是连接运算的 **单位元**，所以$s\varepsilon = \varepsilon s = s$

2. 前缀、后缀和子串

   若 $x,y,z$ 都是 $\Sigma$ 上的符号串，那么 $x$ 被称为 $xy$ 的 **前缀**，$y$ 被称为 $xy$ 的 **后缀**，$y$ 被称为 $xyz$ 的 **子串**

   当 $x$ 是 $xy$ 的前缀，且 $x\neq xy$，则 $x$ 被称为 $xy$ 的真前缀

   当 $y$ 是 $xy$ 的后缀，且 $y\neq xy$，则 $y$ 被称为 $xy$ 的真后缀

   当 $y$ 是 $xyz$ 的子串，且 $y\neq xyz$，则 $y$ 被称为 $xyz$ 的真子串

   $\varepsilon$ 是任何串的（真）前缀，（真）后缀以及（真）子串

   符号串 $N$：

   前缀和后缀的数目：1+$\lvert N\rvert $，真前缀和后缀的数目：$\lvert N\rvert$，子串的数目：$1+\frac{\lvert N\rvert+{\lvert N\rvert}^2}{2}$，真子串的数目：$\frac{\lvert N\rvert+{\lvert N\rvert}^2}{2}$

3. 符号串幂运算
   $$
   \left\{\begin{array}{l}
   {s}^0 ={\varepsilon} \\
   {s}^n ={s}^{n-1} s, n \geq 1
   \end{array}\right.
   $$

   + 符号串$s$的$n$次幂，相当于将$n$个$s$连接起来

4. 符号串集合连接

   设 $L_1$ 定义在 $\Sigma_1$ 的符号串集合，$L_2$ 定义在 $\Sigma_2$ 的符号串集合：
   $$
   {L}_1 {L}_2 =\left\{{xy} \mid {x} \in {L}_1, {y} \in {L}_2\right\}
   $$

   + 同样的，也是类似于笛卡尔积的形式
   + $\Phi L = L \Phi  = \Phi$
   + $\left\{\varepsilon\right\}L  = L\left\{\varepsilon\right\} = L$

5. 符号串集合幂运算
   $$
   \left\{\begin{array}{l}
   {L}^0 =\left\{\varepsilon\right\} \\
   {L}^n ={L}^{n-1} L, n \geq 1
   \end{array}\right.
   $$

6. 符号串集合的正闭包
   $$
   L^{+}= L \cup L^2 \cup L^3 \cup \ldots
   $$

7. 符号串集合的闭包
   $$
   L^* = L^0 \cup L^{+}= L \cup L^2 \cup L^3 \cup \ldots
   $$

   + 两个闭包运算，都与字母表的闭包运算大抵相同
   + 由于$\Sigma$本身也可以视作符号串集合，因此将克林闭包$\Sigma^*$称为* *行集合**，表示字母表中的符号以任意顺序，任意个数，任意长度构成的符号串集合

### 语言和文法的形式化定义

> 句子是由本语言字母表上符号按照一定规则组成的符号串。
>
> + 枚举法，如果一个语言仅包含有限条句子，就可以采用枚举法来描述此语言把语言中每条句子都列举出来即可
> + 自动机识别法，在这种方法中，每种语言对应一种自动机（即某种算法）, 由它判定一个符号串是否在该语言中
> + 文法产生法，这种方法是为每种语言定义一组文法规则，从而产生该语言中的每条句子

#### 巴克斯-诺尔范式

巴科斯范式是描述语法规则一种表示方法，它是由巴科斯为了在 ALGOL60 报告中来描述 ALGOL 语言首先提出的。采用这种形式体系方式定义语法规则，可以用简洁的公式把各种语法规则严格而清晰描述出来。例如，在高级语言中大家所熟知的 **标识符** 这种语法成分，它用巴科斯范式可以描述为：

<标识符> `::=` <字母> | <标识符> <字母> | <标识符> <数字>

<字母> `::=` a|b|c|…|z

<数字> `::=` 0|1|2|…|9

不难发现，巴克斯范式使用的符号如下：

1. `::=`（或 $\to$），表示 **定义为**
2. `|`，表示多种不同的选择，不同选择称为 **候选式**
3. `< >`，表示语法实体，在比较明确的情况下，可省略

> 比如标识符的定义，就刻画出了其是以 **字母开始（递归定义，总会以字母开始）的** 一串字母和数字任意组合这种特点

产生式：产生式是 **只有一个候选式** 的文法规则，是一个 **非空符号串** 和另一个 **符号串** 的有序偶 $(\alpha,\beta)$，记为 $\alpha::=\beta$ 或 $\alpha\to \beta$。$\alpha$ 称为产生式的 **左部**，$\beta$ 称为产生式的 **右部**。表示 $\alpha$ 定义为 $\beta$。对于有相同左部的产生式，可以用 `|` 简单定义

字汇表：用于产生式左部和右部中所有符号形成集合为字汇表，记为 $V$

字汇表的分类：

1. 非终结符号

   出现在产生式左部，且能 **派生** 出符号或符号串的那些符号称为非终结符，也称语法实体或语法单位，它们的全体构成一个非终结符的集合，记为 $V_N$

2. 终结符号

   产生式中不属于 $V$ 的那些符号称为终结符，它们的全体组成终结符的集合，记为 $V_T$。终结符一般出现在规则的右部

+ 显然，$V = V_N \cup V_T \quad V_N \cap V_T = \Phi$

> 在上面标识符的定义中，
>
> $V_N$ = {<字母>, <数字>, <标识符>}
>
> $V_T$ = {a, b, c…z,0,1,2…9}

#### 文法

文法是规则的 **有穷集合**，形式定义为四元组 $G = (V_N, V_T,P,S)$，通常记为 $G[S]$

1. $V_N$ 是非终结符集合
2. $V_T$ 是终结符集合
3. $P$ 代表产生式集
4. $S\in V_N$ 是文法 $G$ 开始符号，也称识别符号，它至少要在一条产生式左部出现

栗子：
$$
G = (V_N, V_T, P, S)\\
V_N = \left\{A, B\right\}\\
V_T = \left\{c, d\right\}\\
P = \left\{A \to Bc, B \to d\right\}\\
S = A
$$

> 通常情况下，在对文法的描述时可以省略 $V_N$ 和 $V_T$，文法的开始符号也可以不需要“显式地”指定，仅需将开始符号写在 G 后的中括号中即可。
>
> 所以上述栗子可以简单描述为：$G[A]:A \to Bc, B \to d$

