# 数据库系统概论

$$
\mathscr{Anduin9527}
$$



## 绪论

### 数据库的三要素

1. 数据（描述事物的符号记录，数据库里面存储的内容） 
2. 存储器（外存，一般是硬盘，数据库的载体）
3. 数据库管理系统（DBMS，数据库的管理软件）

### 基本术语

数据（Data）

- 计算机用来描述事物的记录（文字．图形．图像．声音）
- 数据的形式本身并不能完全表达其内容，需要经过语义解释。数据与其语义是不可分的

数据库（Database，简称DB）

- 数据库是长期存储在计算机内、有结构的、可共享的大量的数据集合

>数据库数据具有永久存储、有组织和可共享三个基本特点

#### 数据库管理系统（DBMS）

数据库管理系统是位于用户与操作系统之间的一层数据管理软件，是**系统软件**。数据库在建立、运用和维护时由数据库管理系统统一管理、统一控制。

主要功能：

1. 数据定义功能（提供数据定义语言DDL）
2. 数据组织、存储和管理
3. 数据操纵功能（提供数据操作语言DML，增删改查）
4. 数据库的事务管理和运行管理
5. 数据库的建立和维护

主要特点：

1. 数据结构化
2. 数据的共享性高，冗余度低且易扩展
3. 数据独立性高（物理，逻辑）
4. 数据由数据库管理系统统一管理和控制

#### 数据库系统（DBS）

- **数据库管理人员DBA**

  数据库管理员负责维护而非开发，决定数据库中的信息内容和结构，定义数据完整性约束，监控数据库运行

- **数据库DB**

- **数据库管理系统DBMS**（及其开发工具）

- **操作系统（OS）**

  DBMS通过调用OS中的功能实现系统


- **用户**

- 应用系统（用户访问的是应用系统）

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20230515150812.png" alt="image-20230515150805456" style="zoom: 50%;" />

数据冗余度：

- 指同一数据重复存储时的重复程度。 

数据的安全性（Security）

- 数据的安全性是指保护数据，防止不合法使用数据造成数据的泄密和破坏，使每个用户只能按规定，对某些数据以某些方式进行访问和处理。  

数据的完整性（Integrity）

- 数据的完整性指数据的正确性、有效性和相容性。即将数据控制在有效的范围内，或要求数据之间满足一定的关系。 

并发（Concurrency）控制

- 对多用户的并发操作加以控制和协调，防止相互干扰而得到错误的结果 。

数据库恢复（Recovery）

- 将数据库从错误状态恢复到某一已知的正确状态

### 数据管理的三个阶段

1. 人工管理阶段（纸带）
   1. 数据不保存
   2. 应用程序管理数据
   3. 数据不共享
   4. 数据不具有独立性
2. 文件系统阶段
   1. 可以长期保存数据
   2. 由文件系统管理数据
   3. 数据共享性差，冗余度大
   4. 数据独立性差
3. 数据库系统阶段
   1. 数据结构化（与文件系统的本质区别）
   2. 数据的共享性高，见余度低，易扩充
   3. 数据独立性高
      1. 物理独立性（应用程序与数据的物理存储相互独立）
      2. 逻辑独立性（应用程序与数据库的逻辑结构相互独立）
   4. 数据由DBMS统一管理和控制

### 数据模型

根据模型应用的不同目的，可以分为两类：

1. 概念模型（信息模型）

   （用于信息世界的建模），它是**按用户的观点**来对数据和信息建模，主要用于数据库设计。这类模型强调其语义表达能力，要能够较方便、直接地表达应用中的各种语义知识，这类模型应为概念简单、清晰、易于用户理解，是用户和数据库设计人员之间进行交流的语言

   以下是信息世界的基本概念：

	实体（Entity）

   - 客观存在并可相互区别的事物称为实体

	属性（Attribute）

   - 实体所具有的某一特性称为属性

	码（关键字，Key）

	- 唯一标识实体的（最小的）属性或属性集称为码

	域（Domain）

	- 属性的取值范围称为该属性的域

	实体型（Entity Type）

	- 具有相同属性的实体必然具有共同的特征和性质。用实体名及其属性名集合来抽象和刻划同类实体，称为实体型

	实体集（Entity Set）

	- 同型实体的集合称为实体集

	联系（Relationship）

	- 在现实世界中，事物内部以及事物之间是有联系的，这些联系在信息世界中反映为实体（型）内部的联系和实体（型）之间的联系。〖组成实体的各属性之间以及不同实体集之间的联系〗



1. 逻辑模型（数据模型）和物理模型

   逻辑模型（如层次、网状、关系模型，用于机器世界），是**按计算机系统的观点**对数据建模，**主要用于DBMS的实现**。这类模型通常需要有严格的形式化定义，而且常常会加上一些限制或规定，以便于机器上的实现。还通常有一组严格定义了语法和语义的语言，是数据库设计人员与应用程序猿进行交流的工具

   物理模型是对数据最底层的抽象，不仅与DBMS有关还与**系统硬件**有关


**数据模型的三要素**

1. 数据结构

   数据结构是所研究的对象类型（Object Type）的集合

   **数据结构是对系统的静态特性的描述**

2.  数据操作

   数据操作是指对数据库中各种对象（型）的实例（值）允许执行的操作的集合。数据库主要有检索和更新（插入、删除、修改）两大类操作

   **数据操作是对系统动态特性的描述**

3. 数据的完整性约束条件

   数据的约束条件是完整性规则的集合。完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据状态以及状态的变化，以保证数据的正确、有效、相容

   >在关系模型中，任何关系必须满足实体完整性和参照完整性两个条件

### 联系的种类

**实体集之间的联系**，也可以是**同一实体集内各个实体之间的联系**：

 - 一对一联系 1:1
 - 一对多联系 1:n
 - 多对多联系 m:n


### 概念模型的表示方法

E-R图

- **长方形**来表示**实体型**，框内写上实体名

- **椭圆型**表示**实体的属性**，并用**无向边**把实体和属性连接起来

- **菱形**表示**实体间的联系**，菱形框内写上联系名，用**无向边**把菱形分别与有关实体相连接，在无向边旁标上联系的类型

  >若联系也具有属性，则把属性和菱形也用无向边连接上

### 常用数据模型

**层次模型(Hierarchical Model)**

- 最早使用的一种模型
- 数据结构是一棵**有向树**
- 优点：简单清晰，查询效率高，良好的完整性支持
- 缺点：表示的关系有局限性

**网状模型(Network Model)**

- 数据结构是一个有向图
- 能表示实体之间的多种复杂联系
- 优点：描述直观，查询效率高
- 缺点：结构复杂，编写复杂

**关系模型(Relational Model)**

- 关系模型是用**二维表**格结构来表示实体及实体之间的联系的模型，由E.F.Codd首次提出
- 在用户观点下，其逻辑结构（数据结构）是一张二维表。基本数据结构是关系
- 主要术语

	- 关系（relation）：一个关系对应于平常讲的一张表
	- 元组（tuple）：表中的一行称为一个元组
	- 属性（attribute）：表中的一列称为属性，每列的名称为属性名
	- 码（key）：表中的某个属性组，它们的值唯一的标识一个元组
	- 域（domain）：属性的取值范围，是一个集合
	- 分量：元组中的一个属性值
	- 关系模式：对关系的描述，用关系名（属性名1，属性名2，…，属性名n）来表示

- 特点

	- 概念单一
		- 实体或实体之间的联系都用关系表示
		- 用户的观点里，数据的逻辑结构就是表
		
	- 关系必须是规范化的关系
		- 指在关系模型中，每一个关系模式要满足一定的要求或者称为规范条件
		- 其最基本的要求是每一个分量是一个不可分的数据项，也就是说，不允许表中还有表
		
	- 用户对数据的检索操作不过是从原来的表中得到一张新的表
		- 在用户眼中，无论是原始数据还是结果数据，都是同一种数据结构——二维表
		- 数据操作是集合操作，即操作对象和操作结果都是关系（若干元组的集合），而不象非关系模型中那样单记录的操作方式
		- 把存取路径向用户隐藏起来，提高了数据的独立性（查询效率不如格式化模型）
		
	- 关系模型和层次、网状模型的最大差别是用关键码而非指针导航数据

### 数据库系统的体系结构

模式：模式（Schema）是数据库中全体数据的逻辑结构和特征的描述，同一个模式可以有很多实例。本质上是对某个数据库的一种规范（比如学生数据库应该有xxx而不应该有xxx）

**三级模式结构：**指数据库系统由外模式、模式和内模式三级构成

- 外模式（视图view）

  - 又称为**子模式/用户模式**，是数据库用户和数据库系统的接口，是数据库用户的数据视图，是数据库用户可以看见和使用的局部数据的逻辑结构和特征的描述

    >栗子：查询学生中姓名为张三的，最后返回信息就是一个外模式的过程

  - 一个数据库通常都有多个外模式。一个应用程序只能使用一个外模式，但同一外模式可为多个应用程序所用

  - 外模式通常是模式的子集，描述数据局部逻辑结构

- 模式（表table）

  - 又称为**逻辑模式**
  - 一个数据库只有一个模式
  - 是所有数据库用户的公共数据视图，描述数据全局逻辑结构
  - 模式定义语言DDL来严格定义模式

- 内模式

  - 又称为**存储模式**，是数据库物理结构和存储方式的描述，是数据在数据库内部的表示方式。是在外存中真实存在的 
  - 一个数据库只有一个内模式。内模式并不涉及物理记录，也不涉及硬件设备
  - 比如数据库底层的数据结构，索引方式（Hash/红黑树），是否压缩，是否加密

- 三层模式关系

  - 外模式通常是模式的子集。数据按外模式的描述提供给用户
  - 按内模式的描述存储在硬盘上，内模式依赖于全局逻辑结构，但可以独立于具体的存设备
  - 而模式介于外、内模式之间，既不涉及外部的访问，也不涉及内部的存储，从而起到隔离作用，有利于保持数据的独立性

**二层映象功能：**外模式/模式映象和模式/内模式映象（即三层模式之间的转换）

- 映象：是一种对应规则，说明映象双方如何进行转换。 

- 外模式/模式映象

  - 作用：把描述局部逻辑结构的外模式与描述全局逻辑结构的模式联系趣来
  - 当模式改变时，只要对外模式/模式映象做相应的改变，使外模式保持不变，则以外模式为依据的应用程序不受影响，从而保证了数据与程序之间的**逻辑独立性**，也就是数据的逻辑独立性 

- 模式/内模式映象

  - 作用：把描述全局逻辑结构的模式与描述物理结构的内模式联系起来

  - 当内模式改变时，比如存储设备或存储方式有所改变，只要模式/内模式映象做相应的改变，使模式保持不变，则应用程序就不受影响，从而保证了数据与程序之的**物理独立性**

    >栗子：在磁盘上移动db文件，不需要重新设计数据库结构

<div STYLE="page-break-after: always;"></div>

## 关系模型

### 关系

#### 基本概念

1. 域（Domain）：域是一组具有相同数据类型的值的集合。比如 整数

2. 笛卡尔积（Cartesian Product）：所有域的所有取值的一个组合
   $$
   D_1 \times D_2 \times \ldots \times D_n=\left\{\left(d_1, d_2, \ldots, d_n\right) \mid d_i \in D_i, \quad i=1,2, \ldots, n\right\}
   $$
   

   1. `元组`（Tuple）
       笛卡尔积中每一个元素叫作`一个n元组`（n-tuple）或简称`元组`(Tuple)

   2. `分量`（Component）
       笛卡尔积元素中的每一个值叫作一个`分量`

   3. `基数`（Cardinal number）

      可以把基数看做笛卡尔积元素的个数，即元组的个数

   4. 笛卡尔积的表示方法:
      笛卡尔积可表示为一个二维表
      表中的每行对应一个元组，表中的每列对应一个域

3. `关系`：笛卡尔积的子集，称为在域上的关系，形式化表示如下：
   $$
   R(D_1,D_2,...D_n)
   $$

   + $R$为关系名

   + $n$为关系的`目`或者度，$n=1$为单元关系，$n=2$为二元关系

   + `元组`：关系中的一行，通常用$t$表示

   + `属性`：关系中不同列可以对应相同的域，为了加以区分，必须对每列起一个名字，称为属性。 显然的，$n$目关系必有$n$个属性

   + 关系的表示：表的每行是一个元组，每一列对应一个属性（取值范围为域）

     > 不是所有的子集都有实际意义

4. 码

   + 候选码（Candidate key）：关系中的**某一**属性组的值**能唯一地标识一个元组**
   + 全码（All-key）：关系模式的**所有属性组都是这个关系模式的候选码**，称为全码
   + 主码（Primary key）：若一个关系有多个候选码，则选定其中一个为主码
   + 主属性（Prime attribute）：候选码的诸属性称为主属性
     相对的，不包含在任何侯选码中的属性称为非主属性（ Non-Prime attribute）或非码属性（Non-key attribute） 

#### 三类关系

1. `基本关系`（基本表或基表）
    实际存在的表，是实际存储数据的逻辑表示
2. `查询表`
    查询结果对应的表
3. `视图表`
    由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据

#### 基本关系的六大性质

1. 列是同质的
   - 每一列中的分量是同一类型的数据，来自同一个域
2. 不同的列可出自同一个域，其中的每一列称为一个属性，不同的属性要给予不同的属性名
3. 列的顺序无所谓，列的次序可以任意交换
4. 任意两个元组的候选码不能完全相同
   - 候选码是可以惟一标识一个元组的属性或属性组
   - 若一个关系中的候选码有多个，则选择一个作为主码
5. 行的顺序无所谓，行的次序可以任意交换
6. 分量必须取原子值
   - 每一个分量都必须是不可分的数据项，即无表中表

### 关系模式

#### 基本概念

关系模式（Relation Schema）是型，而关系是值。（模式–实例）

1. 元组集合的结构：
   1. 属性构成
   2. 属性来自的域
   3. 属性与域之间的映象关系
2. 关系通常由元组语义确定
3. 现实世界还存在完整性约束

`关系模式`可以形式化地表示为：$R(U,D,DOM,F)$

+ `R` 关系名
+ `U `组成该关系的属性名集合
+ `D `属性组U中属性所来自的域
+ `DOM `属性向域的映象集合
+ `F` 属性间的数据依赖关系集合

#### 关系模式与关系

- **关系模式**
   对关系的描述
   静态的、稳定的
- **关系**
   关系模式在某一时刻的状态或内容
   动态的、随时间不断变化的
   关系模式和关系往往统称为关系

+ 可以把关系模式理解为表的结构、属性之间的关系、约束条件，把关系理解为具体的二维表

### 关系数据库

`关系数据库`：在一个给定的应用领域中，所有关系的集合构成一个关系数据库

关系数据库的型：关系数据库模式，对关系数据库的描述

关系数据库的值：关系模式在某一时刻对应的关系的集合，简称为关系数据库

关系数据库模式：若干域的定义，在这些域上定义的若干关系模式


### 关系操作

#### 概述

- `关系代数`是一种抽象的查询语言，用对关系的运算来表达查询，作为研究关系数据语言的数学工具
- 关系代数的运算对象是关系，运算结果亦为关系
- 常用操作：
  - 查询：选择、投影、连接、除、并、交、差
  - 数据更新：插入、删除、修改
  - 其中选择、投影、并、差、笛卡尔积是5种基本操作


#### 关系代数语言

+ `关系代数语言`：用对关系的运算来表达查询要求
  + 代表：ISBL
+ `关系演算语言`：用谓词来表达查询要求
  + 元组关系演算语言：谓词变元的基本对象是元组变量
    + 代表：APLHA，QUEL
  + 域关系演算语言：谓词变元的基本对象是域变量
    + 代表：QBE
+ `具有关系代数和关系演算双重特点的语言`
  + 代表：SQL（Structured Query Language） 

### 关系的三类完整性约束

- `实体完整性`

  - 主属性（主码的属性）不能为空值（不知道，不存在，无意义）
  - 保证关系中的每个元组都**可识别**和**唯一性**（一般以主码作为唯一性标识）
  - SQL实现：Primary Key

- `参照完整性`

  
  - 在关系数据库中，表与表之间的联系是通过参照完整性实现的

  - 外码并不一定要与相应的主码同名，但往往相同

  - 所以外码取值只能为空值或者对应的引用，其实质是不允许引用不存在的实体
  
  - SQL实现：外码（Foreign Key）

    1. 非本关系（参照关系）的主码
    2. 而是另一个关系（被参照关系/目标关系）的主码

    >栗子：学生关系的“专业号”与专业关系的主码“专业号”相对应
    >“专业号”属性是学生关系的外码
    >
    >专业关系是被参照关系，学生关系为参照关系


- `用户定义的完整性`

	- 针对某一具体数据库的约束，使其数据满足语义要求
	- SQL实现：Check（）

### 关系代数

####  集合运算

从关系的水平方向进行（行）

- 并Union  $(\cup)$

  - R和S的并，$R\cup S$，是在R或S或两者中的元素的集合
  - R和S**必须同类型**（属性集相同、次序相同，但属性名可以不同）
  - 一个元素在并集中只出现一次（并后要查重）
- 交Intersect $(\cap )$

  - R和S的交，$R\cap S$，是在R和S中都存在的元素的集合
  - R和S**必须同类型**（属性集相同、次序相同，但属性名可以不同）
  - 一个元素在交集中只出现一次（交后要查重）
- 差Minus $(-)$

  - R和S的差，$R-S$，是在R中而不在S中的元素的集合
  - R和S**必须同类型**（属性集相同、次序相同，但属性名可以不同）
- 广义笛卡儿积 $(\times )$

  - 关系R、S的广义笛卡儿积是两个关系的元组对的集合所组成的新关系
  - $R\times S$：
    - 假设$R(m,k_1)$，$S(n,k_2)$
    - 属性是R和S的组合（可以有重复属性，最终变为$m+n$列）
    - 元组是R和S所有元组的可能组合（最终变为$k_1\times k_2$行）
    - 是R、S的`无条件连接`，使任意两个关系的信息能组合在一起
  - SQL：`SELECT * FROM R,S;`

专门的关系运算：

- 投影Projection $(\pi )$

  - $\pi_{A_1,A_2}(R)$选择若干列进行显示
  - 投影运算的结果中，也要去除可能的重复元组
  - SQL：`SELECT A1,A2 FROM R;`

- 选择Selection $(\sigma)$

  - 从关系R中选择符合条件的元组构成新的关系
  - $\sigma_F(R)$，表示从R中选择满足条件（使逻辑表达式F为真）的元组
  - 行的运算
  - SQL：`SELECT * FROM R WHERE F;`

- 条件连接 $(\theta)$

  - 从$R\times S$的结果集中，选取在指定的属性组A和B，满足$A\theta B$条件的元组，组成新的关系

    记作：$\begin{gathered}R \bowtie S \\ a \theta b\end{gathered}$

  - $\theta$是一个关于属性集的比较运算符

  - $\theta$为`=`的连接运算称为`等值连接`，即选取AB属性值相等的元组

  - SQL：`SELECT R.*,S.* FROM R,S WHERE \theta;`

- 自然连接

  - 是一种特殊的等值连接（没有$\theta $表示的条件），记作：$R \bowtie S$
  - 从$R\times S$的结果集中，选取在**某些公共属性**上具有相同值的元组，组成新的关系
  - R、S的公共属性：属性集的交集（名称及类型相同）
  - 结果需要查重（**公共属性只写其中之一，而条件链接时同名属性仍需分开写**）

  + 悬浮元组：两个关系R和S在自然连接时，关系R和S中被舍弃的元组

  + 外连接：如果把悬浮元组也保存在结果关系中，在其他属性上填空值NULL
    + 左外连接：如果只保留左边关系R中的悬浮元组叫做左外连接
    + 右外连接：如果只保留右边关系S中的悬浮元组叫做右外连接

- 除Division $(\div )$
  - 给定关系$R(X,Y)$和$S(Y,Z)$，其中X，Y，Z为属性组。R中的Y与S中的Y可以有不同的属性名，但必须出自相同的域集
  - R与S的除运算得到一个新的关系P(X)，P是R中满足下列条件的元组在X属性列上的投影：
    - 首先在R中计算X中的分量$X_i$关于Y的象集
    - 对比S的Y，看看哪一个象集能包含全部的S.Y
    - 将符合条件的X分量作为结果
    - 除数作为条件，比较完就丢弃了，所以列会比被除数来的少
  - 白话：除法是写为$R \div S$的二元关系。其结果由$R$中元组到唯一于$R$的属性名字（就是说只在$R$表头中而不在$S$表头中的属性）的限制构成，并且它们与$S$中的元组的所有组合都存在于$R$中
  - 除操作同时从列和行角度进行运算
  
  <img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20230526133500.png" alt="image-20230526133500279" style="zoom:50%;" />

>题型1：求某几个属性特定值，格式：
>$$
>\pi_{\text{属性1},\text{属性2}}\ (\sigma_{\text{条件}}(\text{表名}\bowtie \text{表名}))
>$$
>
>+ 投影运算的下标为题目要求的最终需要的列
>+ 选择运算的下标为题目给出的判断条件，多个条件以$\and$或$\or$连接
>+ 若有多个表，表之间常用自然连接
>
>题型2：求满足某属性**全部**值的其他属性（除运算）：
>
>例如：A表为学生选课表，B表为课程信息表，求选了全部课程的学生号
>$$
>\pi_{\text {学号, 课程 }}(A) \div \pi_{\text {课程 }}(B)
>$$
>
>+ **全部课程**只在B表出现，学号只在A表出现
>+ 于是先全选A表的学号字段和课程字段，再全选B表的课
>+ 反之若是$\pi_{\text {学号, 课程 }}(A) \div \pi_{\text {学号 }}(B)$，则表示求全部学生都选了的课程号
>
>题型3：求没有任何满足某条件的属性（差运算）：
>$$
>\pi_{\text {属性}}(表名) - \pi_{属性}(\sigma_{反条件}(表名))
>$$
>
>+ 正难则反，可以先求条件的差集（反条件），再用全集减去满足条件部分
>
>栗子1：在关系S(S#,SNAME)、SC(S#,C#,G)和C(C#,CNAME)中，检索选修了DS和DB课程的学生姓名
>$$
>\pi_{sname} ((\pi _{s\#,c\#}(SC)\div \pi_{c\#}(\sigma_{cname='DS'\or cname = 'DB'}(C) ))\bowtie S)
>$$
>
>1. 从课程表$C$中获取DS和DB的课程号C#，$\pi_{c\#}(\sigma_{cname='DS'\or cname = 'DB'}(C) $
>2. 利用除运算，获取选修了这两门课的学生学号$\pi _{s\#,c\#}(SC)\div \text{1式}$
>3. 最后与学生表连接后查询学生姓名$\pi_{sname}(\text {2式}\bowtie S)$

<div STYLE="page-break-after: always;"></div>

## 数据库语言SQL

>别忘记分号;别忘记分号;别忘记分号;别忘记分号;别忘记分号;别忘记分号;别忘记分号;别忘记分号;

### SQL概述

- SQL（Structured Query Language）结构化查询语言，是关系数据库的标准语言
- SQL是一个通用的、功能极强的关系数据库语言

#### SQL特点

1. 综合统一
   1. 集数据定义语言 DDL，数据操纵语言 DML，数据控制语言 DCL功能于一体
   2. 可以独立完成数据库生命周期中的全部活动
   3. 用户数据库投入运行后，可根据需要随时逐步修改模式，不影响数据的运行
   4. 数据操作符统一
2. 高度非过程化
   1. 非关系数据模型的数据操纵语言“面向过程”，必须制定存取路径
   2. SQL只要提出“做什么”，无须了解存取路径
   3. 存取路径的选择以及SQL的操作过程由系统自动完成
3. 面向集合的操作方式
   1. 非关系数据模型采用面向记录的操作方式，操作对象是一条记录
   2. SQL采用集合操作方式：   
      1. 操作对象、查找结果可以是元组的集合
      2. 一次插入、删除、更新操作的对象可以是元组的集合
4. 形式
   1. 独立式SQL
   2. 嵌入式SQL

#### SQL基本概念

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20230520143730.png" alt="image-20230520143723352" style="zoom: 50%;" />

**基本表**

- 本身独立存在的表
- SQL中一个关系就对应一个基本表
- 一个（或多个）基本表对应一个存储文件
- 一个表可以带若干索引

**存储文件**

- 逻辑结构组成了关系数据库的内模式
- 物理结构是任意的，对用户透明

**视图**

- 从一个或几个基本表导出的表
- 数据库中只存放视图的定义而不存放视图对应的数据
- 视图是一个**虚表**
- 用户可以在视图上再定义视图

#### SQL语言主要组成部分 

数据定义语言（DDL，Data Definition Language）

- 数据定义语言是指用来定义和管理数据库以及数据库中的各种对象的语句，这些语句包括CREATE、ALTER和DROP等语句。在SQL Server中，数据库对象包括表、视图、触发器、存储过程、规则、缺省、用户自定义的数据类型等。这些对象的创建、修改和删除等都可以通过使用CREATE、ALTER、DROP等语句来完成。
- 常见的数据类型

	- 字符型：

		-      定长字符型 char(n) 由于是定长，所以速度快
		-      变长字符型 varchar(n)   

	- 数值型：

		-      整型 int(或integer)   -231~+231
		- 短整型 smallint -215~+215的
		-      浮点型 real、float、double
		-      数值型 numeric (p [,d])

	- 日期／时间型：

		-      DateTime

	- 文本和图像型

		-  Text：存放大量文本数据。在SQLServer中，Text对象实际为一指针
		- Image：存放图形数据

数据操纵语言（DML，Data Manipulation Language）

- 数据操纵语言是指用来查询、添加、修改和删除数据库中数据的语句，这些语句包括SELECT、INSERT、UPDATE、DELETE等。在默认情况下，只有sysadmin、dbcreator、db_owner或db_datawriter等角色的成员才有权利执行数据操纵语言。

数据控制语言（DCL，Data Control Language）

- 数据控制语言（DCL）是用来设置或者更改数据库用户或角色权限的语句，这些语句包括GRANT、REVOKE 、DENY等语句，在默认状态下，只有sysadmin、dbcreator、db_owner或db_securityadmin等角色的成员才有权利执行数据控制语言。

### 数据定义

SQL的数据定义功能: `模式定义`、`表定义`、`视图`和`索引`的定义

| 操作对象 |     创建      |    删除     |    修改     |
| :------: | :-----------: | :---------: | :---------: |
|   模式   | CREATE SCHEMA | DROP SCHEMA |             |
|    表    | CREATE TABLE  | DROP TABLE  | ALTER TABLE |
|   视图   |  CREATE VIEW  |  DROP VIEW  |             |
|   索引   | CREATE INDEX  | DROP INDEX  | ALTER INDEX |

#### 模式定义

##### 创建模式

```sql
CREATE SCHEMA <模式名> AUTHORIZATION <用户名>
```

+ 若没有指定模式名，那么<模式名>默认为<用户名>

+ 在`CREATE SCHEMA`中可以接受`CREATE TABLE`,`CREATE VIEW`和`GRANT`子句。格式如下：

  ```sql
  CREATE SCHEMA <模式名> AUTHORIZATION <用户名>[<表定义>|<视图定义>|<授权定义>]
  ```

+ 执行创建模式语句必须拥有**DBA**权限，或者DBA授予在`CREATE SCHEMA`的权限

##### 删除模式

```sql
DROP SCHEMA <模式名> <CASCADE|RESTRICT>
```

+ 两个选项必选其一

  + `CASCADE(级联)` 

    删除模式的同时把该模式中所有的数据库对象全部删除

  + `RESTRICT(限制)`
    如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行

    即当该模式中没有任何下属的对象时才能执行

#### 表定义

##### 创建表

```sql
CREATE TABLE <表名>(
      <列名> <数据类型> [<列级完整性约束条件>]
      [,<列名> <数据类型> [<列级完整性约束条件>]]
       ………
      [,<表级完整性约束条件>]
 );
```

+ 如果完整性约束条件涉及到该表的多个属性列，则必须定义在表级上，否则既可以定义在列级也可以定义在表级

**数据类型：**

| 数据类型     | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| CHAR(n)      | 字符/字符串。固定长度 n                                      |
| VARCHAR(n)   | 字符/字符串。可变长度。最大长度 n                            |
| BOOLEAN      | 存储 TRUE 或 FALSE                                           |
| SMALLINT     | 整数值（没有小数点）。精度 5                                 |
| INT          | 整数值（没有小数点）。精度 10                                |
| NUMERIC(p,s) | 精确数值，精度 p，小数点后位数 s                             |
| FLOAT(p)     | 近似数值，尾数精度 p。一个采用以 10 为基数的指数计数法的浮点数 |
| REAL         | 近似数值，尾数精度 7                                         |
| DATE         | 存储年、月、日的值，格式：**YYYY-MM-DD**                     |
| TIME         | 存储小时、分、秒的值，格式：**HH:MM:SS**                     |
| TIMESTAMP    | 存储年、月、日、小时、分、秒的值，格式：**YYYY-MM-DD HH:MM:SS** |

**列级完整性约束条件：**

1. `NOT NULL`：列值不可以为空（非空约束）
2. `UNIQUE`：列值唯一，不得重复（唯一性约束）
3. `DEFAULT`：列值空缺时，由系统填写默认值（默认值约束）
4. `PRIMARY KEY`：主码为单属性时，可直接在属性后的列级完整性约束条件中，定义主码

**表级完整性约束条件：**

1. 主码（PRIMARY KEY ）子句：

   ```mysql
   PRIMARY KEY(<列名表>);
   ```

2. 外码（FOREIGN KEY ）子句：

   ```mysql
   FOREIGN KEY [外码名] (<列名表 1>)
   REFERENCES <主表名> [(列名表 2)];
   ```

3. 检查（CHECK）子句

   ```mysql
   CHECK (约束表达式)
   ```

##### 修改表

```sql
ALTER TABLE <表名>
[ ADD <新列名> <数据类型> [完整性约束]]
[ ADD <完整性约束>]
[ DROP <列名> [CASCADE|RESTRICT]]
[ DROP CONSTAINT <完整性约束名> ]
[ ALTER COLUMN <列名> <新数据类型> ];
```

+ `ADD`子句用于增加列，或是增加列/表级约束
+ `DROP`子句用于删除列
  + `CASCADE`，自动删除引用该列的其他对象
  + `RESTRICT`，若该列被其他对象引用，则拒绝删除
+ `DROP CONSTAINT`子句用于删除表级约束
+ `ALTER COLUMN`子句用于修改原本列数据类型

>- 向 Student 表增加“入学时间”列，其数据类型为日期型
>  `ALTER TABLE Student ADD S_entrance DATE;`
>- 将年龄的数据类型由字符型（假设原来的数据类型是字符型）改为整数
>  `ALTER TABLE Student ALTER COLUMN Sage INT;`
>- 增加课程名称必须取唯一值的约束条件
>  `ALTER TABLE Course ADD UNIQUE(Cname);`

##### 删除表

```sql
DROP TABLE <表名> ［RESTRICT | CASCADE];
```

- `CASCADE`：删除该表没有限制
  - 在删除基本表的同时，相关的依赖对象一起删除
- `RESTRICT`：删除表是有限制的
  - 欲删除的基本表不能被其他表的约束所引用
  - 如果存在依赖该表的对象，则此表不能被删除
- 在删除表的同时将相关的依赖对象，例如视图，约束，外码，触发器，函数或存储过程，都将被一起删除

#### 索引定义

**建立索引的目的：加快查询速度**

- 谁可以建立索引？
  - DBA 或表的属主（即建立表的人）
- DBMS一般会自动建立以下列上的索引
  - PRIMARY KEY
  - UNIQUE
- DBMS自动选择是否使用索引以及使用哪些索引，并自动维护索引
- RDBMS（关系数据库管理系统）中索引一般采用`B+树索引`或`HASH索引`来实现
  - B+树索引具有动态平衡的优点
  - HASH索引具有查找速度快的特点
- 索引是关系数据库的内部实现技术，**属于内模式的范畴**
- `CREATE INDEX`语句定义索引时，可以定义索引是`唯一索引、非唯一索引或聚簇索引`

##### 创建索引

```sql
CREATE [UNIQUE] [CLUSTER] INDEX <索引名> 
ON <表名> (<列名>[<次序>][,<列名>[<次序>] ]…);
```

- `UNIQUE` 关键字是可选的。如果指定了 `UNIQUE`，则表示创建的索引对应的属性取值是唯一的（比如只取id作为索引，那么不能有重复的id）
- `CLUSTER` 关键字是可选的。如果指定了 `CLUSTER`，则表示创建的索引是聚簇索引，其索引顺序与**物理存储顺序**一致，在最经常查询的列上建聚簇索引可以**改善数据检索效率**，**但在表上只能创建一个聚簇索引**
- `<次序>` 是可选的，用于指定列的排序顺序。可以指定 `ASC`（升序）或 `DESC`（降序），如果不指定，则默认为升序

>- Student表按学号升序建唯一索引
>
>  `CREATE UNIQUE INDEX  Stusno ON Student(Sno)`
>
>- Course表按课程号升序建唯一索引
>
>  `CREATE UNIQUE INDEX  Coucno ON Course(Cno)`
>
>- SC表按学号升序和课程号降序建唯一索引
>
>  `CREATE UNIQUE INDEX  SCno ON SC(Sno ASC,Cno DESC)`

##### 删除索引

```sql
DROP INDEX <索引名> ON <表名>;
DROP INDEX <表名>.<索引名>;
```

### 数据查询

```sql
SELECT [ALL | DISTINCT] <目标列表达式> [,<目标列表达式>] ...
FROM <表名或视图名> [,<表名或视图名>...] | (<SELECT 语句>) [AS] <别名>
[WHERE <条件表达式>]
[GROUP BY <列名1> [HAVING <条件表达式>]]
[ORDER BY <列名2> [ASC | DESC]];
```

- `ALL`（默认值） 和 `DISTINCT` 是可选的修饰符，用于指定返回所有行或只返回不同的行
- `FROM` 用于指定要查询的表或视图的名称。可以在一个查询中指定多个表或视图
- `WHERE` 是可选的，用于指定查询条件，仅返回满足条件的行
- `GROUP BY` 用于指定要分组的列，可以使用聚合函数对每个组进行计算
- `HAVING` 是可选的，用于指定分组后的筛选条件
- `ORDER BY` 用于指定返回的结果行的顺序，可以按一个或多个列进行排序

#### 单表查询

1. 查询指定列
   格式：`SELECT <列名1> [,<列名2>] ... FROM <表名>;`
2. 查询所有列
   格式：`SELECT * FROM <表名>;`
3. 查询经过计算后的结果
	 格式：`SELECT <表达式> FROM <表名>;`
	 + `表达式`可以是算术表达式、字符串常量、函数、列别名等
  > 算术表达式：`SELECT Sno,Sname,Sage+1 FROM Student;`
  >
  > 字符串常量：`SELECT Sno,Sname,'男' FROM Student;`
  >
  > 函数：`SELECT Sno,Sname,UPPER(Sname) FROM Student;`
  >
  > 列别名：`SELECT Sno,Sname,Sage+1 AS Sage1 FROM Student;`
##### 选择表中的若干元组
1. 消除取值重复的元组
   
    ```sql
    SELECT DISTINCT <列名1> [,<列名2>] ... FROM <表名>;
    ```
    
     + `DISTINCT` 关键字用于消除取值重复的元组
     + 若不指定 `DISTINCT`，则默认为 `ALL`，即返回所有行
    
2. 查询满足条件的元组
   查询满足条件的元组，即 `WHERE` 子句
   
   ```sql
	SELECT <列名1> [,<列名2>] ... FROM <表名> WHERE <条件表达式>;
   ```

   + `WHERE` 子句用于指定查询条件，仅返回满足条件的行
   
   + 常用查询条件如下表
   
     | 查 询  条 件         | 谓  词                                              |
     | -------------------- | --------------------------------------------------- |
     | 比  较               | =, >, <, >=, <=, !=, <>, !>, !<; NOT+上述比较运算符 |
     | 确定范围             | BETWEEN  AND,  NOT  BETWEEN AND                     |
     | 确定集合             | IN, NOT  IN                                         |
     | 字符匹配             | LIKE, NOT  LIKE                                     |
     | 空  值               | IS  NULL,  IS  NOT NULL                             |
     | 多重条件（逻辑运算） | AND, OR, NOT                                        |
	  
   + 模糊查询常用的通配符
	
	  + `%`：表示任意长度的字符串 	 
	
   	 + `_`：表示任意单个字符，**注意：在ASCII码表中，一个汉字长度为2，GBK中为1**
	
		 + `[]`：表示括号内所列字符中的一个
	
		 + `[^]`：表示不在括号内所列字符中的一个
	
		 + 默认换码符 `\` 可以将通配符作为普通字符进行匹配，如果要自定义换码符，可以使用 `ESCAPE` 关键字
 + 注意：`NULL` 与任何值的比较都是未知，即 `NULL` 与任何值都不相等，包括 `NULL` 本身。所以，`WHERE` 子句中不能使用 `=` 或 `<>` 来判断 `NULL` 值，而应该使用 `IS NULL` 或 `IS NOT NULL` 来判断 `NULL` 值
 + 注意：逻辑运算符 `AND`、`OR`、`NOT` 的优先级为 `NOT` > `AND` > `OR`，可以使用圆括号来改变运算符的优先级

  > 比较大小：`SELECT * FROM Student WHERE Sage>20;`
	>
	> 范围：`SELECT * FROM Student WHERE Sage BETWEEN 20 AND 22;`
	>
  > 集合：`SELECT * FROM Student WHERE Sdept IN ('CS','IS');`
	>
	> 字符匹配：`SELECT * FROM Student WHERE Sname LIKE '李%';`
	>
	> 转义匹配：`SELECT * FROM Student WHERE Sno LIKE '%\%%';`
	>
	> 空值：`SELECT * FROM Student WHERE Sdept IS NOT NULL;`
	>
	> 逻辑：`SELECT * FROM Student WHERE Sage>20 AND Sdept='CS';`

3. 改变查询结果的列标题

   ```sql
   SELECT <目标列表达式> AS <别名1> [,<列名2>] ... FROM <表名> WHERE <条件表达式>;
   ```

##### ORDER BY 子句

`ORDER BY` 子句用于指定返回的结果行的顺序，可以按一个或多个列进行排序

```sql
SELECT <列名1> [,<列名2>] ... FROM <表名> ORDER BY <列名2>|<列次序> [ASC | DESC];
```

+ `ASC` 表示升序（默认）
+ `DESC` 表示降序
+ 除了以列名来指定升序降序外，还可以使用列次序指定，比如`ORDER BY 2`，就是以SELECT的第二个属性排序。**这可以用于属性由聚集函数给出的情况**
+ 当含有空值`NULL`时，视为最大值

>+ 查询选修了3号课程的学生的学号及其成绩，并按成绩降序排列
>
>`SELECT Sno,Grade FROM SC WHERE Cno='3' ORDER BY Grade DESC;`
>
>+ 查询全体学生，按所在系的系名升序排列，同一系的学生按年龄降序排列
>
>`SELECT * FROM Student ORDER BY Sdept ASC,Sage DESC;`

##### 聚集函数
聚集函数用于计算一组值的统计值，常用的聚集函数有 `COUNT`、`SUM`、`AVG`、`MAX`、`MIN` 等

```sql
SELECT <聚集函数>([DISTINCT|ALL]<列名>) FROM <表名>;
```

+ `COUNT(*)`：计算元组个数，包括 `NULL` 值
+ `COUNT`：计算一列中的元组个数
+ `SUM`：计算一列中的元组值的和
+ `AVG`：计算一列中的元组值的平均值
+ `MAX`：计算一列中的元组值的最大值
+ `MIN`：计算一列中的元组值的最小值
+ **注意：聚集函数只能用于 `SELECT` 子句和 `HAVING` 子句中，不能用于 `WHERE` 子句中**
+ 如果指定了`DISTINCT`则表示计算时要取消重复值。若不指定，则默认为ALL，表示不取消重复值
+ 聚集函数对于`NULL`的处理：基本都是忽略 `NULL` 值，只有 `COUNT(*)` 会统计 `NULL` 值

>+ 查询学生总人数
>
>`SELECT COUNT(*) FROM Student;`
>
>+ 查询选修了课程的学生的人数
>
>`SELECT COUNT(DISTINCT Sno) FROM SC;`
>
>+ 计算1号课程的平均成绩，并以`AVG1`作为列名展示
>
>`SELECT AVG(Grade) AVG1 FROM SC WHERE Cno='1';`

##### 分组查询
`GROUP BY` 子句用于将查询结果分组，常与聚集函数一起使用，使得聚集函数可以对每个组进行计算

```sql
SELECT <列名1> [,<列名2>] ... FROM <表名> GROUP BY <列名1> [,<列名2>] ... HAVING <条件>;
```

+ **注意：使用了 `GROUP BY` 子句后，`SELECT` 子句中只能出现分组属性和聚集函数，不能出现其他属性**
+ 可以使用 `HAVING` 子句对分组后的结果进行筛选，而不能使用 `WHERE` 子句

> + 查询选修人数>30的课程的课程号和选修人数
>
> `SELECT Cno,COUNT(Sno) FROM SC GROUP BY Cno HAVING COUNT(Sno)>30;`
>
> + 统计选修人数超过15人的课程的课程号、课程名和学生选修人数，并按照学生选修人数降序排列，如果人数相同，则按照课程号升序排列
>
>   ```sql
>   SELECT C.CNO, C.CNAME, COUNT(*) AS COUNT
>   FROM SC, C
>   WHERE C.CNO = SC.CNO
>   GROUP BY C.CNO, C.CNAME
>   HAVING COUNT > 2
>   ORDER BY COUNT DESC, C.CNO;
>   ```
>
>   + 注意第一个`COUNT(*) AS COUNT`，起个别名
>   + 在分组之后统计个数`COUNT`

+ `HAVING`与`WHERE`的区别
  + `WHERE`子句在分组前进行限制，`HAVING`子句在分组后进行限制
  + `WHERE`子句中不能使用聚集函数，`HAVING`子句中可以使用聚集函数

#### 连接查询
连接查询是指在两个或多个表中查询满足某种连接条件的元组，连接查询的 WHERE 子句中用来连接两个表的条件称为连接条件或者连接谓词（相同属性列，自然连接）

##### 等值与非等值连接查询

格式1，比较运算符：
```sql
SELECT <表名1>.<列名1>, <表名2>.<列名2> 
FROM <表名1>,<表名2> 
WHERE <表名1>.<列名1><比较运算符> <表名2>.<列名2>;
```
格式2，BETWEEN...AND...：
```sql
SELECT <表名1>.<列名1>, <表名2>.<列名2> 
FROM <表名1>,<表名2> 
WHERE <表名1>.<列名1> BETWEEN <表名2>.<列名2> AND <表名2>.<列名3>;
```

+ 等值连接：`<比较运算符>`为`=`
+ `<列名1>`与`<列名2>`的数据类型必须相同（可比较的）
+ `<列名1>`与`<列名2>`的名称可以不同，最后的结果也不会对属性进行去重（与连接操作相同）
+ 连接操作的执行方法：循环嵌套法
+ 若在等值连接中把目标列中重复的属性去掉，则得到的连接结果称为自然连接。即自然连接是等值连接的一种特殊情况。将`SELECT`子句中的每个属性值都以`<表名>.<属性名>`的形式给出，且无重复属性值即可


##### 自身链接
一个表与自身进行连接，称为自身连接
+ 需要给表起别名以区分
+ 由于所有的属性名都是相同的，所以在`SELECT`子句中必须使用`<表名>.<属性名>`的形式给出
  
> + 查询每一门课的间接先修课程
>
> `SELECT FIRST.Cno,SECOND.Cpno FROM Course AS FIRST,Course AS SECOND WHERE FIRST.Cpno=SECOND.Cno;`

##### 外连接
普通连接只能查询出两个表中满足连接条件的元组，而不能查询出两个表中不满足连接条件的元组，这种连接称为内连接。若要查询出两个表中不满足连接条件的元组，就需要使用外连接。

外连接分为左外连接和右外连接，左外连接查询出左表中不满足连接条件的元组，右外连接查询出右表中不满足连接条件的元组。
```sql
SELECT <表名1>.<列名1>, <表名2>.<列名2> 
FROM <表名1> [LEFT|RIGHT] OUT JOIN <表名2> 
ON <表名1>.<列名1> <比较运算符> <表名2>.<列名2>;
```
+ `LEFT`表示左外连接，`RIGHT`表示右外连接
+ `JOIN`后的表其中的值就是可以为`NULL`的

> + 查询每个学生的学号，姓名和选修的课程名（包括未选修的学生）
>
> `SELECT Student.Sno,Student.Sname,Course.Cname FROM Student LEFT OUT JOIN SC ON Student.Sno=SC.Sno`


##### 多表连接
多表连接是指连接操作中涉及到的表的个数大于2的连接操作，多表连接的连接条件可以是等值连接，也可以是非等值连接。
```sql
SELECT <表名1>.<列名1>, <表名2>.<列名2> 
FROM <表名1>,<表名2>,<表名3> 
WHERE <表名1>.<列名1> <比较运算符> <表名2>.<列名2> AND <表名2>.<列名2> <比较运算符> <表名3>.<列名3>;
```

#### 嵌套查询
一个`SELECT-FROM-WHERE`语句称为一个查询块，一个查询块可以嵌套在另一个查询块的`WHERE`子句或`HAVING`子句中，这种查询称为嵌套查询

```sql
SELECT <列名1>,<列名2>,... 
FROM <表名1>,<表名2>,... 
WHERE <列名1> <比较运算符>/<IN> (<SELECT-FROM-WHERE>);
```
+ 外层查询（父查询），内层查询（子查询）
+ **子查询中不能使用`ORDER BY`子句**
+ 有些嵌套查询可以使用连接运算代替
+ `相关子查询`：子查询中的`WHERE`子句中的条件包含父查询中的属性
+ `非相关子查询`：子查询中的`WHERE`子句中的条件不包含父查询中的属性

##### 使用`IN`的子查询
> + 查询选修了课程名为“信息系统”的学生学号和姓名
>
>   嵌套查询
>
>   ```sql
>   SELECT Sno,Sname /*③ 最后在Student关系中取出Sno和Sname*/
>   FROM    Student  
>   WHERE Sno  IN
>   (  SELECT Sno  	/*② 然后在SC关系中找出选修了3号课程的学生学号*/
>   	 FROM    SC      
>   	 WHERE  Cno IN
>   		( SELECT Cno   /*① 首先在Course关系中找出 “信息系统”的课程号*/
>   		  FROM Course    
>   		  WHERE Cname= '信息系统'
>        )
>   );
>   ```
>
>   连接查询
>
>   ```sql
>   SELECT Student.Sno,Sname
>   FROM    Student,SC,Course
>   WHERE Student.Sno = SC.Sno 
>   AND SC.Cno = Course.Cno 
>   AND Course.Cname='信息系统';
>   ```

##### 使用比较运算符的子查询

带有比较运算符的子查询是指父查询与子查询之间用比较运算符进行连接。当用户能确切知道内层查询返回的是`单个值`时，可以用>、<、=、>=、<= 、!=或< >等比较运算符

```sql
SELECT <列名1>,<列名2>,... 
FROM <表名1>,<表名2>,... 
WHERE <列名1> <比较运算符> ANY/ALL (<SELECT-FROM-WHERE>);
```

+ `ANY`：表示子查询的结果中的任意一个值

+ `ALL`：表示子查询的结果中的所有值

+ 事实上可以使用聚集函数代替`ANY`和`ALL`，且效率更高
  
  |     | =   | <>或!= | <    | <=    | >    | >=    |
  | --- | --- | ------ | ---- | ----- | ---- | ----- |
  | ANY | IN  | –      | <MAX | <=MAX | >MIN | >=MIN |
  | ALL | –   | NOT IN | <MIN | <=MIN | >MAX | >=MAX |

>+ 找出每个学生超过他选修课程平均成绩的课程号
>
>  ```sql
>  SELECT Sno, Cno
>  FROM  SC  x
>  WHERE Grade >=(SELECT AVG(Grade)  /*相关子查询*/ 
>     	           FROM  SC y
>                 WHERE y.Sno=x.Sno
>     						 );
>  ```
>
>  
>
>+ 查询其他系中比计算机科学某一学生年龄小的学生姓名和年龄
>
>  使用`ANY`函数
>
>  ```sql
>  SELECT Sname,Sage
>  FROM    Student
>  WHERE Sage < ANY (SELECT  Sage
>                    FROM    Student
>                    WHERE Sdept= 'CS')
>     		AND Sdept <> 'CS' ;
>  ```
>
>  
>
>  使用聚集函数
>
>  ```sql
>  SELECT Sname,Sage
>  FROM   Student
>  WHERE Sage < (SELECT MAX(Sage)
>               FROM Student
>               WHERE Sdept= 'CS')
>        AND Sdept <> 'CS';
>  ```
>
>  
>
>

##### 使用`EXISTS`的子查询
`EXISTS`谓词代表存在量词$\exists$，它的一般形式为：`EXISTS <SELECT-FROM-WHERE>`，其中`<SELECT-FROM-WHERE>`是一个查询块，它的结果是一个关系，`EXISTS`谓词的意思是：如果`<SELECT-FROM-WHERE>`的结果非空，则返回`TRUE`，否则返回`FALSE`

```sql
SELECT <列名1>,<列名2>,...
FROM <表名1>,<表名2>,...
WHERE [NOT] EXISTS (<SELECT-FROM-WHERE>);
```
+ `EXISTS`谓词的结果只有`TRUE`和`FALSE`两种情况，即查询到的结果集为空时返回`FALSE`，否则返回`TRUE`
+ 由`EXISTS`谓词引出的子查询中的`SELECT`子句目标列表都使用`*`，因为它的目的只是判断子查询的结果是否为空
+ 带有`EXISTS`谓词的查询往往效率比较高

> + 查询所有选修了1号课程的学生姓名
>
>   连接查询
>
>   ```sql
>   SELECT Sname
>   FROM Student, SC
>   WHERE Student.Sno=SC.Sno 
>   AND SC.Cno= '1';
>   ```
>
>   使用`EXIST`嵌套查询
>
>   ```sql
>   SELECT Sname
>   FROM Student
>   WHERE EXISTS(SELECT *
>                FROM SC
>                 WHERE Sno=Student.Sno 
>      		AND Cno= '1');
>   ```
>

+ 使用`EXIST`实现全称量词$\forall$
  $$
	(\forall \mathbf{X}) \mathbf{P} \equiv \neg(\exists \mathbf{x}(\neg \mathbf{P}))
	$$
	> + 查询所有选修了所有课程的学生姓名
	>
	>   嵌套查询
	>   ```sql
	>   SELECT Sname
	>   FROM Student
	>   WHERE NOT EXISTS(SELECT *
	>                    FROM Course
	>                    WHERE NOT EXISTS(SELECT *
	>                                     FROM SC
	>                                     WHERE Sno=Student.Sno 
	>                                     AND Cno=Course.Cno));
	>   ```
	>   
	>   分组查询
	>   
	>   ```sql
	>   SELECT SNAME FROM STUDENT,SC
	>   WHERE STUDENT.SNO=SC.SNO
	>   GROUP BY STUDENT.SNO,SNAME
	>   HAVING COUNT(*)=(SELECT COUNT(CNO) FROM COURSE);
	>   ```
	>
	
#### 集合查询 不考



### 数据更新
#### 插入数据
##### 插入元组
```sql
INSERT INTO <表名> [(<列名1>,<列名2>,...)]
VALUES (<值1>,<值2>,...);
```
+ `INTO` 列名的顺序可以与表中的属性顺序不同，但是必须与`VALUES`子句中的值的顺序一致
+ 如果没有提供列名，则默认按照表中属性的顺序依次插入
+ 如果新的元组没有提供所有属性的值，则默认为`NULL`
+ 但主码属性不能为`NULL`，如果主码属性没有提供值，则插入失败

> + 插入一个新学生
>
>   ```sql
>   INSERT
>   INTO  Student (Sno，Sname，Ssex，Sdept，Sage)
>   VALUES ('200215128'，'陈冬'，'男'，'IS'，18)；
>   ```
>
>   省略列名
>
>   ```sql
>   INSERT
>   INTO  Student
>   VALUES ('200215128'，'陈冬'，'男'，'IS'，18)；
>   ```
>

##### 插入子查询结果
```sql
INSERT INTO <表名> [(<列名1>,<列名2>,...)]
<SELECT-FROM-WHERE>;
```
+ `SELECT-FROM-WHERE`子句的结果必须与`INSERT`子句中的列名一一对应

#### 修改数据

**注意：增删改都只能针对一个表进行操作，连接多表操作是不允许的**

##### 修改元组

```sql
UPDATE <表名>
SET <列名1>=<表达式1>[,<列名2>=<表达式2>,...]
[WHERE <条件>];
```
+ `SET`：指定要修改的属性及其新值
+ `WHERE`：指定要修改的元组，缺省时表示修改所有元组
+ 进行`UPDATE`时，必须保证完整性约束不被破坏
> + 将所有学生的年龄增加1
>
>   `UPDATE Student SET Sage=Sage+1;`

##### 带子查询的修改

```sql
UPDATE <表名>
SET <列名1>=<表达式1>[,<列名2>=<表达式2>,...]
WHERE <条件> IN <SELECT-FROM-WHERE>;
```

#### 删除数据
##### 删除元组

```sql
DELETE FROM <表名>
[WHERE <条件>];
```
+ `WHERE`：指定要删除的元组，缺省时表示删除所有元组
+ 进行`DELETE`时，必须保证完整性约束不被破坏
+ `DELETE`操作不会删除表中的属性，只删除表中的元组

> + 删除所有学生的记录
>
>   `DELETE FROM Student;`

##### 带子查询的删除

```sql
DELETE FROM <表名>
WHERE <条件> IN <SELECT-FROM-WHERE>;
```
> + 删除所有CS系的学生的选课记录
>
>   ```sql
>   DELETE FROM SC
>   WHERE Sno IN (SELECT Sno
>                 FROM Student
>                 WHERE Sdept='CS');
>   ```

#### 空值处理
空值的存在一般有3种情况：
1. 该属性有值，但是未知
2. 该属性不应该有值
3. 由于某种原因，不便于填写

空值的产生：插入元组时，某些属性没有提供值

空值的判断：`IS NULL`，`IS NOT NULL`

空值的约束条件：
1. 属性定义中指定`NOT NULL`的属性不能为空值
2. 属性定义中指定`UNIQUE`的属性不能有多个空值
3. 属性定义中指定`PRIMARY KEY`的属性不能有空值

空值的运算：
+ 算术运算：任何算术运算的结果都是`NULL`
+ 比较运算：任何比较运算的结果都是`UNKNOWN`
+ 逻辑运算：有了`UNKNOWN`之后，传统二值逻辑运算就转换为三值逻辑运算
	+ `TRUE`：真
	+ `FALSE`：假
	+ `UNKNOWN`：未知
	+ 逻辑运算优先级
	  + `AND`：`FALSE` > `UNKNOWN` > `TRUE`
	  + `OR`：`TRUE` > `UNKNOWN` > `FALSE`
	+ 特别的，`NOT UNKNOWN = UNKNOWN `

> + 选修1号课程的不及格学生以及缺考学生
>
>   ```sql
>   SELECT Sno
>   FROM SC
>   WHERE Cno='1'
>   AND (Grade<60 OR Grade IS NULL);
>   ```


### 视图（VIEW）

1. 视图是一个虚拟的表，其内容由查询定义(从一个或多个基本表中导出的)
2. 视图是一个逻辑概念，不占用物理空间
3. 表中的数据发生变化时，视图中的数据也会发生变化

#### 视图的定义
##### 建立视图

```sql
CREATE VIEW <视图名> [(<列名1>,<列名2>,...)]
AS <SELECT-FROM-WHERE> [WITH CHECK OPTION];
```
+ 组成视图的属性列名：全部省略或全部指定
+ 子查询`SELECT-FROM-WHERE`中不允许使用`ORDER BY`和`DISTINCT`子句
+ 只是把视图定义存入`数据字典`，并不执行其中的`SELECT`语句
+ `WITH CHECK OPTION`是可选的，用于指定视图更新时的限制条件，更新视图时只能更新那些符合 `WHERE` 子句中指定条件的行，否则将会抛出一个错误

> + IS系选修了1号课程的学生
>
>   ```sql
>   CREATE VIEW IS1 (Sno,Sname,Grade)
>   AS SELECT Student.Sno,Sname,Grade
>   FROM Student,SC
>   WHERE Student.Sno=SC.Sno
>   AND Sdept='IS'
>   AND Cno='1';
>   ```
+ 基于视图的视图
> + IS系选修了1号课程,且成绩90分以上的学生
>
>   ```sql
>   CREATE VIEW IS1_90 
>   AS SELECT Sno,Sname,Grade
>   FROM IS1
>   WHERE Grade>=90;
>   ```

+ 带有表达式的视图
> + 定义一个反映学生出生年份的视图
>
>   ```sql
>   CREATE VIEW Sbirth (Sno,Sname,Sbirth)
>   AS SELECT Sno,Sname,2000-Sage
>   FROM Student;
>   ```

+ 分组视图

>+ 将学生的学号及他的平均成绩定义为一个视图
>
>   ```sql
>   CREATE VIEW Savg (Sno,Savg)
>   AS SELECT Sno,AVG(Grade)
>   FROM SC
>   GROUP BY Sno;
>   ```
>

+ 不指定属性列
+ 不指定属性列时，如果基本表结构发生变化，可能导致映射失效

> + 将所有女生记录定义为一个视图
>
>   ```sql
>   CREATE VIEW F_S (F_Sno,name,sex,age,dept)
>   AS SELECT *
>   FROM Student
>   WHERE Ssex = '女';
>   ```

##### 删除视图

```sql
DROP VIEW <视图名>[CASCADE];
```
+ 从数据字典中删除视图定义
+ 若视图被其他视图所依赖，则不能直接删除
+ `CASCADE`是可选的，表示删除视图的同时删除以其为依赖的视图
+ 删除基本表时，由该表导出的视图需要显式地使用`DROP VIEW`语句删除

##### 查询视图

同查询基本表。RDBMS实现视图查询的方法-视图消解法
1. 进行有效性检查
2. 将视图转换为基本表的查询
3. 执行修正后查询

#### 视图的作用

1. 视图能够简化用户的操作
2. 视图使用户能以多种角度看待同一数据
3. 视图对重构数据库提供了一定程度的逻辑独立性
4. 视图能够对机密数据提供安全保护
5. 适当的利用视图可以更清晰的表达查询

<div STYLE="page-break-after: always;"></div>

## 数据库安全性

### 概述

- 数据库的一大特点是数据可以共享
- 数据共享必然带来数据库的安全性问题
- `数据库系统中的数据共享不能是无条件的共享`

数据库的安全性是指保护数据库不被**泄露、更改或破坏**的能力

- 非授权用户对数据库的恶意存取和破坏
  - 用户身份鉴别、存取控制和视图

- 数据库中重要或敏感的数据被泄露
  - 强制存取控制、数据加密存储和加密传输
  - 系统审计日志分析

- 安全环境的脆弱性

### 安全性控制

**非法使用数据库的情况**

1. 编写合法程序绕过数据库管理系统及其授权机制
2. 直接或编写应用程序执行非授权操作
3. 通过多次合法查询数据库从中推导出一些保密数据

**安全模型**

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20230521151804.png" alt="image-20230521151804575" style="zoom: 50%;" />

#### 用户身份鉴别

用户身份鉴别（Identification & Authentication）

+ 系统提供的最外层安全保护措施
+ 用户标识：由用户名和用户标识号组成（用户标识号在系统整个生命周期内唯一）
+ 身份鉴别方法：
  + 静态口令鉴别
  + 动态口令鉴别
  + 生物特征鉴别
  + 智能卡鉴别

#### 存取控制

DBMS存取控制子系统由`用户权限定义`和`合法权检查机制`组成

+ 用户权限定义：
  + 用户对某一数据对象的操作权力称为权限
  + DBMS提供适当的语言来定义用户权限，存放在数据字典中，称做安全规则或授权规则
+ 合法权限检查：
  + 用户发出存取数据库操作请求
  + DBMS查找数据字典，进行合法权限检查
+ 常用存取控制方法：
  + 自主存取控制
  + 强制存取控制

|  对象类型  |     对象     |                         操 作 类 型                          |
| :--------: | :----------: | :----------------------------------------------------------: |
| 数据库模式 |     模式     |                        CREATE SCHEMA                         |
|            |    基本表    |                  CREATE TABLE，ALTER TABLE                   |
|            |     视图     |                         CREATE VIEW                          |
|            |     索引     |                         CREATE INDEX                         |
|    数据    | 基本表和视图 | SELECT，INSERT，UPDATE，DELETE，<br />REFERENCES，ALL PRIVILEGES |
|            |    属性列    |   SELECT，INSERT，UPDATE，<br />REFERENCES，ALL PRIVILEGES   |

#### 自主存取控制方法

用户权限概念：定义用户存取权限就是定义用户可以在哪些数据库对象
哪些类型的操作。定义存取权限称为`授权`

用户权限组成：`<数据对象，操作类型>`

自主存取控制（Discretionary Access Control，简称DAC）

+ 用户对不同的数据对象有不同的存取权限
+ 不同的用户对同一对象也有不同的权限
+ **用户可将其拥有的存限转授**给其他用户
+ `C2级`的数据库管理系统支持自主存取控制
+ 对`数据`的存取权限通过 SQL 的`GRANT`语句和`REVOKE`语句实现
+ 对`数据库模式`的存取权限通过数据库管理员在创建用户

##### 授权权限
```sql
GRANT <权限>[,<权限>]... 
[ON <对象类型> <对象名>]
TO <用户>[,<用户>]...
[WITH GRANT OPTION];
```
+ 发出`GRANT`语句的用户必须具有授予权限，可以是数据库管理员DBA、数据库所有者或者是被授予权限的用户
+ 接收权限的用户可以是一个或多个具体用户，也可是`PUBLIC`，表示所有用户
+ 全部操作权限：`ALL PRIVILEGES`
+ `WITH GRANT OPTION`选项允许**权限再次转授**
+ `SQL`标准不允许循环授权
+ 对属性列的授权必须明确指出属性列名
> + 把查询Student表和修改学生学号的权限授予用户`zhangsan`，且允许转授权限给其他用户
>
>   ```sql
>   GRANT SELECT,UPDATE(Sno)
>   ON TABLE Student
>   TO zhangsan
>   WITH GRANT OPTION;
>   ```
>

##### 回收权限

```sql
REVOKE <权限>[,<权限>]...
ON <对象类型> <对象名>[,<对象类型> <对象名>]...
FROM <用户>[,<用户>]...[CASCADE|RESTRICT];
```

+ `CASCADE`选项表示将权限级联回收（连根拔起）
+ `RESTRICT`选项表示只有当用户不再拥有任何权限时才能回收

> + 回收用户`zhangsan`对Student表的查询和修改学生学号的权限
>
>   ```sql
>   REVOKE SELECT,UPDATE(Sno)
>   ON TABLE Student
>   FROM zhangsan CASCADE；
>   ```

##### 创建数据库模式权限

数据库管理员在创建用户时实现对创建数据库模式的权限

```sql
CREATE USER <用户名>
[WITH][DBA|RESOURCE|CONNECT];
```
+ 只有数据库系统管理员DBA才能创建用户
+ 默认情况下，创建的用户权限为`CONNECT`

| 拥有权限 | 创建新用户 | 创建模式 | 创建基本表 |  登录数据库，增删改查  |
| :------: | :--------: | :------: | :--------: | :--------------------: |
|   DBA    |    可以    |   可以   |    可以    |          可以          |
| RESOURCE |   不可以   |  不可以  |    可以    |          可以          |
| CONNECT  |   不可以   |  不可以  |   不可以   | 可以，但需拥有相应权限 |

#### 数据库角色

数据库角色是一组权限的集合，可以将角色授予用户，用户可以拥有多个角色，角色可以是用户定义的，也可以是系统预定义的。SQL 中首先使用`CREATE ROLE`语句定义角色
```sql
CREATE ROLE <角色名>
```
使用`GRANT`语句将权限授予角色
```sql
GRANT <权限>[,<权限>]...
ON <对象类型> <对象名>
TO <角色1>[,<角色2>]...
```

使用`REVOKE`语句将权限回收
```sql
REVOKE <权限>[,<权限>]...
ON <对象类型> <对象名>
FROM <角色1>[,<角色2>]...
```

最后使用`GRANT`语句将角色授予用户

```sql
GRANT <角色1>[,<角色2>]...
TO <用户>[,<角色3>]...
[WITH ADMIN OPTION];
```
+ `WITH ADMIN OPTION`选项允许用户**将角色转授**给其他用户

#### 强制存取控制方法

`自主存取控制`仅仅通过对数据的存取权限来进行安全控制，而数据本身并无安全性标记

强制存取控制（Mandatory Access Control，简称MAC）

+ 每一个数据对象被标以一定的密级，每一个用户也被授予某一个级别的许可证
+ 对于任意一个对象，只有具有合法许可证的用户才可以存取
+ `B1级`的数据库管理系统支持强制存取控制
+ 实现强制存取控制时，首先要实现自主

1. 实体分类
   1. 主体：主体是系统中的活动实体。包括数据库管理系统的实际用户和代表用户的各进程
   2. 客体：客体是系统中的被动实体，包括受主体操纵文件、基本表、索引、视图
2. 敏感度标记
   1.` 绝密(TS)` > `机密(S)` > `可信(C)` > `公开(P)`
   2. 主体的敏感度标记称为`许可证级别`（Clearance Level）
   3. 客体的敏感度标记称为`密级`（Classification Level）
3. 强制存取控制规则
	 1. 主体的许可证级别必须大于等于客体的密级，才能读取客体
	 2. 主体的许可证级别必须小于等于客体的密级，才能修改客体
   > 老板读文件，秘书写文件

### 视图机制

视图对数据库安全的作用：

+ 把要保密的数据对无权存取这些数据的用户隐藏起来，从而提供一定程度的安全保护
+ 间接地实现支持存取谓词的用户权限定义



### 审计

- `审计日志（Audit Log）`：将用户对数据库的所有操作记录在上面
- 审计员利用审计日志找出非法存取数据的人、时间和内容
- 审计功能非常浪费时间和空间，`C2`以上安全级别的DBMS必须具有

#### 审计事件

1. 服务器事件：审计数据库服务器发生的事件
2. 系统权限：对系统拥有的结构或模式对象进行操作的审计
3. 语句事件：对SQL语句，如DDL、DML、DQL及DCL语句的审计
4. 模式对象事件：对特定模式对象上进行的SELECT或DML操作的审计

#### 审计功能

1. 基本功能：提供多种审计查阅方式
2. 多套审计规则：一般在初始化设定
3. 提供审计分析和报表功能
4. 审计日志管理功能
   1. 防止审计员误删审计记录，审计日志必须先转储后删除
   2. 对转储的审计记录文件提供完整性和保密性保护
   3. 只允许审计员查阅和转储审计记录，不允许任何用户新改审计记录等
5. 提供查询审计设置及审计记录信息的专门视图

#### 审计分类

- `用户级审计`
  针对自己创建的数据库表或视图进行审计，记录所有用户对这些表或视图的一切成功和（或）不成功的访问要求以及各种类型的SQL操作
- `系统级审计`
  只能由DBA设置 ，监测成功或失败的登录要求、监测`GRANT`和`REVOKE`操作以及其他数据库级权限下的操作

#### 审计设置
```sql
NOAUDIT/AUDIT <审计事件>
ON <对象类型> <对象名>
[BY <用户>]
[WHEN <条件>]
[WITH <选项>]
```
+ `审计事件`：指定要审计的事件，比如`SELECT`、`INSERT`等
+ `BY`子句：指定审计事件的发起者
+ `WHEN`子句：指定审计事件发生的条件
+ `WITH`子句：指定审计事件的选项
+ 审计设置和审计日志都是存放在数据字典中的
+ 必须打开审计开关（`AUDIT_TRAIL`参数）才能进行审计设置
+ 数据库安全审计系统提供一种事后检查的安全机制

<div STYLE="page-break-after: always;"></div>

## 数据库完整性

### 概述
数据库的完整性是指数据库中数据的`正确性`和`相容性`。数据库完整性是数据库的重要特性之一，它是保证数据的正确性和相容性的重要手段。

+ 正确性：指数据是符合现实世界语义，反映了当前现实世界状态的
+ 相容性：指数据库同一对象在不同的关系表中的数据是符合逻辑的

>与安全性进行区分：安全性是指数据库中的数据不受非法存取和非法修改的保护，而完整性是指数据库中的数据是正确的、相容的

数据库在完整性方面应该具备的功能：
1. 提供定义完整性约束的机制

   完整性约束条件也称为完整性规则，是数据库中的数据必须满足的语义约束条件。SQL标准通过数据定义语言来描述完整性，包括**关系模型的实体完整性、参照完整性和用户定义完整性**

2. 提供完整性检查的方法

   数据库管理系统中检查数据是否满足完整性约束条件的机制称为完整性检查。一般在`INSERT、UPDATE、DELETE`语句执行后开始检查，也可以在`事务提交`时检查

3. 违约处理

   数据库管理系统若发现用户的操作违背了完整性约束条件，则采取以下方法来保证完整性

   1. 采取**拒绝执行**该操作
   2. 采取**级连执行**该操作
   3. 设置为**空值**

### 实体完整性

#### 实体完整性的定义

+ 设置主码，让每条记录之间相互可区分

- SQL在`CREATE TABLE`中用`PRIMARY KEY`定义
  - 单属性构成主码有两种说明方法
    - 定义为列级约束条件
    - 定义为表级约束条件
  - 对多个属性构成主码只有一种说明方法
    - 定义为表级约束条件
```sql
CREATE TABLE <表名>
(
    <列名> <数据类型> [列级完整性约束条件],
    <列名> <数据类型> PRIMARY KEY,
    ...
    [表级完整性约束条件]
    PRIMARY KEY (<列名>,<列名>,...)
);
```

#### 实体完整性检查和违约处理

插入或对主码列进行更新操作时，RDBMS按照实体完整性规则自动进行检查。包括：

1. 检查主码值**是否唯一**，如果不唯一则拒绝插入或修改

   检查主码值是否唯一的方法是

   1. 进行**全表扫描**（暴力遍历）
   2. 对主码列建立**索引**，比如`B+树`，然后进行**索引扫描**

2. 检查主码的各个**属性是否为空**，只要有一个为空就拒绝插入或修改



### 参照完整性

#### 参照完整性定义

- SQL中在`CREATE TABLE`中用`FOREIGN KEY`短语定义哪些列为外码
- 用`REFERENCES`短语指明这些外码参照哪些表的主码
```sql
CREATE TABLE <表名>
(
    <列名> <数据类型> [列级完整性约束条件],
    ...
    [表级完整性约束条件]
    FOREIGN KEY (<列名1>,<列名2>,...) REFERENCES <表名>(<列名1>,<列名2>,...)
    [ON DELETE <操作>]
    [ON UPDATE <操作>]
);
```
+ `ON DELETE`子句：指定删除操作时的违约处理
+ `ON UPDATE`子句：指定更新操作时的违约处理
+ `操作`包括：
  + `NO ACTION`：拒绝删除/更新操作（默认）
  + `CASCADE`：级联删除/更新操作
  + `SET NULL`：设置外码列值为空值

#### 参照完整性检查和违约处理

一个参照完整性将两个表联系起来，所以在插入或更新操作时，RDBMS要对两个表进行完整性检查，以下是可能破坏参照完整性的操作：
1. 在**参照表**中插入元组，该元组的外码列值在**被参照表**中不存在。则进行**拒绝插入**操作
2. 在**参照表**中修改元组的外码列值，该外码列值在**被参照表**中不存在。则进行**拒绝修改**操作
3. 在**被参照表**中删除/更新元组，此时**在创建参照表时**设置3种操作：
   1. `NO ACTION`**拒绝删除/更新**操作（默认）
   2. `CASCADE`**级联删除/更新**操作（删除或修改参照表中的所有造成不一致的元组）
   3. **设置为空值**操作（外码非主码的情况下）

### 用户定义的完整性

- 用户定义的完整性就是针对`某一具体应用的数据`必须满足的语义要求
- RDBMS提供，而不必由应用程序承担

#### 属性上约束条件

在`CREATE TABLE`时可以用`CHECK`短语定义属性上的约束条件，即`属性级的限制`。此时需要写在`列级完整性约束条件`中，多个属性级的限制之间用空格分开。插入元组或修改属性的值时，关系数据库管理系统检查属性上的约束条件是否被满足，如果不满足则操作被拒绝执行


1. 非空约束 `NOT NULL`
   + 若被定义为主码，则默认为`NOT NULL`
2. 唯一约束 `UNIQUE`
   + 若被定义为主码，则默认为`UNIQUE`
3. 检查约束 `CHECK`
   + `CHECK (条件表达式)`
   + > 栗子：`CHECK (sex IN ('男','女'))`

#### 元组上约束条件

在`CREATE TABLE`时可以用`CHECK`短语定义元组上的约束条件，即`元组级的限制`。同属性值限制相比，元组级的限制可以设置不同属性之间的取值的相互约束条件。此时需要写在`表级完整性约束条件`中。不满足则操作被拒绝执行

```sql
CREATE TABLE <表名>
(
    <列名> <数据类型> [列级完整性约束条件],
    ...
    [表级完整性约束条件]
    CHECK (条件表达式)
);
```

| 三大完整性 |  实体完整性  |                 参照完整性                 | 用户定义的完整性 |
| :--------: | :----------: | :----------------------------------------: | :--------------: |
|  定义方法  | CREATE TABLE |                CREATE TABLE                |   CREATE TABLE   |
|  检查时机  |  插入/修改   | 参照表：插入/修改<br />被参照表：删除/修改 |    插入/修改     |
|  违约处理  |   拒绝执行   |         拒绝执行/级联操作/设置空值         |     拒绝执行     |

### 完整性约束命名子句
在`CREATE TABLE`时，可以用`CONSTRAINT`短语为完整性约束命名，以便于在后续使用`ALTER TABLE`中对约束进行修改或删除

```sql
CREATE TABLE <表名>
(
    <列名> <数据类型> [列级完整性约束条件],
    <列名> <数据类型> [CONSTRAINT <约束名> <列级完整性约束条件>],
    ...
    [表级完整性约束条件],
    [CONSTRAINT <约束名> <表级完整性约束条件>]
);
```

添加、删除或修改约束条件的语法格式如下：

```sql
ALTER TABLE <表名>
    [ADD CONSTRAINT <约束名> <约束条件>]
    [DROP CONSTRAINT <约束名>]
    [MODIFY CONSTRAINT <约束名> <约束条件>];
```

<div STYLE="page-break-after: always;"></div>

## 关系数据库设计理论

> 关系模式由五部分组成，即它是一个五元组 $ R(U, D, DOM, F)$
>
> + R：关系名，即表名
> + U ：组成该关系的属性名集合
> + D：属性组$U$中属性所来自的域。数据的取值范围和类型
> + DOM： 属性向域的映象集合
> + F：属性组$U$上的一组数据依赖

因为$D$和$DOM$对研究表的设计关系不大，所以在学习关系数据库规范化理论时可以将五元组简化成三元组$R(U,F)$

### 函数依赖

[白话详解数据库函数依赖和Armstrong公理及其引理 - 知乎](https://zhuanlan.zhihu.com/p/344087914)

#### 函数依赖

定义：设 $R(U)$ 是属性集合 $U=\{A 1, A 2, \ldots, A n\}$ 上的一个关系模式， $X, Y$ 是 $U$ 上的两个子集，若对 $R(U)$ 的任意一个可能的关系 $r ， r$ 中不可能有两个元组满足在 $X$ 中的属性值相等而在 $Y$ 中的属性值不等，则称 " $X$ 函数**决定** $Y$ " 或 " $Y$ 函数**依赖于** $X$ " ，记作 $X \to Y$ 

白话：

+ 函数的定义：对于定义域中任意 $x$ ，有且只有一个 $y$ 与之对应。
+ 属性之间的依赖：对于相同的 $X$ 属性值，有且只有一个 $Y$ 属性值与之对应

#### 完全函数依赖与部分函数依赖

定义：在关系 ${R}({U})$ 中，若 $X \to Y$ ，且对于 $X$ 的任何真子集 $X^\prime$ 都有 $X^{\prime} \nrightarrow {Y}$ ，则称 $Y$ **完全函数依赖于** $X$ ，记为: $X \stackrel{f}{\to} Y$ 。否则称 $Y$ **部分函数依赖于** $X$ ，记为 $X \stackrel{p}{\to} Y$

白话：

+ 完全函数依赖指属性组 $X$ 的所有属性一起 (即完全) 才能决定属性 $Y$ ，去掉任何一个属性都不行
+ 相反的，部分函数依赖就是指属性组 $X$ 中的部分属性就可以决定 $Y$ ，用不着全部

注意：部分函数依赖存在**非受控冗余**

#### 传递函数依赖

定义：在 $R({U})$ 中，若 $X \to Y ， Y \to Z$ ，且$Y \not \subset X, Z \not \subset Y , Z\not \subset X , Y \nrightarrow X$ ，则称 ${Z}$ **传递函数依赖**于 ${X}$ 

白话：如果 $X$ 函数决定 $Y ， Y$ 函数决定 $Z$ ，且 $Y 、 Z$ 都不包含于 $X ， Z$ 不包含于 $Y ， Y$ 不能决定 ${X}$ ，则称 ${Z}$ 传递函数依赖于 ${X}$ 

注意1：若 $X \to Y ， Y \to Z$ ，可以通过`传递律`得到 $X \to Z$ ，但不能说 $Z$ 传递函数依赖于 ${X}$

注意2：对 $X \to Y$ ，但 $Y \not \subset X$, 则称 $X \to  Y$ 为`非平凡的函数依赖`，即不由`自反律`决定的依赖

注意3：传递函数依赖存在**非受控冗余**

#### 函数依赖相关概念

##### 候选码/键

定义：设 ${K}$ 为 ${R}({U})$ 中的属性或属性组合，若 $K \stackrel{f}{\to} U$ ，则称 ${K}$ 为 ${R}({U})$ 上的候选码

白话：对于关系 $R(U)$ 中的属性 (组) $K$ ，通过$K$能决定出所有属性，且取$K$的任意真子集就不能决定所有属性，则称$K$为候选码。显然这里有**最小性**的要求

> **题型：求候选码**
>
> 方法：
>
> 1. 确定候选码范围
>
>    + 一定属于候选码的属性：只出现在左边，**或者左右都没出现**
>
>    + 可能属于候选码的属性：左右都出现
>
>    + 不属于候选码的属性：只出现在右边
>
> 2. 先对确定的属性`求闭包`，显然候选码的闭包一定能推出所有的属性
>
>    若不能构成候选码，再将**确定的属性和待定的属性依次进行组合后求闭包**，直到得到的属性组能够推出全部的属性
>
> 栗子：集合$U = \{A,B,C,D,E,G\}$  函数依赖集$F = \{AB \to C, CD\to E,E\to A,A\to G\}$
>
> 1. 确定范围
>    1. 只出现左边或左右都没出现：B、D
>    2. 左右都出现：A、C、E
>    3. 只出现在右边：G
> 2. 求闭包：
>    1. $(BD)^+_F = BD$，非候选码
>    2. $(ABD)_F^+ =ABCDE=U$，候选码
>    3. $(BCD)_F^+ =ABCDE=U$，候选码
>    4. $(BDE)_F^+ =ABCDE=U$，候选码
>    5. 由于已经能推导出候选码，因为最小性原则，不需要继续组合4位的闭包
>    6. 候选码为：$\{ABD,BCD,BDE \}$

##### 主码/键

如果有多个候选码，则可以选择任一候选码作为主码（Primary Key）

##### 超码

能推出所有属性的属性组的集合，根据概念可知：候选码是**极小的超码子集**

白话：我和乔丹合砍80分，我和乔丹的集合就是超码，乔丹是候选码

##### 全码

最极端的情况，整个属性组都是码

##### 主属性

包含在任一候选码中的属性称为主属性，其他属性称为非主属性

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20230526222436.png" alt="image-20230526222436568" style="zoom: 50%;" />

##### 外码

$R(U)$ 的外来码，简称外码（Foreign Key）。需满足两个条件：

1. 非本关系$R$的候选码
2. 是另一关系$S$的候选码

##### 逻辑蕴含

定义：设 ${F}$ 是关系$R(U)$中的一个函数依赖集合， $X 、 Y$ 是 $R$ 的属性子集，如果能从 $F$ 这个函数依赖集合中推导出 $X \to Y$ ，则称 ${F}$ 逻辑蕴含 $X \to Y$ ，或者说 $X \to Y$ 是 ${F}$ 的逻辑蕴含。记作 $F \models X \to Y$ 

##### 闭包

定义：被 ${F}$ 逻辑蕴含的所有函数依赖集合称为 ${F}$ 的闭包，记作 $F^{+}$

白话：能从函数依赖集 $F$ 中推导出的**所有函数依赖组成的集合**，称为 $F$ 的闭包

注意：如果 $F^{+}=F$ ，则称 ${F}$ 是一个全函数依赖组(函数依赖完备集)



#### Armstrong公理

##### 公理

1. `自反律`：若 $Y \subseteq X \subseteq U$ ，则 $X \to Y$ 被 ${F}$ 逻辑蕴含。
   白话：属性集 $X$ 可以决定他的属性子集 (`平凡函数依赖`)
2. `增广律`：若 $X \to Y \in F$ ，且 $Z \subseteq U$ ，则 $X Z \to Y Z$ 被 ${F}$ 逻辑蕴含。
   白话：一个函数依赖两端同时**并**一个相同的属性仍蕴含
3. `传递律`
   若 $X \to Y \in F$ ，且 $Y \to Z$ ，则 $X \to Z$ 被 ${F}$ 逻辑蕴含

##### 引理

1. `合并律`：若 $X \to Y$ 且 $X \to Z$ ，则 $X \to Y Z$ 

   证明：根据增广律可以得到 $X \to X Y$ ， $X Y \to Y Z$ ，再根据传递律得证

2. `伪传递律`：若 $X \to Y$ 且 $W Y \to Z$ ，则 $X W \to Z$ 

   证明：根据增广律可以得到 $WX \to WY$，再根据传递律得证

3. `分解律`：若 $X \to Y$ 且 $Z \subseteq Y$ ，则 $X \to Z$ 

   证明：根据自反律可以得到 $Y \to Z$ ，再根据传递律得证

4. `引理2（分解合并律）`：如果 ${A} 1 ， {~A} 2 ， \ldots ， {An}$ 是属性

   则 $X \to A 1 \ldots . A n$ 等价于对每个 ${Ai}$ 有 $X \to A i(1<=i<=n)$


##### 属性集闭包

对 ${R}({U}, {F}) ， X \subseteq U, U=A 1, A 2, \ldots, A n$ ，令$X_F^{+}={Ai}$ 

用 `armstrong`三个公理可从 ${F}$ 导出 $X \to A i$ ，称 $X_F^{+}$为 ${X}$ 关于 ${F}$ 的属性 (集) 闭包

区分闭包和属性（集）闭包：

+ 闭包指的是$F$的闭包，该集合包含的元素是函数依赖

+ 属性集闭包是$X$属性(集) 关于 $F$ 的属性（集）闭包，该集合包含的元素是属性

属性集闭包的相关引理：

+ `引理3`
  若从 ${F}$ 这个函数依赖集合中可以导出 $X \to Y$ ，当且仅当 $Y \subseteq X_F^{+}$

  白话：只要 $Y$ 这个属性在 $X$ 关于 ${F}$ 的属性(集)闭包中，就一定能推出 $X \to Y$ 。反之，只要能推出 $X$ 决定 $Y$ ，那 $Y$ 一定在 $X$ 关于 $F$ 的属性(集)闭包中

>**题型1**：求属性集 $X(X \subseteq U)$ 关于$U$上的函数依赖集 $F$ 的闭包 $X_F^{+}$ 
>
>**题型2**：判断某个函数依赖$X\to Y$是否成立（求$X$的闭包或利用定理推导）
>
>方法:
>
>1. 令 $X^{(0)}=X, i=0$
>2. 对 $F$ 中的每一个函数依赖 $Y \to Z$，若 $Y \subseteq X^{(i)}$，令 $X^{(i+1)}=X^{(i)} \cup Z$ 
>3. 若 $X^{(i+1)} \neq X^{(i)}$，则用 ${i}+1$ 代替 ${i}$，转(2)
>4. 若 $X^{(i+1)}=X^{(i)}$，则 $X^{(i)}$ 即为 $X_F^{+}$
>5. 若$X^{(i+1)}=U$，则$U$即为$X_F^{+}$
>
>栗子1：设关系模式 $R(A B C)$，$F=\{A \to B, B \to C\}$，求A的闭包
>
>解：A的闭包
>
>1. $X^{(0)} = {A}$
>2. $X^{(1)} = {AB}$，因为$ (A\to B)$
>3. $X^{(2)} = {ABC}$，因为$ (B\to C)$
>4. 因为$X^{(2)} = {ABC}=U$，所以$A_F^{+}= ABC$
>
>栗子2：设关系模式 $R(A B C D)$ ， $F=\{A \to B, B \to C\}$，写出BD的闭包
>
>解：BD的闭包
>
>1. $X^{(0)} = {BD}$
>2. $X^{(1)} = {BDC}$，因为$ (B\to C)$
>3. $X^{(2)} = {BDC}$
>4. 因为$X^{(2)} = X^{(1)}$，所以$(BD)_F^{+}= BCD$
>

##### 覆盖

定义：对 ${R}({U})$ 上的两个函数依赖集合 ${F} 、 {G}$ ，如果 $F^{+}=G^{+}$，则称 ${F}$ 和 ${G}$ 是等价的，也称作 $F$ 覆盖 $G$ 或者 $G$ 覆盖 $F$ 

覆盖的相关引理：

+ `引理4`：$F^{+}=G^{+} \Leftrightarrow F \subseteq G^{+} \wedge G \subseteq F^{+}$

+ `引理5`：每个函数依赖集 $F$ 可被一个其右端至多有一个属性的函数依赖集 $G$ 覆盖

最小覆盖：当 ${F}$ 满足以下3条时，称 ${F}$ 为**最小覆盖**或者**最小函数依赖集**
1. ${F}$ 中每个函数依赖的**右边部分都是单个属性**

2. 对任何 $X \to A \in F$ ，有 ${F}-X \to A$ 不等价于 ${F}$ 

3. 对任何 $X \to A \in F ， Z \subset X$ ，( F- $X \to A) \cup Z \to A$ 不等价于F


  白话：

  + 第2点指出，$F$中的每个函数依赖都是不可或缺的，即无冗余FD
  + 第3点指出，$F$中的每个函数依赖的左端都没有冗余属性

定理：每个函数依赖集 ${F}$ 都有等价的最小覆盖 ${F^\prime}$ **（至少存在一个，但不唯一）**

>**题型：求最小函数依赖集**
>
>方法：
>
>1. **右部最小化：**用`分解合并律`，使$F$中的任何一个函数依赖的右边仅含有一个属性
>2. **去除多余的函数依赖：**从第一个函数依赖$X\to Y$开始，将其从$F$中去掉，然后在剩下的函数依赖中求$X$的闭包$X^+_F$，判断其是否包含$Y$
>    1. 如果包含，则去掉$X\to Y$。否则保留
>    2. 依次做下去，**直到扫描所有函数依赖为止**
>
>3. **左部最小化：**如$XY\to A$，若要判断$Y$是冗余属性，则计算$X_F^+$，判断$A$是否属于$X_F^+$
>    1. 如果属于，则$Y$为冗余属性，将$Y$删除变为$X\to A$
>    2. 同理，判断一次$X$
>
>4. 注意：若(3)修改了函数依赖集$F$，则需重新做步骤二
>
>栗子：${R}=\{{A}, {B}, {C}, {D}, {E}, {G}\}, {F}=\{{B} \to {D}, {DG} \to {C}, {BD} \to {E}, {AG} \to {B}, {ADG} \to {BC}\}$, 求 $F$ 的最小函数依赖
>
>解：
>
>1. 右部最小化：将$ADG\to BC $分解为$ADG\to B $和$ADG \to C$
>2. 去除多余函数依赖：从$B\to D$开始遍历，发现$ADG\to B$和$ADG \to C$可以删除
>3. 左部最小化：从$DG\to C$开始遍历，发现$BD\to E$中的$D$冗余，修改为$B\to E$
>4. 由于(3)修改了$F$，所以从(2)开始重新做一遍，发现本次没有出现冗余
>
>答案：$F =\{B\to D,DG\to C,B\to E,AG\to B \}$
>



### 范式

#### 简介

- 规范化理论是围绕着**范式**建立的
- 满足不同程度要求的约束集则称为不同的范式
- 较高层次的范式比较低层次的范式具有“更合乎要求的性质”
- 一个低一级范式的关系模式，通过投影运算可以转化为若干个高一级范式的关系模式的集合，这个过程叫做**规范化**
- **如果一个关系满足某个范式要求,则它也会满足较其级别低的所有范式的要求**

#### 第一范式(1NF)

- 若关系模式$R(U)$中关系的每个分量都是`不可分的数据项`（值，原子）

  则称 ${R}({U})$ 属于第一范式，记为 : ${R}({U}) \in {1 N F}$ 

- 第一范式是对关系模式的最起码的要求。不满足第一范式的数据库模式不能称为关系数据库

非`1NF`处理：将复合属性处理为简单属性，将多值属性与关键字单独组成新关系

#### 第二范式(2NF)

- 若$R(U) \in {1 N F}$ 且 $U$中的每一**非主属性完全函数依赖于候选码**

  则称$R(U)$属于第二范式，记为 : $R(U) \in 2 N F$

- `2NF`消除了非主属性对候选码的**部分函数依赖**

非`2NF`处理：采用投影分解法将一个1NF的关系分解为多个2NF的关系

#### 第三范式(3NF)

- 若$R (U, F) \in 2 N F$ 且 $R$中不存在这样的情况：候选键$X$，属性组 $Y \subseteq U$ 和非主属性 $A$ ，且 $A \notin X, A \notin Y, Y \notin X, Y \nrightarrow X$ ，使得$X \to Y, Y \to A$ 成立

  则称 $R(U)$ 属于第三范式，记为 : $R(U) \in 3 N F$

- `3NF`消除了非主属性对候选码的**传递函数依赖**

- 注意这里的$Y\notin X$，说明其不能完全由主属性构成

- 仍然不能完全消除关系模式中的各种异常情况和数据冗余

非`3NF`处理：采用投影分解法将2NF关系分解。每有一个函数依赖，就变成一个关系模式。然后合并部分关系模式（其中不含传递依赖）

#### BCNF范式

+ 若 $R(U , F) \in 1 N F$ ，若对于任何 $X \to Y \in F$ (或 $X \to A \in F)$ ，当 $Y \notin X($ 或 $A \notin X)$ 时， $X$必含有候选键

  则称 $R(U)$ 属于Boyce-Codd范式，记为 : $R(U) \in B C N F$

+ 等价于：每一个FD左端都包含候选码（任意一个），即左端为超码（我和乔丹）
+ `BCNF`消除了**任何属性**对候选码的**部分和传递函数依赖**
+ 性质：
  + 所有非主属性对每一个码都是完全函数依赖
  + 所有的主属性对每一个不包含它的码，也是完全函数依赖
  + 没有任何属性完全函数依赖于非码的任何一组属性
  + 显然的，如果一个关系的函数依赖集为空，那么至少为BCNF范式
+ 一个模式中的关系模式如果都属于`BCNF`，那么在**函数依赖范畴**内它已实现了彻底的分离，`已消除了插入和删除的异常`

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20230522205136.png" alt="image-20230522205135903" style="zoom: 50%;" />

>题型：判断范式类型
>
>1. 判断候选码和非主属性
>2. 判断是否具有部分依赖（找部分候选码推出非主属性）
>   1. 若有：则为1NF
>
>   2. 若无继续判断
>
>3. 判断是否具有传递依赖（找候选码推出非主属性，而这个非主属性又推导出另一个非主属性）
>   1. 若有：则为2NF
>   2. 若无继续判断
>
>4. 判断DF左端是否都为超码
>   1. 若是：则为BCNF
>   2. 若非：则为3NF
>
>
>
>

### 模式分解

#### 定义

##### 分解属性定义

关系模式 ${R}<{U}, {F}>$ 的一个**分解**是指

$\rho=\left\{R_1<U_1, F_1>, \ldots, R_n<U_n, F_n>\right\}$

其中 $U=U_1 \cup {U}_2 \cup \cdots  \cup {U}_{{n}}$

+ 表明分解后的属性与分解前不多不少

并且没有 ${U}_{{i}} \subseteq {U}_{{j}}, 1 \leq {i} , {j} \leq {n}$, $F_i$ 是 $F$ 在 $U_i$ 上的投影

+ 表明不存在分解出的关系$R_i$之间存在包含关系

##### 分解依赖定义

函数依赖集合 $\left\{X \to Y \mid X \to Y \in {F}^{+} \wedge X Y \subseteq {U}_{{i}}\right\}$ 的一个覆盖 ${F_i}$ 叫作 ${F}$ 在属性 $U_i$ 上的投影

+ 表明了函数依赖应该根据其中的属性分配到拥有对应属性集$U_i$对应的关系模式$R_i$中

##### 模式分解的三个定义

对于一个模式的分解是多种多样的，但是分解后产生的模式应与原模式**等价**。对“等价”的概念形成了三种不同的定义：

1. **不丢失内容**：分解具有无损连接性（lossless join）
2. **不丢失约束**分解要保持函数依赖（preserve functional dependency）
3. 分解既要保持函数依赖，又要具有无损连接性

这三个定义实际是实行分解的三条不同的准则。按照不同的分解准则，模式所能达到的分离程度各不同，**各种范式就是对分离程度的测度**

#### 无损连接性

**投影连接的定义：**

对于关系模式$R$的任一关系实例$r$，它向 $\rho$ 的投影连接记为 $m_\rho(r)$ :
$$
m_\rho(r)=\pi_{R_1}(r) \bowtie \ldots \bowtie \pi_{R_k}(r)=\bowtie_{(i=1, \ldots, k)} \pi_{R_i}(r)
$$
这里 : $\pi_{R_i}(r)=\left\{t\left[R_i\right] \mid t \in r, i=1, \ldots, k\right\}$

白话：

+ 所谓投影，就是把大表拆成若干小表，即分解
+ 所谓$r$就是具体的一张大表
+ 所谓$\rho $就是一种分解方式，其中有各个分解后的小表$R_i$
+ 所谓$m_\rho(r)$就是将分解后的小表再次**连接**起来
  + 若小表之间有公共属性列，则进行**自然连接**，否则进行笛卡尔积

投影连接的引理：

1. $r\subseteq m_\rho(r)$ 
2. 如果 $s=m_\rho(r)$，则 $\pi_{R i}(s)=r_i$
3. $m_p\left(m_p(r)\right)=m_p(r)$

白话：

1. 投影连接后的表肯定包含原关系$r$（只多不少）
2. 投影连接后再次分解，等价于直接投影/分解
3. 连续多次连接等价于连接一次

**无损连接的定义：**

$\rho=\left\{R_1<U_1, F_1>, \ldots, R_n<U_n, F_n>\right\}$ 是 $R<U, F>$ 的一个分解，若对 $R<U, F>$ 的任何一个关系实例 $r$ 均有 $r=m_\rho (r)$ 成立，则称分解 $\rho$ 具有无损连接性。简称 $\rho$ 为`无损分解`

+ 只有具有无损连接性的分解才能够保证不丢失信息

* 无损连接性不一定能解决插入异常、删除异常、修改复杂、 数据冗余等问题

>**题型：判别无损连接的算法**
>
>方法：
>
>1. **构造初始表：**列表示所有的属性，有多少属性就画多少个属性列。行表示分解后的关系，有几个关系就画几个关系行
>2. **初始化：**逐行判断关系中含有的属性，并将其标为$a_j$，$a$的下标是列号。而关系中不存在的属性则标为$b_{ij}$，下表分别是行号和列号
>3. **更新：**依次对函数依赖集里的各个依赖关系FD进行考察。对每个$FD:X\to Y$而言，如果表格中总有（大等于）两行在$X$分量上相等，而在$Y$分量上不相等，则修改$Y$分量的值，使这两行在Y分量上相等：
>    1. 如果$Y$分量中有一个为$a_j$，则另一个也变为$a_j$
>    2. 如果$Y$分量都没有$a_j$，则取$j$下标最小的$b_{ij}$
>
>4. 反复执行以上操作，直到某次操作后，存在某一行全为$a$，则说明$\rho$是无损分解
>5. 反之，若某次操作后表格内容不变，且无全$a$行，则非无损分解
>
>栗子：已知 $F:\langle U, F\rangle, U=\{A, B, C, D, E\}, F=\{A B \to C, C \to D, D \to E\}$ 
>
>$R$ 的一个分解为 $\left.R_1(A, B, C), R_2(C, D\right), R_3(D, E)$ 
>
>1. 构造初始表并初始化
>
> >
> >|       |   $A$    |   $B$    |    C     |    D     |    E     |
> >| ----- | :------: | :------: | :------: | :------: | :------: |
> >| $R_1$ |  $a_1$   |  $a_2$   |  $a_3$   | $b_{14}$ | $b_{15}$ |
> >| $R_2$ | $b_{21}$ | $b_{22}$ |  $a_3$   |  $a_4$   | $b_{25}$ |
> >| $R_3$ | $b_{31}$ | $b_{32}$ | $b_{33}$ |  $a_4$   |  $a_5$   |
>2. 更新表：
>
>  + $A B \to C$ ：没有相同的分量行，不进行更新
>
>  + $C \to D$ ：$R_1$与$R_2$相同，进行更新：$R_2$具有$a_4$，所以将$R_1$中的$b_{14}$更新为$a_4$
>
>  + $D \to E$ ：$R_1$、$R_2$与$R_3$相同，进行更新：$R_3$具有$a_5$，所以将$R_1,R_2$中的$b_{15},b_{25}$更新为$a_5$
>
>3. 判断：
>>
> >|       |   $A$    |   $B$    |    C     |    D    |    E    |
> >| ----- | :------: | :------: | :------: | :-----: | :-----: |
> >| $R_1$ |  $a_1$   |  $a_2$   |  $a_3$   | $a_{4}$ | $a_{5}$ |
> >| $R_2$ | $b_{21}$ | $b_{22}$ |  $a_3$   |  $a_4$  | $a_{5}$ |
> >| $R_3$ | $b_{31}$ | $b_{32}$ | $b_{33}$ |  $a_4$  |  $a_5$  |
>
>+ 发现$R_1$行全$a$，说明该分解具有无损连接性

##### 无损连接性定理

设$F$是关系模式$R$上的一个函数依赖集合。 $\rho=\left\{R_1, R_2\right\}$ 是 $R$ 的一个分解

则当且仅当 $U_1 \cap U_2 \to U_1-U_2$ 或者 $U_1 \cap U_2 \to U_2-U_1$ 属于$F^+$时， $\rho$ 是关于 $F$ 无损连接的

+ 白话：针对分解为两个关系，若其公共属性能推导出所有独有属性，则为无损连接

#### 保持函数依赖

 ${F}^{+}=\left({\cup}_{i=1}^k F_i\right)^{+}$，则 $R\langle U, F\rangle$ 的分解 $\rho=\left\{R_1\left\langle U_1, F_1\right\rangle, \cdots\right. R_k<U_k,F_k>$保持函数依赖

+ 白话：原本函数依赖的闭包与分解后函数依赖的总闭包相等$ F^+ = (\cup F_i)^+ $（即$F$与$\cup F_i$等价），则称为保持函数依赖
+ 注意1：保持依赖的分解可能不是无损连接的
+ 注意2：无损连接的分解可能不是保持依赖的

>题型：求函数依赖集在投影$R_i$上的函数依赖$F_i$
>
>方法：
>
>1. 依次取$R_i$中的单属性，求其在$F$上的闭包
>   1. 若存在单属性的闭包能包含$U_i$ （候选码），则在下一轮选取中将其从$U_i$中删除
>
>   2. 若此时$U_i$中还剩2个以上属性，则依次取$R_i$中的双属性，求其在$F$上的闭包
>   3. 若存在双属性的闭包能包含$U_i$ （候选码），则在下一轮选取中将其从$U_i$中删除
>
>   4. 依次类推，直到没有足够的属性以选取属性组合为止
>
>2. 根据各个闭包，写出**其非平凡函数依赖**（即不是推出子集的函数依赖）
> 3. 若右端不止一个属性，可以使用`分解结合律`进行拆分成多个函数依赖
>
>

>**题型：判断是否保持函数依赖**
>
>方法：
>
>1. 求在投影$R_i$上的函数依赖$F_i$
>2. 根据$U_i$包含的属性进行各个函数依赖的分配得到$F_i$，可以使用`分解结合律`合并相同左部的依赖
>
>3. 各依赖$F_i$并起来得到$G$
>4. 检查$F$中的函数依赖，是否在$G$中全部都出现
>   1. 若全部出现，则保持函数依赖
>   2. 若存在某些函数依赖没出现
>      1. 计算其左端属性在$G$中闭包，判断其闭包是否包含该依赖的右端属性
>      2. 若包含，则保持函数依赖。反之不保持
>
>5. 或者直接判断$ F^+ ?= G^+ $
>
>栗子：$R(A,B,C,D),F = \{A\to B,B\to C,C\to D,D\to A\},\rho =\{ AB,BC,AD\}$，判断其是否保持函数依赖
>
>1. 求各个$F_i$
>2. $R_1(AB),F_1=\{B\to A,A\to B \}$
>3. $R_2(BC),F_2=\{B\to C,C\to B \}$
>4. $R_3(AD),F_3=\{A\to D,D\to A \}$
>5. 得到合并依赖集$G = F_1\cup F_2\cup F_3$
>6. 法2：
>   1. 比较$F$不难发现，$C\to D$没有在$G$中出现
>   2. 计算左端：$C$在$G$中的闭包：$C^+_F =\{C,B,A,D\}$
>   3. 发现右端：$D\in C^+_F$，所以该分解保持函数依赖

#### 模式分解算法

+ 若要求分解保持函数依赖，那么模式分解一定能够达到`3NF`，但不一定能够达到`BCNF`

+ 若要求分解既具有无损连接性，又保持函数依赖，则模式分解一定能够达到`3NF`，但不一定能够达到BCNF

+ 若要求分解具有无损连接性，那么模式分解一定能够达到`4NF`（自然也就达到了`BCNF`）


| 无损连接 | 保持依赖 | 达到的范式                |
| :------: | :------: | :------------------------ |
|          |    Y     | 3NF，不一定BCNF |
|    Y     |   Y    | 3NF，不一定BCNF |
|   Y    |          | BCNF                      |

##### 转化3NF

将关系模式$R$无损分解且保持函数依赖地分解成`3NF`模式集

1. 对于关系模式$R$和$R$上成立的FD集$F$，先求出$F$的**最小函数依赖集**$F^\prime$（见[覆盖](#覆盖)）
2. 再把$F^\prime$中那些左部相同的FD用`合并律`合并起来得到$G$
3. 对$G$中，每个FD $X\to Y$ 构成一个新模式$R_i(XY)$
4. 在构成的模式集合中
   1. 检查是否存在模式之间有包含关系，若有，则删除小的关系
   2. 根据$G$求出候选码（见[候选码](#候选码/键)）
   3. 如果每个模式都不包含候选键，则将候选键作为一个新模式放入模式集中（多个候选键放一个即可）


这样得到的模式集是关系模式$R$的一个分解，并且这个分解**既是无损分解，又能保持函数依赖**

栗子：
$$
R(A, B, C, D, E, G) \\F=\{A\to B, A\to C, A\to D, A\to E, A\to G, C D E\to G, G\to C, G\to D\}
$$

1. 求最小函数依赖集$F=\{A\to B,A\to E,A\to G,CDE\to G,G\to C,G\to D \}$
2. 求合并集$G = \{A\to BEG, CDE\to G, G\to CD\}$
3. 建立新模式$R_1(ABEG),R_2(CDEG),R_3(GCD)$
4. 发现$R_3 \in R_2$，故删除$R_3$
5. 求候选码，得到$A$
6. 发现$R_1$包含$A$，故不需要新建关系$R_i(A)$
7. 则$\rho = {R_1(ABEG),R_2(CDEG)}$

##### 转化为BCNF

将关系模式$R$无损分解地分解成`BCNF`模式集

1. 置初值 $\rho=\{R\}$，求候选码

2. 检查 $\rho$ 中所有关系模式都满足 `BCNF`（见[BCNF](#BCNF范式)），则算法结束

3. 若 $\rho$ 中的 $R_i<U_i,F_i>$ 不属于`BCNF`

   那么必有 $X \to A\in F_i^{+}(A \notin X)$，且$X$非$R_i$的码。因此，$X\cup A$是$U_i$的真子集

   对$R_i$再次进行分解：$\sigma =\{S_1,S_2 \}, U_{s 1}=X A, U_{s 2}=U_i-\{A\}$, 以 $\sigma$ 代替 $R_i\left(U_i, F_i\right)$ 

   + 不符合，拆两半；小的一坨塞一起，大的一坨删右端
   + 新的小关系必然满足，后续无需再检查
   
   返回(2)再次检查

+ 值得注意的是，每拆开一次最好都要更新一下对应的$F_i$（求旧$F_i$在新关系$R_i$上的投影，见[求Fi](#保持函数依赖)），**有可能出现传递函数依赖导致的新依赖**

栗子：
$$
R(C,T,H,R,S,G)
\\
F=\{ C \rightarrow T,  H R \rightarrow C,  H T \rightarrow R,  C S \rightarrow G,  H S \rightarrow R\}
$$

1. 求出候选码$HS$，显然只有$HS\to R$符合
2. 分解$CS\to G$：$R_1(CSG),R_2(CTHRS)$
+ $F_1 = \{CS\to G\}$
+ $F_2=\{C \to T, H R \to C, H T \to R, H S \to R\}$
+ 没有特殊改变
3. 分解$C\to T$：$R_1(CSG),R_2(CT),R_3(CHRS)$
	1. $F_2 = \{C\to T \}$
	2. $F_3 = \{HR\to C, CH\to R,HS\to R \}$
	3. 发现特殊的$CH\to R$
4. 分解$CH\to R$：$R_1(CSG),R_2(CT),R_3(CHR),R_4(CHS)$
	1. $F_3=\{CH\to R, HR\to C\}$
	2. $F_4 = \{HS\to C \}$

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20230524002108.png" alt="image-20230524002108562" style="zoom: 50%;" />

>综合题：设有关系模式 ${R}({A}, {B}, {C}, {D}, {E}, {F}, {G})$
>
>其基本的函数依赖集 $F=\{A$ $A \rightarrow C, E \rightarrow D, A E \rightarrow G\}$
>
>其分解为 $\rho=\{R 1(A, B, C), R 2(A, D, E, F, G)$
>
>1. 找出 $R$ 的候选键，直接给出结果
>
>   显然是$AEF$，**别忘记了没有出现在函数依赖中的必为候选码**
>
>2. 判断 ${R}$ 最高属于第几范式，说明理由
>     1NF，理由：存在非主属性对候选键的局部依赖，例如: ${A} \rightarrow {B}$
>
>3. 判断分解 $\rho$ 是否保持函数依赖，是否无损，说明理由
>
>   分解后的 ${F} {1}=\{{A} \rightarrow {B}, {A} \rightarrow {C}\}, {F} {2}=\{{E} \rightarrow {D}, {A E} \rightarrow {G}\}$
>   因为: $F 1 \cup F 2=G=F$，所以$G$与$F$一定等价，所以 $\rho$ 保持依赖
>
>   利用定理判断：${U} 1 \cap {U} 2=A, {U} 1-{U} 2={BC}$ 
>   因为 ${A} \rightarrow {BC} \in {F}$，即 ${U} 1 \cap {U} 2 \rightarrow {U} 1-{U} 2 \in {F}$，所以 $\rho$ 无损
>
>4. 将 $R$ 无损且保持依赖地分解为 $3 {NF}$ 的模式集 $\rho$，直接给出结果
>
>   $\rho=\{{R} 1({A}, {B}, {C}), {R} 2({D}, {E}), {R} 3({A}, {E}, {G}), {R} 4({A}, {E}, {F})\}$，注意加入$G$的候选码$AEF$
>
>

<div STYLE="page-break-after: always;"></div>

## 数据库设计

### 概述

数据库技术是信息资源管理最有效的手段。数据库设计是指对于一个给定的应用环境，构造数据库**逻辑模式**和**物理结构**，建立数据库及其应用系统，有效存储数据，满足用户**信息管理要求**和**数据操作要求**。

+ 三分技术，七分管理，十二分基础数据
+ 结构设计和行为设计相结合（数据库设计和应用程序设计并行）

#### 数据库设计方法

常用的数据库设计方法如下：

1. 新奥尔良方法：将数据库设计分为若干阶段和步骤
2. 基于 E-R 模型的设计方法：概念设计阶段广泛采用
3. 基于 3NF 的设计方法：逻辑阶段可采用的有效方法
4. ODL（Object Definition Language）方法：面向对象的数据库设计方法
5. 计算机辅助设计：ORACLE Designer 2000、SYBASE PowerDesigner

#### 数据库设计的步骤

1. 需求分析阶段 

	- 收集和分析用户需求，结果得到**数据字典**描述的数据需求
2. 概念结构设计阶段

	- 通过对用户需求进行综合、归纳与抽象，形成一个独立于具体DBMS的概念模型，可以用**E-R图**表示
3. 逻辑结构设计阶段

	- 将概念结构转换为某个DBMS所支持的数据模型（例如关系模型），并对其进行优化（例如使用范式理论）
4. 数据库物理设计阶段

	- 为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）
5. 数据库实施阶段

	- 运用DBMS提供的数据语言（例如SQL）及其宿主语言（例如C），根据逻辑设计和物理设计的结果建立数据库，编制与调试应用程序，组织数据入库，并进行试运行
6. 数据库运行和维护阶段

	- 数据库应用系统经过试运行后即可投入正式运行。在数据库系统运行过程中必须不断地对其进行评价、调整与修改

#### 数据字典

对数据库设计来讲，`数据字典`是进行数据收集和数据分析所获得的主要成果。数据字典是各类数据描述的集合 

数据字典通常包括数据项、数据结构、数据流、数据存储和处理过程五个部分：

- `数据项`是不可再分的数据单位
- `数据结构`反映了数据之间的组合关系。一个数据结构可以由若干个数据项组成，也可以由若干个数据结构组成，或由若干个数据项和数据结构混合组成
- `数据流`是数据结构在系统内传输的路径
- `数据存储`是数据结构停留或保存的地方，也是数据流的来源和去向之一
- 处理过程描述＝｛处理过程名，说明，输入:｛数据流｝，输出:｛数据流｝，处理:｛简要说明｝｝

### 概念结构设计

#### E-R模型

E-R方法是抽象和描述现实世界的有力工具

##### 表示方法

- 使用长方形来表示实体型，框内写上实体名
- 椭圆型表示实体的属性，并用**无向边**把实体和属性连接起来
- 用菱形表示实体间的联系，菱形框内写上联系名，用无向边把菱形分别与有关实体相连接
  - 在无向边旁标上联系的类型
  - **若实体之间联系也具有属性，则把属性和菱形也用无向边连接上**

##### 实体型联系

1. 两个实体型之间的联系：
   1. 一对一联系（1:1）
   2. 一对多联系（1:n）
   3. 多对多联系（m:n）
2. 两个以上的实体型之间也存在着一对一、一对多、多对多联系
3. 单个实体型内的联系，即同一个实体集内的各实体之间也可以存在一对一、一对多、多对多的联系
4. `联系的度`：参与联系的实体型的数目
   + 2个实体型之间的联系度为2，也称为二元联系
     N个实体型之间的联系度为N，也称为N元联系

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20230526150350.png" alt="image-20230526150350599" style="zoom: 50%;" />

#### 概念结构设计

##### 实体与属性的划分原则

现实世界的事物能作为属性对待的，尽量作为属性对待。可以简化E-R图的处置。划分实体与属性的两条准则：

1. 作为属性，不能再具有需要描述的性质。属性必须是不可分的数据项，不能包含其他属性
2. 属性不能与其他实体具有联系。E-R图中所表示的联系是实体与实体之间的联系

##### E-R图的集成

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20230524225213.png" alt="image-20230524225206339" style="zoom: 50%;" />

E-R图的集成一般需要分两步：

1. 合并：解决各分E-R图之间的冲突，将分E-R图合并，生成初步E-R图

   E-R图之间的冲突主要有三类

   - 属性冲突 

     - 属性域冲突，即属性值的类型、取值范围或取值集合不同。
     - 属性取值单位冲突
     - 属性冲突通过**协商解决**

   - 命名冲突

     - 同名异义
     - 异名同义（一义多名）
     - 命名冲突通过**协商解决**

   - 结构冲突 

     - 同一对象在不同应用中具有不同的抽象（一边作为实体，一边作为属性）
       - 解决：变为同一抽象
     - 同一实体在不同局部视图中所包含的属性不完全相同，或者属性的次序不完全相同
       - 解决：取属性的并集并适当调整次序
     - 实体之间的联系在不同局部视图中呈现不同的类型（联系类型不同）
       - 解决：通过语义进行综合或调整

2. 修改和重构：消除不必要的冗余，生成基本E-R图

   + 冗余的数据：可由基本数据导出的数据
   + 冗余的联系：可由其他联系导出的联系
   + 注意：并不是所有的冗余数据与冗余联系都必须加以消除，有时为了提高效率，不得不以沉余信息作为代价
   + 消除冗余方法：**分析方法**和**规范化理论的方法**

### 逻辑结构设计阶段

#### E-R图向关系模式的转换

E-R图由实体型、实体的属性和实体型之间的联系三个要素组成。E-R图向关系模型的转换就是将实体型、实体的属性和实体型之间的联系**转化为关系模式**

转换原则：一个实体型转换为一个关系模式，关系的属性为实体的属性，关系的码为实体的码。除此之外，还需将联系逐个进行转换，方式如下：

1. 一对一联系

  1. 转换为一个独立的关系模式

     + 关系模式的属性：与该联系相连的**各实体的码**以及**联系本身的属性**

     + 关系模式的码：**每个实体的码**均是该关系模式的候选码

  2. 也可以与相连的任意一端对应的关系模式合并

     + 合并后关系模式的属性：**加入对应关系的码（作为外码）**和**联系本身的属性**

     + 合并后关系模式的码：不变
     + 该方法可以减少系统模式中的关系个数，一般情况下更倾向于采用

2. 一对多联系

   1. 转换为一个独立的关系模式

      + 关系模式的属性：与该联系相连的**各实体的码**以及**联系本身的属性**

      + 关系模式的码：**n端的实体的码**

   2. 与**n端对应的关系模式合并**

      + 合并后关系模式的属性：加入**1端关系的码（作为外码）**以及**联系本身的属性**
      + 合并后关系模式的码：不变
      + 该方法可以减少系统模式中的关系个数，一般情况下更倾向于采用

3. 多对多联系

   1. 只能转换为一个关系模式

      + 关系模式的属性：与该联系相连的各实体的码**（作为外码）**以及**联系本身的属性**

      + 关系模式的码：各实体码的组合

4. 三个或三个以上实体间的一个多元联系
   1. 只能转换为一个关系模式
      + 关系模式的属性：与该多元联系相连的各实体的码**（作为外码）**以及**联系本身的属性**
      + 关系模式的码：各实体码的组合
5. 具有相同码的关系模式可合并
   + 合并方法：
     1. 将其中一个关系模式的全部属性加入到另一个关系模式中
     2. 然后去掉其中的同义属性（可能同名也可能不同名）
     3. 适当调整属性的次序

>题型1：根据上述语义画出ER图
>
>方法：
>
>1. 画出实体
>2. 画出联系
>3. 写出属性
>4. 连线
>5. 标出联系类型
>6. **标出实体键**
>
>题型2：将ER图转换成关系模式，并指出每个关系模式的主键和外键
>
>方法：
>
>1. 将各个实体的名字转换为各个关系模式的名字
>2. 实体的属性就是关系的属性，实体的码就是关系的码
>3. 实体间联系的转换
>    1. 1对1联系：在任意一方加入对方的主码并设为其外码，并加入联系本身的属性
>    2. 1对n联系：将1方的主码加入n方作为外码，并同时将联系的属性加入n方
>    3. n对m联系：**将联系转换为新的关系模式**，将联系双方的主码加入其中设为主码，并将联系的属性也加入其中
>    4. 多对多联系：**将联系转换为新的关系模式**，其中包含多对多联系的两个实体的主键，作为该关系模式的主键，同时将联系的属性也加入其中
>
>4. 别忘记主码添加下划线（组合主码下划线连在一起），外码添加波浪线（如果是n对m和多对多联系转化的新关系模式，其组合主码本身也是外码，在下划线下**添加分隔的波浪线**）



#### 数据模型的优化 

数据库逻辑设计的结果不是唯一的。得到初步数据据模式后，还应该适当地修改、调整数据库逻辑结构，以进一步提高数据库应用系统的性能，这就是数据模型的优化。关系数据模型的优化通常以规范化理论为指导

1. 确定数据依赖
   - 按需求分析阶段所得到的语义，分别写出每个关系模式内部各属性之间的数据依赖以及不同关系模式属性之间数据依赖

2. 对于各个关系模式之间的数据依赖进行极小化处理，消除冗余的联系

3. 按照数据依赖的理论对关系模式逐一进行分析，考查是否存在部分函数依赖、传递函数依赖、多值依赖等，确定各关系模式分别属于第几范式

4. 按照需求分析阶段得到的各种应用对数据处理的要求，分析对于这样的应用环境这些模式是否合适，确定是否要对它们进行合并或分解
5. 对关系模式进行必要分解：水平分解/垂直分解

几点注意：

1. 对于一个具体应用来说，到底规范化进行到什么程度，需要权衡响应时间和潜在问题两者的利弊来决定
2. 当查询经常涉及两个或多个关系模式的属性时，系统必须经常地进行连接运算，连接运算的代价是相当高的。这种情况下，需要降低规范化程度
3. 非BCNF的关系模式会存在不同程度的更新异常。如果在实际应用中对此关系模式只是查询，并不执行更新操作，就不会产生实际影响

#### 设计用户子模式

- 使用更符合用户习惯的别名 
- 针对不同级别的用户定义不同的视图，以满足系统对安全性的要求
- 简化用户对系统的使用，某些局部应用中经常要使用一些很复杂的查询，为了方便用户，可以将这些复
  杂查询定义为视图。

<div STYLE="page-break-after: always;"></div>

## 数据库恢复技术

### 事务的基本概念



+ 事务(Transaction)是用户定义的一个数据库操作序列，这些操作**要么全做，要么全不做**，是一个不可分割的工作单位

+ 事务和程序是两个概念

  - 在关系数据库中，一个事务可以是一条SQL语句，一组SQL语句或整个程序

  - 一个应用程序通常包含多个事务

+ 事务是**恢复**和**并发控制**的基本单位

#### 事务的定义

##### 显式定义方式

正常终止：`COMMIT`
```sql
BEGIN TRANSACTION;
SQL语句1;
SQL语句2;
...
COMMIT;
```

+ `BEGIN TRANSACTION`：开始一个事务
+ `COMMIT`：提交事务，使事务中的所有操作永久生效

异常终止：`ROLLBACK`
```sql
BEGIN TRANSACTION;
SQL语句1;
SQL语句2;
...
ROLLBACK;
```
+ `ROLLBACK`：回滚事务，使事务中的已完成的所有操作无效，使得数据库回滚到事务开始前的状态

##### 事务的特性ACID

- 原子性（Atomicity）

  - 事务是数据库的逻辑工作单位
  - 事务不可再分，即其中的诸操作要么都做，要么都不做

- 一致性（Consistency）

  - 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态
  - 一致性状态：数据库中只包含成功事务提交的结果

  - 不一致状态：数据库中包含失败事务的结果

- 隔离性（Isolation）

  - 对并发执行而言一个事务的执行不能被其他事务干扰

  - 一个事务内部的操作及使用的数据对其他并发事务是隔离的
  - 并发执行的各个事务之间不能互相干扰
  - 由**并发控制子系统**实现

- 持续性（Durability ）

  - 持续性也称永久性（Permanence）
  - 一个事务一旦提交，它对数据库中数据的改变就应该是永久性的
  - 接下来的其他操作或故障不应该对其执行结果有任何影响
  - 由**恢复管理子系统**实现

保证事务ACID特性是**事务处理**的任务

破坏事务ACID特性的因素：

1. 多个事务并行运行时，不同事务的操作交叉执行

   数据库管理系统必须保证多个事务的交叉运行不影响这些事务的**隔离性**

2. 事务在运行过程中被强行停止

   数据库管理系统必须保证被强行终止的事务对数据库和其他事务没有任何影响

### 数据库恢复概述

故障是不可避免的，故障主要包括：计算机硬件故障、软件的错误、操作员的失误、恶意的破坏等

故障对数据库的影响主要表现为：

1. 运行事务非正常中断
2. 影响数据库中数据的正确性
3. 数据库全部或部分丢失数据等。

数据库恢复：把数据库从错误状态恢复到某一已知的正确状态（亦称为一致状态或完整状态）的功能。是数据库的最后一道防线

### 故障的种类

1. 事务内部故障（应用代码导致的故障）
   1. 有的是可以通过事务**程序本身**发现的
   2. 有的是非预期的，不能由事务程序处理的
      1. 运算溢出
      2. 并发事务发生死锁而被选中撤销该事务
      3. 违反了某些完整性限制而被终止等
   3. 恢复策略：
      1. 强行回滚（ROLLBACK）该事务
      2. 撤销该事务已经作出的任何对数据库的修改
2. 系统故障（软故障）
   1. 故障表现：整个系统的正常运行突然被破坏，内存中缓冲区的信息全部丢失，所有正在运行的事务都非正常终止
   2. 常见原因：特定类型的硬件错误（如CPU故障）、操作系统故障、数据库管理系统代码错误、系统断电等
   3. 恢复策略：
      1. 撤销所有未完成的事务
      2. 重做所有已提交的事务
3. 介质故障（硬故障，外存故障）
4. 计算机病毒



### 恢复的实现技术

恢复操作的基本原理：冗余。利用存储在系统别处的冗余数据来重建数据库中已被破坏或不正确的那部分数据

建立数据冗余的方法常见方法有**数据转储**（backup）和**登记日志文件**（logging）

#### 数据转储

数据转储是指数据库管理员定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存起来的过程

备用的数据文本称为后备副本（backup）或后援副本

##### 转储状态

1. 静态转储
   + 在系统中无运行事务时进行的转储操作
   + 转储开始时数据库处于一致性状态
   + 转储期间不允许对数据库的任何存取、修改活动
   + 得到的一定是一个数据一致性的副本
   + 优点：简单
   + 缺点：降低了数据库的可用性
     + 转储必须等待正运行的用户事务结束
     + 新的事务必须等转储结束
2. 动态转储
   + 转储操作与用户事务并发进行
   + 转储期间允许对数据库进行存取或修改
   + 优点：
     + 不用等待正在运行的用户事务结束
     + 不会影响新事务的运行
   + 缺点：不能保证副本中的数据正确有效，需要**配合动态转储期间的日志文件**才能正确恢复

##### 转储方式

1. 海量转储：每次转储全部数据库
2. 增量转储：只转储上次转储后更新过的数据

海量转储与增量转储比较：

1. 从恢复角度看，使用海量转储得到的后备副本进行恢复往往更方便
2. 如果数据库很大，事务处理又十分频繁，则增量转储方式更实用更有效

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20230525105609.png" alt="image-20230525105609787" style="zoom:67%;" />

#### 日志文件

##### 格式和内容

日志文件的格式和内容：日志文件是用来记录事务对数据库**所有更新操作**的文件

日志文件的格式：以**记录为单位的日志文件**和**以数据块为单位的日志文件**

1. 以记录为单位的日志文件内容：
   + 各个事务的开始标记（`T1 BEGIN TRANSACTION`）
   + 各个事务的结束标记（`T1 COMMIT`或`T1 ROLLBACK`）
   + 各个事务的所有更新操作（`T1 U AA 18 20`）
     + 事务标识（标明是哪个事务）
     + 操作类型（插入、删除或修改）
     + 操作对象（记录ID、Block NO.)
     + 更新前数据的旧值（对插入操作而言，此项为空值）
     + 更新后数据的新值（对删除操作而言，此项为空值）
   + 以上均作为日志文件中的一个日志记录（log record）
2. 以数据块为单位的日志文件，每条日志记录的内容是事务标识和被更新的数据块

##### 日志作用

进行事务故障恢复、进行系统故障恢复和协助后备副本进行介质故障恢复

+ 事务故障恢复和系统故障恢复必须用日志文件

+ 在动态转储方式中必须建立日志文件，后备副本和日志文件结合起来才能有效地恢复数据库
+ 在静态转储方式中，也可以建立日志文件
  + 故障恢复时重新装入后援副本把数据库恢复到转储时刻的正确状态
  + 利用日志文件，重做已完成事务
  + 不必重新运行那些已完成的事务程序就可把数据库恢复到故障前某一时刻的正确状态

##### 登记日志文件

为保证数据库是可恢复的，登记日志文件时必须遵循两条原则

1. 登记的次序严格按并发事务执行的时间次序
2. 必须**先写日志文件，后写数据库**
   1. 写日志文件操作：把表示这个修改的日志记录写到日志文件中
   2. 写数据库操作：把对数据的修改写到数据库中

**为什么要先写日志文件：**

1. 写数据库和写日志文件是两个不同的操作
2. 在这两个操作之间可能发生故障
3. 如果先写了数据库修改，而在日志文件中没有登记下这个修改，则以后就无法恢复这个修改了
4. 如果先写日志，但没有修改数据库，按日志文件恢复时只不过是多执行一次不必要的UNDO操作，并不会影响数据库的正确性



### 恢复策略

#### 事务故障的恢复

事务故障：事务在运行至正常终止点前被终止

恢复方法：由恢复子系统利用日志文件撤消（UNDO）此事务已对数据库进行的修改

+ 事务故障的恢复由系统自动完成，对用户是透明的，不需要用户干预

恢复步骤：

1. 反向扫描文件日志（即从最后向前扫描日志文件），查找该事务的更新操作
2. 对该事务的更新操作执行逆操作。即将日志记录中“更新前的值”写入数据库
   + 插入操作，“更新前的值”为空，则相当于做删除操作
   + 删除操作，则相当于做插入操作
   + 若是修改操作，则相当于用修改前值代替修改后值
3. 继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理
4. 如此处理下去，直至读到此事务的开始标记，事务故障恢复就完成了

#### 系统故障的恢复

系统故障：

1. 未完成事务对数据库的更新可能已写入数据库

2. 已提交事务对数据库的更新可能还留在缓冲区没来得及写入数据库

+ 系统故障的恢复由系统在重新启动时自动完成，不需要用户干预

恢复方法：

1. UNDO故障发生时未完成的事务
2. REDO已完成的事务

恢复步骤：

1. 正向扫描日志文件（即从头扫描日志文件）
   + 重做（REDO）队列：在故障发生前已经提交的事务
     + 这些事务既有`BEGIN TRANSACTION`记录，也有`COMMIT`记录
   + 撤销（UNDO）队列：故障发生时尚未完成的事务
     + 这些事务只有`BEGIN TRANSACTION`记录，无相应的`COMMIT`记录
2. 对撤销（UNDO）队列事务进行撤销处理
   + 反向扫描日志文件，对每个撤销事务的更新操作执行逆操作
3. 对重做（REDO）队列事务进行重做处理
   + 正向扫描日志文件，对每个重做事务重新执行登记的操作

#### 介质故障的恢复

介质故障后磁盘上的物理数据和日志文件被破坏，这是最严重的一种故障，恢复方法是重装数据库，然后重做已完成的事务

+ 介质故障的恢复需要数据库管理员介入

恢复步骤：

1. 装入最新的后备数据库副本，使数据库恢复到最近一次转储时的一致性状态
   + 对于静态转储的数据库副本，装入后数据库即处于一致性状态
   + 对于动态转储的数据库副本，还须同时装入转储时刻的日志文件副本，利用恢复系统故障的方法（REDO，UNDO)才能将数据库恢复到一致性状态
2. 装入有关的日志文件副本（转储结束时刻的日志文件副本），重做已完成的事务
   1. 首先扫描日志文件，找出故障发生时已提交的事务的标识，将其记入重做队列
   2. 然后正向扫描日志文件，对重做队列中的所有事务进行重做处理

| 故障类型 | 恢复方式      |
| -------- | ------------- |
| 事务故障 | UNDO          |
| 系统故障 | UNDO+REDO     |
| 介质故障 | 后备恢复+REDO |

### 具有检查点的恢复技术

#### 检查点记录和重新开始文件

+ 在日志文件中增加检查点记录（checkpoint)
  + 建立检查点时刻所有正在执行的事务清单
  + 这些事务最近一个日志记录的地址
+ 在系统中增加重新开始文件
  + 记录各个检查点记录在日志文件中的地址
+ 恢复子系统在登录日志文件期间动态地维护日志

#### 动态维护日志文件

周期性地执行如下操作：建立检查点，保存数据库状态

具体步骤是：

1. 将当前日志缓冲区中的所有日志记录写入磁盘的日志文件上
2. 在日志文件中写入一个检查点记录
3. 将当前数据缓冲区的所有数据记录写入磁盘的数据库中
4. 把检查点记录在日志文件中的地址写入一个重新开始文件

周期性方式：

+ 定期：按照预定的一个时间间隔，如每隔一小时建立一个检查点
+ 不定期：按照某种规则，比如日志文件已写满一半建立一个检查点

#### 利用检查点的恢复策略

+ 当事务T在一个检查点之前提交
  + T对数据库所做的修改已写入数据库
  + 写入时间是在这个检查点建立之前或在这个检查点建立之时
  + 在进行恢复处理时，没有必要对事务T执行重做操作
+ 当事务T在检查点时还没有完成
  + T对数据库所做的修改已写入数据库
  + 在进行恢复处理时，判断其在故障点前是否完成
    + 如果完成，则重做T，重做的起始点是检查点
    + 如果未完成，则撤销T

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20230525114701.png" alt="image-20230525114701641" style="zoom: 50%;" />



**检查点和数据转储的区别：**

1. 检查点是数据库管理系统内部的一种保护机制，而数据转储是将数据导出到外部文件的过程
2. 检查点通常是自动进行的，而数据转储通常是手动执行的
3. 检查点关注的是事务日志和数据库的一致状态，而数据转储关注的是数据库中的所有数据和结构信息
4. 检查点恢复时需要重放事务日志，而数据转储恢复时需要导入备份文件

### 数据库镜像

+ 数据库管理系统自动把整个数据库或其中的关键数据复制到另一个磁盘上
+ 数据库管理系统自动保证镜像数据与主数据的一致性每当主数据库更新时，数据库管理系统自动把更新后的数据复制过去
+ 频繁地复制数据自然会降低系统运行效率

数据库镜像作用：

+ 出现介质故障时：
  + 可由镜像磁盘继续提供使用
  + 同时数据库管理系统自动利用镜像磁盘数据进行数据库的恢复
  + 不需要关闭系统和重装数据库副本
+ 没有出现故障时：
  + 可用于并发操作（负载均衡）
  + 一个用户对数据加排他锁修改数据，其他用户可以读镜像数据库上的数据

>题型：日志记录分析（带检查点）
>
>题型1：判断那些事务需要**重做REDO**，**撤销UNDO**，无需操作
>
>方法：
>
>1. 首先判断故障发生时事务的状态
>    1. 已提交COMMIT
>    2. 已回滚ROLLBACK
>    3. 未完成
>    4. 未开始：无需处理
>
>  2. 若带有检查点，额外注意是否在检查点之前完成
>     1. 判断故障类型（基本都是系统故障），根据类型选择方法（REDO|UNDO）
>     2. 事务故障：UNDO（未完成，已提交）
>     3. **系统故障：UNDO（未完成，已回滚），REDO（已提交）**
>     4. **若带有检查点：在检查点之前完成的（已提交，已回滚）：修改为无需处理，其余不变**
>     5. 介质故障：后备恢复，REDO（已提交）
>
>
>
>
>题型2：判断故障发生后，恢复后各变量的值
>
>1. 判断故障发生时事务的状态
>2. 判断故障类型，根据类型选择方法
>3. **UNDO的事务直接无视即可**，**REDO的事务为有效操作**，根据次序模拟得到答案
> + 若存在检查点，则检查点前完成（已提交，已回滚）的操作也为有效操作
>
>栗子：
>
><img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20230526160023.png" alt="image-20230526155154590" style="zoom: 50%;" />
>
>如果系统故障发生在23之后，说明系统如何进行恢复
>
>1. 判断事务状态
>    1. 已提交：T1（检查点前），T3，T6，T8
>    2. 已回滚：T2（检查点前），T4
>    3. 未完成：T5，T7
>    4. 未开始：无
>2. 类型为系统故障：进行REDO和UNDO，同时存在检查点
>    1. 不做处理：T1，T2
>    2. 重做REDO：T3，T6，T8
>    3. 撤销UNDO：T4，T5，T7

<div STYLE="page-break-after: always;"></div>

## 并发控制

### 并发控制概述

**多用户数据库系统**：允许多个用户同时使用的数据库系统

特点：在同一时刻并发运行的事务数可达数百上千个



**多事务执行方式**：

1. 事务串行执行
   + 每个时刻只有一个事务运行，其他事务必须等到这个事务结束以后方能运行
   + 不能充分利用系统资源，发挥数据库共享资源的特点
2. 交叉并发方式
   + 在单处理机系统中，事务的并行执行是这些并行事务的并行操作轮流交叉运行
   + 单处理机系统中的并行事务并没有真正地并行运行，但能够提高系统的效率
3. 同时并发方式
   + 多处理机系统中，每个处理机可以运行一个事务，多个处理机可以同时运行多个事务，实现多个事务真正的并行运行
   + 最理想的并发方式，但受制于硬件环境更复杂的并发方式机制
   + 事务并发执行带来的问题：会产生多个事务同时存取同一数据的情况
     + 可能会存取和存储不正确的数据，破坏事务隔离性和数据库的一致性
       + 丢失修改（修改-修改冲突)
       + 不可重复读（读-更新冲突)
       + 读“脏”数据（修改-读冲突）
     + 因此，数据库管理系统必须提供并发控制机制

**操作不一致性：**

1. 丢失修改：两个以上的事务读入同一数据并修改，后提交的事务的提交结果破坏了先提交的事务的提交结果，导致先提交的事务对数据库的修改被丢失
2. 不可重复读：指事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果
3. 读脏数据：事务T1修改某一数据后并将其写回磁盘，事务T2读取同一数据后，T1由于某种原因被撤销，这时T1修改过的数据恢复原值，T2读到的数据就与数据库中的数据不一致

 **事务是并发控制的基本单位**，并发控制机制的任务：

1. 对并发操作进行正确调度
2. 保证事务的隔离性
3. 保证数据库的一致性

**并发控制的主要技术**：

1. 封锁（Locking）
2. 时间戳（Timestamp）
3. 乐观控制法
4. 多版本并发控制（MVCC）

### 封锁

封锁就是事务T在对某个数据对象（例如表、记录等）操作之前，先向系统发出请求，对其加锁。加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象

基本封锁类型：

1. 排它锁（Exclusive Locks，简记为**X锁**）
   + 若事务T对数据对象A加上T锁，则只允许T读取和修改A
   + 其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁
   + 保证其他事务在T释放A上的锁之前不能再读取和修改A
   + 排它锁又称为**写锁**
   + 表示方法：上锁`Xlock(T)`，释放锁`Unlock(T)`
2. 共享锁（Share Locks，简记为**S锁**）
   + 若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，
   + 其它事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁
   + 保证其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改
   + 共享锁又称为**读锁**
   + 表示方法：上锁`Slock(T)`，释放锁`Unlock(T)`

**锁相容矩阵**

|      |  X   |  S   |  -   |
| :--: | :--: | :--: | :--: |
|  X   |  N   |  N   |  Y   |
|  S   |  N   |  Y   |  Y   |
|  -   |  Y   |  Y   |  Y   |

+ 注：似乎有点类似PV操作中的读者-写者问题

### 封锁协议

在运用X锁和S锁对数据对象加锁时，需要约定一些规则，这些规则为封锁协议（Locking Protocol)

+ 何时申请
+ 持续时间
+ 何时释放

#### 一级封锁协议

事务T在**修改数据R**之前必须先对其加X锁，直到事务结束才释放

+ 正常结束（COMMIT）
+ 非正常结束（ROLLBACK）
+ 特点：一级封锁协议**可防止丢失修改**，并保证事务T是可恢复的
+ 缺点：在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它不能保证可重复读和不读“脏”数据

#### 二级封锁协议

在一级封锁协议的基础上加上事务T在读取数据R之前必须先对其加S锁，**读完后立即释放S锁**

+ 特点：二级封锁协议**可以防止丢失修改**和**读“脏”数据**
+ 缺点：在二级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读

#### 三级封锁协议



在一级封锁协议的基础上加上事务T在读取数据R之前必须先对其加S锁，**直到事务结束才释放S锁**

+ 特点：三级封锁协议可防止丢失修改、读脏数据和不可重复读

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20230525152821.png" alt="image-20230525152821236" style="zoom: 50%;" />

+ 不同的封锁协议使事务达到的一致性级别不同：封锁协议级别越高，一致性程度越高
+ 如果所有事务均遵循三级封锁协议，由于其隔离级别高，那么这些事务无论怎样交叉并行，**都是可串性化的调度**

### 活锁和死锁

#### 活锁

以下事务的执行是活锁的情形：

1. 事务T1封锁了数据R
2. 事务T2又请求封锁R，于是T2等待
3. T3也请求封锁R，当T1释放了R上的封锁之后系统首先批准了T3的请求，T2仍然等待
4. T4又请求封锁R，当T3释放了R上的封锁之后系统又批准了T4请求……
5. T2有可能永远等待，这就是活锁的情形

白话：类比操作系统中的进程**饥饿**现象

避免活锁：**采用先来先服务的策略**

+ 当多个事务请求封锁同一数据对象时
+ 按请求封锁的先后次序对这些事务排队
+ 该数据对象上的锁一旦释放，首先批准申请队列中第一个事务获得锁

#### 死锁

以下事务的执行是死锁的情形：

1. 事务T1封锁了数据R1
2. T2封锁了数据R2
3. T1请求封锁R2，因T2已封锁了R2，于是T1等待T2释放R2的锁
4. 接着T2又申请封锁R1，因T1已封锁了R1，T2也只能等待T1释放R1的锁
5. 这样T1和T2一直相互等待到死

白话：类比操作系统中的进程**死锁**现象

##### 死锁的预防

产生死锁的原因是两个或多个事务都已封锁了一些数据对象，然后又都请求对已为其他事务封锁的数据对象加锁，从而出现死等待。预防死锁的发生就是要破坏产生死锁的条件

1. 一次封锁法：要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行
   + 过早加锁，降低系统并发度
   + 难于事先精确确定封锁对象
2. 顺序封锁法：顺序封锁法是预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁
   + 随着数据库中的数据对象增多，维护成本高
   + 难以动态实现

结论：在操作系统中广为采用的预防死锁的策略**并不太适合数据库的特点**。数据库管理系统在解决死锁的问题上更普遍采用的是诊断并解除死锁的方法

##### 死锁的诊断与解除

1. 超时法

   如果一个事务的等待时间超过了规定的时限，就认为发生了死锁
   优点：实现简单
   缺点：有可能误判死锁，时限若设置得太长，死锁发生后不能及时发现

2. 等待图法

   用事务等待图动态反映所有事务的等待情况，事务等待图是一个有向图$G=(T,U)$

   + T为结点的集合，每个结点表示正运行的事务
   + U为边的集合，每条边表示事务等待的情况
   + 若T1等待T2，则T1，T2之间划一条有向边，从T1指向T2
   + 并发控制子系统周期性地（比如每隔数秒）生成事务等待图，检测事务。如果发现图中存在回路，则表示系统中出现了死锁

3. 解除死锁：选择一个处理死锁代价最小的事务，将其撤消。释放此事务持有的所有的锁，使其它事务能继
   续运行下去

### 并发调度的可串行性

#### 可串行化调度

数据库管理系统对并发事务不同的调度可能会产生不同的结果。**串行调度是正确的**。并发执行结果等价于串行调度的调度也是正确的，称为**可串行化调度**

+ 值得注意的是，串行调度本身因为次序的不同可能会产生不同的结果。而只要并发执行的结果满足其中之一为正确的

可串行性（Serializability)：是并发事务正确调度的**准则**，一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度

#### 冲突可串行化调度

冲突可串行化：一个比可串行化更严格的条件

冲突操作：指**不同事务**对**同一数据**的**读写操作**和**写写操作**

+ T1读X，T2写X：$R_1(X), W_2(X)$
+ T1写X，T2写X：$W_1(X), W_2(X)$

+ **（不同事务的）冲突操作**和**同一事务中的两个操作**都是不能交换的
+ 其他所有可交换的操作称为**不冲突操作**

一个调度$Sc$在保证冲突操作的次序不变的情况下，通过**交换两个事务不冲突操作的次序**得到另一个调度$Sc^\prime$，如果$Sc^\prime$是串行的，则称调度$Sc$是**冲突可串行化的调度**。反之，则不是

>栗子：${Sc}_1=r_1(A) w_1(A) r_2(A) w_2(A) r_1(B) w_1(B) r_2(B) w_2(B)$
>
>+ 原调度顺序为：T1对A读写 -> T2对A读写 -> T1对B读写 -> T2对B读写
>+ 目的是令调度顺序变为：T1操作 -> T2操作
>
>1. 把$w_2(A)$与$r_1(B)w_1(B)$交换（不同对象可交换）得到：
>
>   $r_1(A) w_1(A) r_2(A) r_1(B) w_1(B) w_2(A) r_2(B) w_2(B) $
>
>2. 再把$r_2(A)$与$r_1(B)w_1(B)$交换（不同对象可交换）得到：
>
>   $S c_2=r_1(A) w_1(A) r_1(B) w_1(B) r_2(A) w_2(A) r_2(B) w_2(B)$
>
>3. 可以看到$Sc_2$中的下标先全1后全2，说明顺序变为$T1 \to T2$

+ 冲突可串行化调度是可串行化调度的充分条件，但不是必要条件

### 两段锁协议

数据库管理系统普遍采用两段锁协议的方法实现并发调度的可串行性，从而保证调度的正确性

两段锁协议：指所有事务必须分两个阶段对数据项加锁和解锁。在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁。在释放一个封锁之后，事务不再申请和获得任何其他封锁

1. 第一阶段是获得封锁，也称为扩展阶段
   事务可以申请获得任何数据项上的任何类型的锁，但是**不能释放任何锁**
2. 第二阶段是释放封锁，也称为收缩阶段
   事务可以释放任何数据项上的任何类型的锁，但是**不能再申请任何锁**

+ 事务遵守**两段锁协议是可串行化调度的充分条件**，而不是必要条件
+ 若并发事务都遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的

**两段锁协议与防止死锁的一次封锁法：**

+ 一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行，因此一次封锁法遵守两段锁协议
+ 但是两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生死锁

三级封锁协议可以保证并发操作的正确性，但由于其太过严苛，对并发度有负面影响。**三级封锁协议实际是两段锁协议的特例，是更严格的两段锁协议**

### 封锁的粒度

#### 封锁粒度

封锁对象的大小称为封锁粒度（Granularity）

封锁的对象：逻辑单元，物理单元，以关系数据库中的封锁对象为例：

+ 逻辑单元：属性值、属性值的集合、元组、关系、索引项、整个索引、整个数据库等
+ 物理单元：页（数据页或索引页）、物理记录等

封锁粒度与系统的并发度和并发控制的开销密切相关：

+ 封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小
+ 封锁的粒度越小，并发度较高，但系统开销也就越大

#### 多粒度封锁

多粒度封锁（Multiple Granularity Locking）：在一个系统中同时支持多种封锁粒度供不同的事务选择

**选择封锁粒度的原则**：同时考虑封锁开销和并发度两个因素，适当选择封锁粒度

1. 需要处理大量元组的用户事务：以关系为封锁单元
2. 需要处理多个关系的大量元组的用户事务：以数据库为封锁单位
3. 只处理少量元组的用户事务：以元组为封锁单位