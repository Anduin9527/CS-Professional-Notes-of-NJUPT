# 计算机组成原理

主要参考：

[计算机组成原理（哈工大刘宏伟）](http://www.feemic.cn/mooc/icourse163/1205914219)

唐朔飞 《计算机组成原理》（第二版）

[冉冉云 计算机体系结构](https://blog.csdn.net/gzxb1995/category_9814748.html)

## 计算机系统概论

### 计算机系统简介

#### 计算机软硬件概念

计算机系统

1. 硬件：计算机的实体：如主机、外设
2. 软件：具有各类特殊功能的信息（程序）组成
   1. 系统软件：用来管理整个计算机系统
      1. 语言处理程序（编译、链接）
      2. 操作系统
      3. 服务性程序
      4. 数据库管理系统
      5. 网络软件
   2. 应用软件：按任务需要编写的程序

#### 计算机系统的层次结构

1. 物理结构抽象

   ![image-20220625092855877](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625092903.png)

   自底向上地来看：

   1. Physics 物理抽象，电子设备依靠电子的移动进行工作。可以使用 量子 机制，和麦克斯韦方程进行描述。
   2. Devices 电子元件，利用电子在不同物质中的移动特征来构建不同的电子元件，其具有不同的电压电流特征用以描述。
   3. Analog Circuits 模拟电路，利用基本的电子元件构建放大器，滤波器等部件。
   4. Digital Circuits 数字电路，利用模拟电路层进一步构建与非门等。
   5. Logic 逻辑层，利用数字电路进行加法器和存储器的实现。
   6. Microarchitecture 微体系(架构)结构层，具有执行单元和控制单元

2. 程序员角度

   ![image-20220625094958199](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625094958.png)

### 计算机的基本组成

#### 冯·诺依曼计算机的特点

1. 计算机由五大部件（运算器、控制器、存储器、输入设备和输出设备）组成
2. 指令和数据以同等地位**存于存储器**，可按地址寻访
3. 指令和数据用二进制表示
4. 指令由操作码和地址码组成
5. 存储程序（核心特征）
6. 以运算器为中心

#### 冯·诺依曼计算机的硬件图

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625101051.png" alt="image-20220625101051177" style="zoom:80%;" />

+ 实线表示数据通路
+ 虚线表示控制和状态反馈
+ 运算器：核心，算术运算与逻辑运算
+ 存储器：存放数据和程序
+ 控制器：指挥控制程序的运行
+ 输入设备：将信息转化为机器能识别的形式
+ 输出设备：将结果转化为人能识别的形式

#### 冯·诺依曼计算机的结构改进

以存储器为中心的计算机硬件框图

![image-20220625101628906](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625101628.png)

其中，运算器（ALU）和控制器（CU）可以组成 CPU 。存储器可以进一步分为主存和辅存。主存和CPU可以进一步构成主机。输入设备和输出设备统称为I/O设备，主机和I/O设备统称为硬件。则给出

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625103446.png" alt="image-20220625103446906" style="zoom:80%;" />

#### 系统复杂性管理的方法

1. 层次化（Hierachy）：将被设计的系统划分为多个模块或子模块
2. 模块化（Modularity）：有明确定义（well-defined）的功能和接口
3. 规则性（regularity）：模块符合某些通用标准，使其更容易被重用

#### 计算机的工作步骤

1. 建立数学模型
2. 确定计算方法
3. 编写解题程序

给例子：计算$a x^{2}+b x+c=(a x+b) x+c$

1. 从问题来看需要**加法指令**和**乘法指令**

2. 还需要取出数字并放置到累加器中的**取数指令**，和读取结果并放置到存储器中的**读取指令**

3. 最后是显示或者打印的**打印指令**，以及停机指令

4. 计算

    	取 x 至运算器中
    	乘以 a 在运算器中
    	加 b 在运算器中
    	乘以 x 在运算器中
    	加 c 在运算器中

#### 指令格式

都使用16位长度的指令由6位操作码和8位地址码构成，[] 表示在寄存器中保存的内容

1. 取数指令

   取数 a，[a] –> ACC

   000001 0000001000，前六位表示取数指令，后十位表示地址8

2. 存数指令

   存数 b，[ACC] –> b

3. 加法指令

   加数 c，[ACC] + [c] –> [ACC]

4. 乘法指令

   乘数 d，[ACC] * [d] –> [ACC]

5. 打印指令

   $\sigma$ ，[$\sigma$] –> 打印机

6. 停机指令

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625110202.png" alt="image-20220625110202631" style="zoom:67%;" />



#### 存储器的基本组成

上面我们知道，**指令**和**数据**都保存在存储器当中。**存储器**的主要部分是**存储体，MAR，MDR**

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625161002.png" alt="image-20220625161002215" style="zoom:67%;" />

+ **存储体**又有若干**存储单元**构成，**存储单元**又由若干**存储元件**（0/1）构成。 

+ 存储单元：存放一串二进制代码，即**存储字**
+ 存储字长：存储字的长度（位数）
+ 存储单元**按照地址寻址**
+ MAR：存储器**地址寄存器**，**保存了存储单元的地址**，MAR的位数反映了存储单元的个数。**即存储单元个数是$2^{n_{MAR}}$**。
+ MDR：存储器**数据寄存器**，MDR的位数表示该存储器的**存储字长**，即**存储字长是**$n_{MDR}$
+ MAR 就像存储器的入口，其接受某个地址作为寻找请求。存储器找到后将其地址中的**内容**交给存储器出口MDR

#### 运算器的基本组成



![image-20220625162012087](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625162012.png)

ALU：Arithmetic Logic Unit，**算术逻辑运算单元**，运算器中完成算术逻辑运算的逻辑部件

ACC：Accumulator，**累加器**，运算器中运算前存放操作数、运算后存放运算结果的寄存器

MQ：Multiplier-Quotient Register，**乘商寄存器**，乘法运算时存放乘数、除法时存放商的寄存器

X：此字母没有专指的缩写含义，可以用作任一部件名，在此表示操作数寄存器，即运算器中工作寄存器之一，用来**存放操作数**

例：加法操作过程，设加法指令操作码为000001，加数的地址为M

1. 初态：ACC中已经存放好了被加数
2. [M] –> X
3. [ACC] + [X] –> ACC

例2：减法操作过程，设减法指令操作码为000010，减数的地址为M

	1. 初态：ACC中已经存放好了被减数
	1. [M] –> X
	1. [ACC] - [X] –> ACC

例3：乘法操作过程，设乘法指令操作码为000011，乘数的地址为M

1. 初态：ACC中已经存放好了被乘数
2. [M] –> MQ
3. [ACC] –> X
4. 0 –> ACC
5. [ACC] \* [X] –> ACC//MQ

例4：除法操作过程，设触发指令操作码为000111，除数的地址为M

1. 初态：ACC中已经存放好了被除数
2. [M] –> X
3. [ACC] / [X] –> MQ，余数在ACC中

#### 控制器的基本组成

控制器由PC、IR与CU组成

控制器用以解释指令并保证指令按照正确的次序执行，下面来看完成一条指令需要三个大步骤：

1. 取指令，**PC（程序计数器）**存放当前欲执行指令的地址， 具有计数功能：（PC）+ 1 –> PC
2. 分析指令，**IR（指令寄存器）**存放当前欲执行的指令
3. 执行指令，**CU**

例：完成一条**取数指令**的过程

![image-20220625165601107](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625165601.png)

1. 取指令
   1. PC 把指令的地址给MAR 
   2. MAR 在控制器的控制之下，根据地址寻找指定的存储单元
   3. 存储体把指定的存储单元中的指令取出送入 MDR
   4. MDR 取出的指令送入 IR
2. 分析指令
   1. IR 中的操作码部分送给 CU，由 CU 根据指令开始执行操作
3. 执行指令
   1. IR 中的地址码部分送给 MAR
   2. MAR 在控制器的控制之下，根据地址寻找指定的存储单元
   3. 存储体把指定的存储单元中的数据取出送入 MDR
   4. MDR 取出的数据送入ACC，取数完毕

#### 总结

1. 将程序通过输入设备送至计算机
2. 程序首地址 –> PC
3. 启动程序运行
4. 取指令PC→MAR→M→MDR→IR，(PC)+1→PC
5. 分析指令OP(IR)→CU
6. 执行指令AD(IR)→MAR→M→MDR→ACC
7. ……
8. 打印结果
9. 停机

## 系统总线

### 总线的基本概念

> **总线**（Bus）是指计算机组件间规范化的交换数据的方式，即以一种通用的方式为各组件提供数据传送和控制逻辑。从另一个角度来看，如果说[主板](https://zh.wikipedia.org/wiki/主機板)（Mother Board）是一座城市，那么总线就像是城市里的公共汽车（bus），能按照固定行车路线，传输来回不停运作的[比特](https://zh.wikipedia.org/wiki/位元)（bit）。这些线路在同一时间内都仅能负责传输一个比特。因此，必须同时采用多条线路才能发送更多资料，而总线可同时传输的资料数就称为宽度（width），以比特为单位，总线宽度愈大，传输性能就愈佳。总线的[带宽](https://zh.wikipedia.org/wiki/頻寬)（即单位时间内可以传输的总资料数）为：总线带宽 = 频率×宽度（Bytes/sec）

#### 为什么使用总线

| 连接方式     | 硬件资源             | 可扩展性                                         |
| ------------ | -------------------- | ------------------------------------------------ |
| 两两单独连接 | 占用引脚多，连线复杂 | 需要现有设备提供与新设备之间的接口，扩展起来麻烦 |
| 总线式连接   | 占用引脚少，连线简单 | 只需将新设备挂到总线，扩展方便                   |

![为什么要使用总线](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BA%BF.png)

#### 总线上信息的传输

首先，**在任意时刻一条总线只能有一对部件进行信息传输**

总线信息传输方式可以分为**串行传输**和**并行传输**，字面意思来看，串行就是数据是一位一位的发送**，**并行就是数据一组一组的发送。以直觉来看，并行应该是比串行传输速率高的，但事实上现在大部分的芯片都选择串行传输

>**并行总线由于是多个数据同时传输，需要考虑数据的协同性，这就导致了并行传输的频率不能做的很高**。相对的，串行总线只有一条链路，就可以把频率做的很高，提高传输速度，速度提高了就能够弥补一次只能传输一个数据的缺陷。
>
>此外，**并行总线两根相邻的链路其数据是同时传输的**，这就会导致它们彼此之间会产生**严重干扰**，并行的链路越多，干扰越强。因此并行总线需要加强抗干扰的能力，否则传输过程中数据就可能被损坏。如果传输过程中数据故障了，就需要重新对齐数据再传输。而串行总线如果一个数据出错了，只需要重新传输一次就好了，由于串行总线频率高，很快就可以把错误数据重新传输过去。
>
>再次，由于**并行总线是多链路一块传输数据**，就需要很多线，接口需要很多针脚，老式计算机里的并行接口做得很大，接线比较宽，针脚非常多。这样一来装机也很麻烦，因为走线不方便、接口体积很大。

### 总线的分类

#### 根据总线位置进行分类

1. 片内总线：芯片内部的总线
2. 系统总线：计算机各部件的信息传输
   1. 数据总线：双向，与机器字长、存储字长相关
   2. 地址总线：单向，与存储地址、I/O地址相关
   3. 控制总线：
      + 有出：中断请求、总线请求
      + 存储器读、存储器写、总线使用权许可、中断确认
3. 通信总线：用于 计算机系统之间 或 计算机系统 与 其他系统。
   1. 串行传输
   2. 并行传输

### 总线特性及性能指标

#### 总线特性

| 特性分类 | 含义                                 |
| -------- | ------------------------------------ |
| 机械特性 | 尺寸、形状、引脚数、引脚的排列顺序等 |
| 电气特性 | 传输方向、有效电平范围等             |
| 功能特性 | 每根线的功能，如地址、数据、控制等   |
| 时间特性 | 时钟频率、信号的时序关系等           |

#### 性能指标

1. 总线宽度：数据线的根数，根数越多，同时传输的位数就越多
2. 标准传输率：每秒传输的最大字节数（MBps）
3. 时钟类型：同步、不同步
4. 总线复用：地址线和数据线**复用**，以减少芯片的管脚数
5. 信号线数：地址线、数据线和控制线的总和
6. 总线控制方式：突发、自动、仲裁、逻辑、计数
7. 其他指标：负载能力

#### 总线标准

![image-20220627192109975](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%80%BB%E7%BA%BF%E6%A0%87%E5%87%86.png)

顺便一提，现代总线比如雷电4标准已经到 40 Gbps，所以总线标准也是计算机的性能瓶颈之一。

### 总线结构

#### 单总线结构

![单总线结构](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png)

+ 存在主线争用问题
+ 时间延迟高

#### 多总线结构

1. 面向CPU的双总线结构

   ![面向CPU的双总线结构](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220627185027109.png)

   + 考虑到**指令**和**数据**都来自主存，所以用单独的M总线保证其交换速度
   + 假设主存要与I/O设备信息传输，就不得不经过CPU，会打乱CPU的信息交换任务

2. 面向存储器的双总线结构

   ![面向存储器的双总线结构](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%9D%A2%E5%90%91%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%8F%8C%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png)

   + 从主存发出两条总线：存储总线和系统总线
   + CPU和主存也保留了专用总线
   + CPU也可以直接与I/O设备交互
   + 目前还不能做到主存同时使用两根总线

3. 使用通道

   ![通道双主线](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%80%9A%E9%81%93%E5%8F%8C%E4%B8%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png)

   + 一般来说通道有自己的控制器，指令等

4. 三总线结构

   ![三总线结构](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png)

   + 在面向CPU的双总线结构上，将I/O设备分为高速和低速
   + 将高速设备通过新的DMA总线与内存进行直接地信息交换

5. 三总线结构-2

   ![三总线结构2](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%842)

   + 由于内存的进步较于CPU缓慢，容易成为计算机的瓶颈点。所以使用Cache对内存中常用的指令预先读取，然后单独与CPU连接一条局部总线
   + 系统总线通过一个扩展总线接口连接扩展总线，但这样会影响外部设备的传输速率

6. 四总线结构

   ![四总线结构](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%9B%9B%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png)

   + 在三总线-2的基础上将外设分为高速和低速

### 总线控制

总线控制主要解决两个问题：多设备同时申请使用总线的判定（总线判优控制/仲裁）和设备占用总线中保证通讯的正确性（总线通信控制）

#### 总线判优控制

根据组件在总线中的功能可以分为总设备（模块）和从设备（模块）

主设备：对总线有控制权，可以发出占用总线的申请

从设备：没有控制权，只能响应主设备发出的申请

集中式仲裁：把总线的判优逻辑放在一个部件中，根据查询方式不同，又可以分为：**链式查询、计数器定时查询和独立请求方式**

分布式仲裁：总线的仲裁逻辑分散在与总线连接的各主设备上。典型的例子有**以太网**，以太网上接入的各台计算机都可以发起通信，为避免无序竞争，它们都需要遵循以太网的仲裁逻辑，即**载波侦听/冲突检测**。

#### 链式查询

![链式查询](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%93%BE%E5%BC%8F%E6%9F%A5%E8%AF%A2.png)

+ 地址线：从设备查找
+ 数据线：数据传输
+ BR 总线：各接口向总线控制部件提出占用请求
+ BG 总线：总线控制部件**链式地**查询哪个I/O接口提出了占用请求（碰到就停止查询）
+ BS 总线：获得总线使用权的接口利用 BR 总线向总线控制部件，发送一个总线忙碌状态以应答

+ 链式查询的顺序就是设备的优先级顺序
+ 优点：结构简单，算法简单，增删设备容易
+ 缺点：BG 对电路故障特别敏感，速度较慢

#### 计数器定时查询

![计时器定时查询](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E8%AE%A1%E6%97%B6%E5%99%A8%E5%AE%9A%E6%97%B6%E6%9F%A5%E8%AF%A2.png)

+ 设备地址线：由总线控制部件的**计数器**发出信号，通过这个地址来查找某个设备是否发出总线请求
+ 计数器：各接口向总线控制部件通过 BR 提出占用请求。控制器接受到请求并成功通过后就会启动计数器（初值为0或者某个地址），计数器的值通过设备地址线向外输出，查询接口为初值的I/O接口。如果没有提出，则计数器++后重复查询，直到找到提出的I/O接口，并用 BR 进行应答。
+ 优点：优先级是优先级较为灵活，比如通过软件的方式设定初值，那么优先级也就随之改变了

#### 	独立请求方式

![独立请求方式](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%8B%AC%E7%AB%8B%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F.png)

+ 任何一个I/O接口都增加了两条线 BR BG
+ 排队器：通过软件的方式在总线控制部件中动态地调整优先级
+ 缺点：连接复杂

#### 总线通信控制

总线传输周期：完成一次传输需要的时间

- 申请分配：判优问题
- 寻址阶段：主设备向从设备给出地址和命令
- 传输阶段：主设备和从设备交换数据
- 结束阶段：主设备撤销相关信息

方式：

| 通信方式   | 特点                                                         |
| ---------- | ------------------------------------------------------------ |
| 同步通信   | 统一定宽定距的时标控制数据传输                               |
| 异步通信   | 无统一时标，采用应答方式。主设备发出请求（命令），从设备应答，进而完成数据交换 |
| 半同步通信 | 引入等待信号，解决不同速度的两个设备之间的通讯，同步异步结合 |
| 分离式通信 | 不在等待时占据总线，提高总线通信的效率                       |

#### 同步通信

1. 同步通信输入

  ![同步通信](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1.png)

  + 假设一次数据传输使用了四个时钟周期
  + $T_1$的上升沿之前：主设备发出地址信号并持续
  + $T_2$的上升沿之前：给出读命令
  + $T_3$的上升沿之前：从设备需要将需要数据发送到数据线上
  + $T_4$的上升沿之前：撤销数据、撤销读命令
  + $T_4$结束之前：撤销地址

2. 同步通信输出

   ![image-20220627210825638](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%E8%BE%93%E5%87%BA.png)

   + 假设一次数据传输使用了四个时钟周期
   + $T_1$的上升沿之前：主设备发出地址信号并持续
   + $T_1$的下降沿之前：给出数据到数据线上
   + $T_2$的上升沿之前：给出写命令
   + $T_4$的上升沿之前：撤销数据、撤销写命令
   + $T_4$结束之前：撤销地址

同步通讯特点：需要选择最慢的设备（模块）作为统一通讯的时标，所以通常应用于总线长度短（长度越长频率越低）且各个模块存取时间较为一致。

#### 异步通讯

异步通讯中根据应答信号是否互锁，即请求和回答信号的建立和撤消是否互相依赖，异步通讯可分为三种类型：非**互锁通讯、半互锁通讯和全互锁通讯**。

![异步通讯](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%BC%82%E6%AD%A5%E9%80%9A%E8%AE%AF.png)

+ 锁：可以简单理解为状态锁，即保持发送请求这个状态。
+ 不互锁：主设备发出请求信号，经过一段时间（主设备觉得从设备差不多收到）后，就撤销请求信号。从设备同理，接收到请求信号后，经过一段时间，撤销响应信号。**即主设备主观、从设备主观**
+ 半互锁：主设备发出请求信号，直到从设备发出应答信号后才能撤销。而从设备无需等待主设备发出撤销信号，经过一段时间后，撤销响应信号。**即主设备客观、从设备主观**
+ 全互锁：主设备发出请求信号，直到从设备发出应答信号后才能撤销。从设备发出响应信号，知道主设备发出撤销信号后才能撤销响应信号。**即主设备客观、从设备客观**
+ 显然互锁方式不同，传输的速率和可靠程度亦不同

#### 半同步通信

同步特点：发送方用系统时钟前沿**发信号**，接收方用系统时钟后沿**判断、识别**

异步特点：允许不同速度的模块一同工作，增加了一条“等待”响应信号$\overline {WAIT}$

![半同步通信读取](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8D%8A%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.png)

+ $T_1$的上升沿之前：主设备发出地址信号并持续
+ $T_2$的上升沿之前：给出读命令
+ $T_3$的上升沿之前：如果从设备无法准备好数据，则给出$\overline {WAIT}$告知 CPU 进行等待，CPU会插入$T_w$时钟周期。直到某次检测$WAIT$信号为1，则进入$T_3$
+ $T_4$的上升沿之前：撤销读命令、撤销数据
+ $T_4$的上升沿之前：撤销地址

#### 分离式通信

上述三种通信控制方式，准备数据的时候总线都没有被占用，这就造成了浪费。于是乎，我们将一个完整的总线传输周期分为两个小周期，**放弃等待数据这段时间的总线占用**。那么这么判断何时从设备准备好数据了呢？所以在分离式通信中，**每个设备都能作为主设备发出请求信号**，这样从设备就能正常地提供数据以继续流程。

1. 主设备 发出地址和命令占用总线，使用完后主设备放弃总线，从设备进行准备。

2. 如果 从设备 准备好数据，**从设备会化身为主设备**向总线发出请求

   

## 存储器 

### 存储器分类

#### 按存储介质分类

1. 半导体存储器（易丢失）：TTL（集成度低，功耗高），MOS（集成度高，功耗低）
2. 磁表面存储器：磁头(读/写)、载磁体(存储)
3. 磁芯存储器：硬磁材料，环状元件
4. 光盘存储器：激光(读/写)，磁光材料(存储)

#### 按存取方式分类

1. 存取时间与物理地址无关 (随机访问)

   - 随机存储器（**在程序执行过程中**可读可写）

   - 只读存储器（**在程序执行过程中**只读）

2. 存取时间与物理地址有关(串行访问)

   - 顺序存取存储器，如磁带

   - 直接存取存储器，如磁盘

#### 按在计算机中的作用分类

![按在计算机中的作用分类](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%8C%89%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%88%86%E7%B1%BB.png)

+ Cache：高速缓冲存储器，位于CPU和主存之间，用于缓存主存的数据。本质上是一块集成到CPU的SRAM。

+ RAM：

  - 静态RAM(SRAM)

  - 动态RAM(DRAM)

+ ROM：

  - MROM(掩膜ROM)

  - PROM(可编程ROM)

  - EPROM(电可编程ROM)

  - EEPROM(电可编程可擦除ROM)

+ Flash Memory（闪存）：可用于固态硬盘

### 存储器的层次结构

![image-20220628201956665](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AD%98%E5%82%A8%E5%99%A8%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE.png)

+ 速度：从快到慢
+ 容量：从小到大
+ 价格：从高到低
+ 寄存器：集成在CPU当中，I/O端口中也存在。
  + 从体系结构的角度，供给给机器语言程序员使用的称为体系结构寄存器。
+ 缓存：一部分集成在CPU当中。如果CPU需要读取或写入数据，缓存的速度更快

![缓存 主存层次和主存 辅存层次](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%BC%93%E5%AD%98%20%E4%B8%BB%E5%AD%98%E5%B1%82%E6%AC%A1%E5%92%8C%E4%B8%BB%E5%AD%98%20%E8%BE%85%E5%AD%98%E5%B1%82%E6%AC%A1.png)

+ 缓存到辅存的管理由CPU提供的硬件来完成，通常软件开发者不需要了解其中的细节。
+ 主存到辅存的管理由CPU提供的**MMU**以及操作系统提供的**内存管理模块**共同完成，不仅可以为每个进程提供**独立的地址空间**，还可以借助辅存让那些比主存容量还要大的程序得以运行。

### 主存储器

#### 概述

1. 主存的基本结构

  ![主存的基本结构](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%BB%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png)

  + MAR：记录了我们要访问的存储单元地址
  + MDR：记录了我们要读出或者写入的数据
  +  具体的读还是写，则是由控制电路控制读写电路实现

2. 主存和CPU联系

  ![主存和CPU联系](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%BB%E5%AD%98%E5%92%8CCPU%E8%81%94%E7%B3%BB.png)

  + MDR和MAR都是集成在CPU上的，但属于主存
  + 数据总线完成CPU和主存的信息传输
  + 地址总线是单向的，CPU给定要访问的内存单元地址
  + 控制信号：读取或者写入

3. 主存中存储单元地址的分配

   假设当前使用的存储器字长为32位，要存储的数为12345678H。首先根据8位一个字节，每个字节都要有一个**字地址**，那么一个存储单元就可以分为4个字节。**字地址的选择是当前字节的第一个地址**，所以根据数据的存放顺序，可以分为两种方式。

   ![大端和小端方式](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D.png)

   + 如图，每一个格子都有八位（存储两个16进制数），一行就是一个存储单元（字长为32）
   + 字地址从0开始编号
   + **主存的寻址方式**：按字节寻址（每个地址对应一个字节）和按字寻址（每个地址对应一个字）

4. 主存的技术指标

   - 存储容量：存放二进制数据的总位数或总字节数

   - 存储速度：
     - 存取时间：存储器的访问(读/写)时间，即给出地址信号到访问完成所需的时间
     - 存取周期：**连续**两次**独立**的存储器访问操作所需的**最小**时间间隔，通常**大于**存取时间
   - 存储器的带宽：单位时间内写入的位数

#### 半导体芯片简述

1. 半导体芯片的存储结构

   ![半导体芯片的存储结构](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8D%8A%E5%AF%BC%E4%BD%93%E8%8A%AF%E7%89%87%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png)

   + 地址线：单向，由CPU或I/O设备
   + 数据线：双向，读取向外，写入向内
   + **芯片容量**：假设地址线有$n$条，数据线有$m$条。则芯片容量为$m*2^n$位，通常将$2^n$表示为$K$的形式，即$2^{10}$为$1K$。然后写为 $\alpha K \times m$位 ，其中$\alpha$为系数
   + 片选线：传输片选信号，用来选中具体的芯片（存储器可能由多个存储芯片构成）。表示为$\overline{CS},\overline{CE}$
   + 读写控制线：$\overline {WE}$（低电平写，高电平读），或者用两根线表示：$\overline{OE},\overline{WE}$

2. 半导体存储芯片扩展

   ![存储芯片扩展](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E6%89%A9%E5%B1%95.png)

   首先是位扩展：将8片一位的并为一组，则得到$16K \times 8$位存储器

   然后是字扩展：复制为4组即可得到$64K \times 8$位存储器

   所以一共使用了32片存储芯片，即其存储容量的倍数关系

3. 半导体芯片的译码驱动方式

   线选法

   ![线选法](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%BA%BF%E9%80%89%E6%B3%95.png)

   线选法主要是通过地址译码器，走指定字线到目标的存储单元。并且根据读写控制电路选择数据的流通方向。显然这样做系统的结构非常清晰，但是内部字线的数量会随着地址增加而变得非常臃肿。

   重合法

   ![重合法](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%87%8D%E5%90%88%E6%B3%95.png)

   重合法将所有的存储单元形成一个矩阵布局。通过行（X地址）列（Y地址）分别进行译码操作。

#### 随机存取存储器（RAM）

1. 静态RAM（SRAM）

   SRAM使用**触发器**来保存0和1这两个状态。具体的电路实现就省略了。下面开始举例：

   ![Intel 2114](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/Intel%202114.png)

   + $\overline {WE}$：读写控制
   + $\overline {CS}$：片选信号，只有当其为低电平时，该芯片被选中
   + $A$：地址线，一共有10条，说明是地址位为$1K$
   + $I/O$：数据线，一共有4条，说明数据位为4

   下面举个例子，将2114拼成一个64X64的存储阵列，通过重合法，一次**读取同一行的四列数据**

   ![64X64 2114](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/64X64%202114.png)

   + 不难发现，行地址全部正常编号。列地址只使用了4位，即编号16个地址。那么将列数64与16相除，得到四组。这样一来每次就能实现选取同一行的四列数据

2. 动态RAM（DRAM）

   DRAM使**用电容存储电荷的方式来存储1，0**。读数据时，当电容是高电平的时候为1，低电平的时候为0。写数据时，写1就是为电容充电，写0则是电容放电。由于电容会通过电路漏电，时间一久电荷就会流失，导致信息丢失，因此需要周期性的刷新电容(为电容充电)。其具体电路实现分为**单管**和**三管**

   ![Intel1103-DRAM三管读取数据](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220629125609.png)

   + 由图易得，是$1K \times 1$位的存储器。通过重合法进行译码
   + 首先是行地址，注意这里除了5位行地址，还包括一位读取信号。列地址同理
   + 得到数据后，通过读写控制电路向外界传输

3. 动态RAM的刷新

   回想动态RAM的操作过程，首先是行地址取出一整行的数据到某条选择线上。这时我们在选择线上加装一个刷新放大器，即可保存原本的数值。所以，**刷新只与行地址有关，每次刷新一行**

   1. 集中刷新：存在死区
   2. 分散刷新：无死区，但读写周期加长，性能变差
   3. 异步刷新：存在小死区，但是如果安排得当。比如放置在CPU进行指令译码时，则无死区。

4. 动态RAM和静态RAM比较

   1. 存储原理：输出DRAM使用电容存储数据；SRAM使用触发器存储数据
   2. 集成度：DRAM的基本单元电路结构更简单，方便大规模集成，因此DRAM集成度更高
   3. 引脚数量：DRAM通常将行列地址复用引脚，因此引脚数量少(进而芯片封装的体积较小)；而SRAM出于速度的考虑，一般不会这样做
   4. 功耗：DRAM的功耗主要消耗在电容充放电，功耗较小；SRAM的使用触发器存放数据，而构成触发器的管子有部分是一直导通的，也就一直消耗功率，因此功耗较大
   5. 价格：同样存储一个bit，DRAM的单元电路简单，价格低；SRAM的单元电路复杂，用的管子多，因此价格高
   6. 速度：访问DRAM伴随着电容的充放电，因此速度较慢；而SRAM采用chu'fa，访问速度快
   7. 刷新：DRAM需要周期性的刷新其中的电容，才能保持数据；SRAM则没有这个需要。

#### 只读存储器（ROM）

**ROM的发展历程**

1. 早期的ROM在出厂时就会被厂家烧写好内容，且不支持用户再次对ROM进行编程
2. 用户可以使用专门的擦写设备对芯片进行一次擦写，**仅可擦写一次**
3. 用户可以使用专门的擦写设备对芯片进行多次擦写，比如用紫外线擦写的EPROM，这时候擦写还比较麻烦
4. EEPROM的出现使得用户可以多次擦写ROM，且无需使用专门的擦写设备

**几种ROM的简介**

+ MROM（掩模式只读存储器）：**行列选择线交叉处有MOS管则表示1，无MOS管则表示0。**因为有无MOS管在芯片生产出来后就决定了，因此不可编程。
+ PROM（可编程只读存储器）：通常实现为在行列选择线之间**添加一根熔丝**，编程时需要写0则加大电流让熔丝熔断，否则熔丝连通表示1。由于熔丝熔断后不可在连接，因此**只可进行一次编程**。
+ EPROM（可擦除可编程式只读存储器）：EPROM可通过对芯片中的**N型沟道浮动栅MOS管**的D端加电压，形成浮动栅，进而电路不导通表示0，反之表示1。浮动栅可由**紫外线照射后消除**，因此可以利用紫外线实现芯片的全部擦写，从而实现芯片的多次编程。
+ EEPROM（电子式可擦除可编程只读存储器）：EEPROM改进了芯片的擦写功能，实现了电可擦写，且既可局部擦写也可全局擦写。
+ Flash Memory（闪存）：，较EEPROM成本更低，单元电路更为简单，集成度高，访问速度也更快。不过寿命不如EEPROM，因此闪存通常用于保存大量数据，而EEPROM则用于存放不需要经常改变的一些系统参数(数据量少)。只有少数支持片上执行(XIP)的闪存(如NorFlash)才可以作为主存储器，存放程序(不可以随机写，因此无法存放程序运行时加工的数据)。而大部分闪存一般用作辅存。

#### 存储器的扩展

1. 位扩展：电路连接时，两块或多块芯片共用地址线，数据线则分别与CPU的不同数据线连接，片选和读写控制连接在一起，实现同时读，同时写。

   ![2片1Kx4组成1Kx8](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%BD%8D%E6%89%A9%E5%B1%95.png)

   

2. 字扩展：电路连接时，共用低位的地址线，片选信号则通过译码器连接CPU地址线的高位，芯片数量少时，也可以不用译码器，直接使用非门

   ![2片1Kx8组成2Kx8](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AD%97%E6%89%A9%E5%B1%95.png)

3. 字、位扩展：先按位扩展将多个芯片组成一个位数更多的芯片组，各组之间再按照字扩展的连接方式与CPU连接

![8片1Kx4组成4Kx8](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/8%E7%89%871Kx4%E7%BB%84%E6%88%904Kx8.png)

#### 存储器与CPU的连接

1. 地址线的连接
2. 数据线的连接
3. 读/写命令线的连接
4. 片选线的连接
5. 合理选择存储芯片：系统配置和系统程序使用ROM，用户程序选择RAM。
6. 其他 时序、负载

#### 对存储器进行校验

复杂的电磁环境下，工作中的存储器受到干扰，可能导致其内部存储的1、0发生翻转，即1变成0、0变成1，这样存储的信息就出错了。如果我们无法得知这一情况，而在程序中使用了错误的数据，那么就可能造成损失。

一个编码集合中，任意两个合法编码之间**二进制位数**的**最少差异**称为**编码的最小距离**，编码的纠错和检错能力与其最小距离有关。具体关系如下：
$$
L - 1 = D + C (D >= C)
$$

+ L：编码的最小距离
+ D：能够检错的位数
+ C：能够纠错的位数

常用的检验方法有奇偶校验，海明码，CRC循环校验

**奇偶校验**

奇校验：使待校验bit串和校验位共有**奇数**个1

偶校验：使待校验bit串和校验位共有**偶数**个1

**海明码**（汉明码）

是一种多重分组奇偶校验。将数据组织为$k$个分组，每组进行奇偶校验。不仅能检验是否出错，也能定位错误，但定位代价较大，假设有$n$位有效码，设置了$k$位校验码，则$n$与$k$关系为
$$
2^k≥n + k + 1
$$
+ 假设有$k$个校验位，一位有0或1两种情况，$k$位就有$2^k$种排列情况，能表示$2^k$种状态。其中一个状态用来表示正确（没有错误发生）的这种情况。其余的$2^k-1$种状态来表示错误发生在哪一位。总共有$n+k$位，所以$2^k-1$要大等于$n+k$。

+ 海明码的校验码总是放在$2^i,i=0,1,2,3...$

+ 把海明码（有效码和校验码的结合）从左到右，从**1**开始编号$C_1C_2n_3C_4n_5n_6n_7C_8...$

+ 各检验码负责的部分：$C_i$负责检验第$i$位为1的编号

+ 校验码的数值 = 它所负责的有效码的异或（偶校验规则下）或者凑偶数个1
+ 海明码的纠错过程：
  1. 接收方先根据数据长度确定$k$
  2. 增设检验位$P_i$，比如假设此时$k=3$，则新的检验码为$P_4P_2P_1$
  3. 根据检验码的规则计算$P_i$，比如偶规则下，$P_1 = 1\oplus 3 \oplus 5\oplus7$
  4. 得到二进制表示的检验码$P$，换算成10进制即可得到哪一位出错了。如果是全0则表示无错误
+ 海明距离：是字符串相对于同样长度的零字符串的汉明距离，也就是说，它是字符串中非零的元素个数：对于二进制字符串来说，就是1的个数，所以11101的汉明重量是4。

#### 提高访存速度的措施

>1. 采用高速组件
>2. 采用层次结构 Cache-主存
>3. 调整主存结构

下面介绍通过调整主存结构的方式：

1. 单体多字系统

   将存储器的和CPU的存储控制器的位宽设置为CPU字长(寄存器宽度)的整数倍，一次性可以读出多条指令或数据，缺点是写的时候，如果仅写一个字的内容比较麻烦，需要相应的硬件配合。

2. 多体并行系统
   主要思想是采用多个存储器并行工作，CPU访问第一个存储器后，在读到数据前，无需等待，直接访问下一个存储器。这样一轮下来，第一个存储器已经准备好了数据，并能够接收下一次访问(存取周期已到)，于是再来一轮。如此，CPU和存储器都不会空闲。


## 输入输出系统

## 计算机的运算方法

## 指令系统

## CPU的结构和功能

## 控制单元的功能

## 控制单元的设计

