# 计算机组成原理

主要参考：

[计算机组成原理（哈工大刘宏伟）](http://www.feemic.cn/mooc/icourse163/1205914219)

唐朔飞 《计算机组成原理》（第二版）

[冉冉云 计算机体系结构](https://blog.csdn.net/gzxb1995/category_9814748.html)

## 计算机系统概论

### 计算机系统简介

#### 计算机软硬件概念

计算机系统

1. 硬件：计算机的实体：如主机、外设
2. 软件：具有各类特殊功能的信息（程序）组成
   1. 系统软件：用来管理整个计算机系统
      1. 语言处理程序（编译、链接）
      2. 操作系统
      3. 服务性程序
      4. 数据库管理系统
      5. 网络软件
   2. 应用软件：按任务需要编写的程序

#### 计算机系统的层次结构

1. 物理结构抽象

   ![image-20220625092855877](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625092903.png)

   自底向上地来看：

   1. Physics 物理抽象，电子设备依靠电子的移动进行工作。可以使用 量子 机制，和麦克斯韦方程进行描述。
   2. Devices 电子元件，利用电子在不同物质中的移动特征来构建不同的电子元件，其具有不同的电压电流特征用以描述。
   3. Analog Circuits 模拟电路，利用基本的电子元件构建放大器，滤波器等部件。
   4. Digital Circuits 数字电路，利用模拟电路层进一步构建与非门等。
   5. Logic 逻辑层，利用数字电路进行加法器和存储器的实现。
   6. Microarchitecture 微体系(架构)结构层，具有执行单元和控制单元

2. 程序员角度

   ![image-20220625094958199](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625094958.png)

### 计算机的基本组成

#### 冯·诺依曼计算机的特点

1. 计算机由五大部件（运算器、控制器、存储器、输入设备和输出设备）组成
2. 指令和数据以同等地位**存于存储器**，可按地址寻访
3. 指令和数据用二进制表示
4. 指令由操作码和地址码组成
5. 存储程序（核心特征）
6. 以运算器为中心

#### 冯·诺依曼计算机的硬件图

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625101051.png" alt="image-20220625101051177" style="zoom:80%;" />

+ 实线表示数据通路
+ 虚线表示控制和状态反馈
+ 运算器：核心，算术运算与逻辑运算
+ 存储器：存放数据和程序
+ 控制器：指挥控制程序的运行
+ 输入设备：将信息转化为机器能识别的形式
+ 输出设备：将结果转化为人能识别的形式

#### 冯·诺依曼计算机的结构改进

以存储器为中心的计算机硬件框图

![image-20220625101628906](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625101628.png)

其中，运算器（ALU）和控制器（CU）可以组成 CPU 。存储器可以进一步分为主存和辅存。主存和CPU可以进一步构成主机。输入设备和输出设备统称为I/O设备，主机和I/O设备统称为硬件。则给出

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625103446.png" alt="image-20220625103446906" style="zoom:80%;" />

#### 系统复杂性管理的方法

1. 层次化（Hierachy）：将被设计的系统划分为多个模块或子模块
2. 模块化（Modularity）：有明确定义（well-defined）的功能和接口
3. 规则性（regularity）：模块符合某些通用标准，使其更容易被重用

#### 计算机的工作步骤

1. 建立数学模型
2. 确定计算方法
3. 编写解题程序

给例子：计算$a x^{2}+b x+c=(a x+b) x+c$

1. 从问题来看需要**加法指令**和**乘法指令**

2. 还需要取出数字并放置到累加器中的**取数指令**，和读取结果并放置到存储器中的**读取指令**

3. 最后是显示或者打印的**打印指令**，以及停机指令

4. 计算

   	取 x 至运算器中
   	乘以 a 在运算器中
   	加 b 在运算器中
   	乘以 x 在运算器中
   	加 c 在运算器中

#### 指令格式

都使用16位长度的指令由6位操作码和8位地址码构成，[] 表示在寄存器中保存的内容

1. 取数指令

   取数 a，[a] –> ACC

   000001 0000001000，前六位表示取数指令，后十位表示地址8

2. 存数指令

   存数 b，[ACC] –> b

3. 加法指令

   加数 c，[ACC] + [c] –> [ACC]

4. 乘法指令

   乘数 d，[ACC] * [d] –> [ACC]

5. 打印指令

   $\sigma$ ，[$\sigma$] –> 打印机

6. 停机指令

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625110202.png" alt="image-20220625110202631" style="zoom:67%;" />



#### 存储器的基本组成

上面我们知道，**指令**和**数据**都保存在存储器当中。**存储器**的主要部分是**存储体，MAR，MDR**

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625161002.png" alt="image-20220625161002215" style="zoom:67%;" />

+ **存储体**又有若干**存储单元**构成，**存储单元**又由若干**存储元件**（0/1）构成。 

+ 存储单元：存放一串二进制代码，即**存储字**
+ 存储字长：存储字的长度（位数）
+ 存储单元**按照地址寻址**
+ MAR：存储器**地址寄存器**，**保存了存储单元的地址**，MAR的位数反映了存储单元的个数。**即存储单元个数是$2^{n_{MAR}}$**。
+ MDR：存储器**数据寄存器**，MDR的位数表示该存储器的**存储字长**，即**存储字长是**$n_{MDR}$
+ MAR 就像存储器的入口，其接受某个地址作为寻找请求。存储器找到后将其地址中的**内容**交给存储器出口MDR

#### 运算器的基本组成



![image-20220625162012087](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625162012.png)

ALU：Arithmetic Logic Unit，**算术逻辑运算单元**，运算器中完成算术逻辑运算的逻辑部件

ACC：Accumulator，**累加器**，运算器中运算前存放操作数、运算后存放运算结果的寄存器

MQ：Multiplier-Quotient Register，**乘商寄存器**，乘法运算时存放乘数、除法时存放商的寄存器

X：此字母没有专指的缩写含义，可以用作任一部件名，在此表示操作数寄存器，即运算器中工作寄存器之一，用来**存放操作数**

例：加法操作过程，设加法指令操作码为000001，加数的地址为M

1. 初态：ACC中已经存放好了被加数
2. [M] –> X
3. [ACC] + [X] –> ACC

例2：减法操作过程，设减法指令操作码为000010，减数的地址为M

	1. 初态：ACC中已经存放好了被减数
	1. [M] –> X
	1. [ACC] - [X] –> ACC

例3：乘法操作过程，设乘法指令操作码为000011，乘数的地址为M

1. 初态：ACC中已经存放好了被乘数
2. [M] –> MQ
3. [ACC] –> X
4. 0 –> ACC
5. [ACC] \* [X] –> ACC//MQ

例4：除法操作过程，设触发指令操作码为000111，除数的地址为M

1. 初态：ACC中已经存放好了被除数
2. [M] –> X
3. [ACC] / [X] –> MQ，余数在ACC中

#### 控制器的基本组成

控制器由PC、IR与CU组成

控制器用以解释指令并保证指令按照正确的次序执行，下面来看完成一条指令需要三个大步骤：

1. 取指令，**PC（程序计数器）**存放当前欲执行指令的地址， 具有计数功能：（PC）+ 1 –> PC
2. 分析指令，**IR（指令寄存器）**存放当前欲执行的指令
3. 执行指令，**CU**

例：完成一条**取数指令**的过程

![image-20220625165601107](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220625165601.png)

1. 取指令
   1. PC 把指令的地址给MAR 
   2. MAR 在控制器的控制之下，根据地址寻找指定的存储单元
   3. 存储体把指定的存储单元中的指令取出送入 MDR
   4. MDR 取出的指令送入 IR
2. 分析指令
   1. IR 中的操作码部分送给 CU，由 CU 根据指令开始执行操作
3. 执行指令
   1. IR 中的地址码部分送给 MAR
   2. MAR 在控制器的控制之下，根据地址寻找指定的存储单元
   3. 存储体把指定的存储单元中的数据取出送入 MDR
   4. MDR 取出的数据送入ACC，取数完毕

#### 总结

1. 将程序通过输入设备送至计算机
2. 程序首地址 –> PC
3. 启动程序运行
4. 取指令PC→MAR→M→MDR→IR，(PC)+1→PC
5. 分析指令OP(IR)→CU
6. 执行指令AD(IR)→MAR→M→MDR→ACC
7. ……
8. 打印结果
9. 停机

## 系统总线

### 总线的基本概念

> **总线**（Bus）是指计算机组件间规范化的交换数据的方式，即以一种通用的方式为各组件提供数据传送和控制逻辑。从另一个角度来看，如果说[主板](https://zh.wikipedia.org/wiki/主機板)（Mother Board）是一座城市，那么总线就像是城市里的公共汽车（bus），能按照固定行车路线，传输来回不停运作的[比特](https://zh.wikipedia.org/wiki/位元)（bit）。这些线路在同一时间内都仅能负责传输一个比特。因此，必须同时采用多条线路才能发送更多资料，而总线可同时传输的资料数就称为宽度（width），以比特为单位，总线宽度愈大，传输性能就愈佳。总线的[带宽](https://zh.wikipedia.org/wiki/頻寬)（即单位时间内可以传输的总资料数）为：总线带宽 = 频率×宽度（Bytes/sec）

#### 为什么使用总线

| 连接方式     | 硬件资源             | 可扩展性                                         |
| ------------ | -------------------- | ------------------------------------------------ |
| 两两单独连接 | 占用引脚多，连线复杂 | 需要现有设备提供与新设备之间的接口，扩展起来麻烦 |
| 总线式连接   | 占用引脚少，连线简单 | 只需将新设备挂到总线，扩展方便                   |

![为什么要使用总线](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BA%BF.png)

#### 总线上信息的传输

首先，**在任意时刻一条总线只能有一对部件进行信息传输**

总线信息传输方式可以分为**串行传输**和**并行传输**，字面意思来看，串行就是数据是一位一位的发送**，**并行就是数据一组一组的发送。以直觉来看，并行应该是比串行传输速率高的，但事实上现在大部分的芯片都选择串行传输

>**并行总线由于是多个数据同时传输，需要考虑数据的协同性，这就导致了并行传输的频率不能做的很高**。相对的，串行总线只有一条链路，就可以把频率做的很高，提高传输速度，速度提高了就能够弥补一次只能传输一个数据的缺陷。
>
>此外，**并行总线两根相邻的链路其数据是同时传输的**，这就会导致它们彼此之间会产生**严重干扰**，并行的链路越多，干扰越强。因此并行总线需要加强抗干扰的能力，否则传输过程中数据就可能被损坏。如果传输过程中数据故障了，就需要重新对齐数据再传输。而串行总线如果一个数据出错了，只需要重新传输一次就好了，由于串行总线频率高，很快就可以把错误数据重新传输过去。
>
>再次，由于**并行总线是多链路一块传输数据**，就需要很多线，接口需要很多针脚，老式计算机里的并行接口做得很大，接线比较宽，针脚非常多。这样一来装机也很麻烦，因为走线不方便、接口体积很大。

### 总线的分类

#### 根据总线位置进行分类

1. 片内总线：芯片内部的总线
2. 系统总线：计算机各部件的信息传输
   1. 数据总线：双向，与机器字长、存储字长相关
   2. 地址总线：单向，与存储地址、I/O地址相关
   3. 控制总线：
      + 有出：中断请求、总线请求
      + 存储器读、存储器写、总线使用权许可、中断确认
3. 通信总线：用于 计算机系统之间 或 计算机系统 与 其他系统。
   1. 串行传输
   2. 并行传输

### 总线特性及性能指标

#### 总线特性

| 特性分类 | 含义                                 |
| -------- | ------------------------------------ |
| 机械特性 | 尺寸、形状、引脚数、引脚的排列顺序等 |
| 电气特性 | 传输方向、有效电平范围等             |
| 功能特性 | 每根线的功能，如地址、数据、控制等   |
| 时间特性 | 时钟频率、信号的时序关系等           |

#### 性能指标

1. 总线宽度：数据线的根数，根数越多，同时传输的位数就越多
2. 标准传输率：每秒传输的最大字节数（MBps）
3. 时钟类型：同步、不同步
4. 总线复用：地址线和数据线**复用**，以减少芯片的管脚数
5. 信号线数：地址线、数据线和控制线的总和
6. 总线控制方式：突发、自动、仲裁、逻辑、计数
7. 其他指标：负载能力

#### 总线标准

![image-20220627192109975](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%80%BB%E7%BA%BF%E6%A0%87%E5%87%86.png)

顺便一提，现代总线比如雷电4标准已经到 40 Gbps，所以总线标准也是计算机的性能瓶颈之一。

### 总线结构

#### 单总线结构

![单总线结构](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png)

+ 存在主线争用问题
+ 时间延迟高

#### 多总线结构

1. 面向CPU的双总线结构

   ![面向CPU的双总线结构](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220627185027109.png)

   + 考虑到**指令**和**数据**都来自主存，所以用单独的M总线保证其交换速度
   + 假设主存要与I/O设备信息传输，就不得不经过CPU，会打乱CPU的信息交换任务

2. 面向存储器的双总线结构

   ![面向存储器的双总线结构](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%9D%A2%E5%90%91%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%8F%8C%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png)

   + 从主存发出两条总线：存储总线和系统总线
   + CPU和主存也保留了专用总线
   + CPU也可以直接与I/O设备交互
   + 目前还不能做到主存同时使用两根总线

3. 使用通道

   ![通道双主线](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%80%9A%E9%81%93%E5%8F%8C%E4%B8%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png)

   + 一般来说通道有自己的控制器，指令等

4. 三总线结构

   ![三总线结构](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png)

   + 在面向CPU的双总线结构上，将I/O设备分为高速和低速
   + 将高速设备通过新的DMA总线与内存进行直接地信息交换

5. 三总线结构-2

   ![三总线结构2](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%842)

   + 由于内存的进步较于CPU缓慢，容易成为计算机的瓶颈点。所以使用Cache对内存中常用的指令预先读取，然后单独与CPU连接一条局部总线
   + 系统总线通过一个扩展总线接口连接扩展总线，但这样会影响外部设备的传输速率

6. 四总线结构

   ![四总线结构](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%9B%9B%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png)

   + 在三总线-2的基础上将外设分为高速和低速

### 总线控制

总线控制主要解决两个问题：多设备同时申请使用总线的判定（总线判优控制/仲裁）和设备占用总线中保证通讯的正确性（总线通信控制）

#### 总线判优控制

根据组件在总线中的功能可以分为总设备（模块）和从设备（模块）

主设备：对总线有控制权，可以发出占用总线的申请

从设备：没有控制权，只能响应主设备发出的申请

集中式仲裁：把总线的判优逻辑放在一个部件中，根据查询方式不同，又可以分为：**链式查询、计数器定时查询和独立请求方式**

分布式仲裁：总线的仲裁逻辑分散在与总线连接的各主设备上。典型的例子有**以太网**，以太网上接入的各台计算机都可以发起通信，为避免无序竞争，它们都需要遵循以太网的仲裁逻辑，即**载波侦听/冲突检测**。

#### 链式查询

![链式查询](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%93%BE%E5%BC%8F%E6%9F%A5%E8%AF%A2.png)

+ 地址线：从设备查找
+ 数据线：数据传输
+ BR 总线：各接口向总线控制部件提出占用请求
+ BG 总线：总线控制部件**链式地**查询哪个I/O接口提出了占用请求（碰到就停止查询）
+ BS 总线：获得总线使用权的接口利用 BR 总线向总线控制部件，发送一个总线忙碌状态以应答

+ 链式查询的顺序就是设备的优先级顺序
+ 优点：结构简单，算法简单，增删设备容易
+ 缺点：BG 对电路故障特别敏感，速度较慢

#### 计数器定时查询

![计时器定时查询](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E8%AE%A1%E6%97%B6%E5%99%A8%E5%AE%9A%E6%97%B6%E6%9F%A5%E8%AF%A2.png)

+ 设备地址线：由总线控制部件的**计数器**发出信号，通过这个地址来查找某个设备是否发出总线请求
+ 计数器：各接口向总线控制部件通过 BR 提出占用请求。控制器接受到请求并成功通过后就会启动计数器（初值为0或者某个地址），计数器的值通过设备地址线向外输出，查询接口为初值的I/O接口。如果没有提出，则计数器++后重复查询，直到找到提出的I/O接口，并用 BR 进行应答。
+ 优点：优先级是优先级较为灵活，比如通过软件的方式设定初值，那么优先级也就随之改变了

#### 	独立请求方式

![独立请求方式](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%8B%AC%E7%AB%8B%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F.png)

+ 任何一个I/O接口都增加了两条线 BR BG
+ 排队器：通过软件的方式在总线控制部件中动态地调整优先级
+ 缺点：连接复杂

#### 总线通信控制

总线传输周期：完成一次传输需要的时间

- 申请分配：判优问题
- 寻址阶段：主设备向从设备给出地址和命令
- 传输阶段：主设备和从设备交换数据
- 结束阶段：主设备撤销相关信息

方式：

| 通信方式   | 特点                                                         |
| ---------- | ------------------------------------------------------------ |
| 同步通信   | 统一定宽定距的时标控制数据传输                               |
| 异步通信   | 无统一时标，采用应答方式。主设备发出请求（命令），从设备应答，进而完成数据交换 |
| 半同步通信 | 引入等待信号，解决不同速度的两个设备之间的通讯，同步异步结合 |
| 分离式通信 | 不在等待时占据总线，提高总线通信的效率                       |

#### 同步通信

1. 同步通信输入

  ![同步通信](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1.png)

  + 假设一次数据传输使用了四个时钟周期
  + $T_1$的上升沿之前：主设备发出地址信号并持续
  + $T_2$的上升沿之前：给出读命令
  + $T_3$的上升沿之前：从设备需要将需要数据发送到数据线上
  + $T_4$的上升沿之前：撤销数据、撤销读命令
  + $T_4$结束之前：撤销地址

2. 同步通信输出

   ![image-20220627210825638](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%E8%BE%93%E5%87%BA.png)

   + 假设一次数据传输使用了四个时钟周期
   + $T_1$的上升沿之前：主设备发出地址信号并持续
   + $T_1$的下降沿之前：给出数据到数据线上
   + $T_2$的上升沿之前：给出写命令
   + $T_4$的上升沿之前：撤销数据、撤销写命令
   + $T_4$结束之前：撤销地址

同步通讯特点：需要选择最慢的设备（模块）作为统一通讯的时标，所以通常应用于总线长度短（长度越长频率越低）且各个模块存取时间较为一致。

#### 异步通讯

异步通讯中根据应答信号是否互锁，即请求和回答信号的建立和撤消是否互相依赖，异步通讯可分为三种类型：非**互锁通讯、半互锁通讯和全互锁通讯**。

![异步通讯](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%BC%82%E6%AD%A5%E9%80%9A%E8%AE%AF.png)

+ 锁：可以简单理解为状态锁，即保持发送请求这个状态。
+ 不互锁：主设备发出请求信号，经过一段时间（主设备觉得从设备差不多收到）后，就撤销请求信号。从设备同理，接收到请求信号后，经过一段时间，撤销响应信号。**即主设备主观、从设备主观**
+ 半互锁：主设备发出请求信号，直到从设备发出应答信号后才能撤销。而从设备无需等待主设备发出撤销信号，经过一段时间后，撤销响应信号。**即主设备客观、从设备主观**
+ 全互锁：主设备发出请求信号，直到从设备发出应答信号后才能撤销。从设备发出响应信号，知道主设备发出撤销信号后才能撤销响应信号。**即主设备客观、从设备客观**
+ 显然互锁方式不同，传输的速率和可靠程度亦不同

#### 半同步通信

同步特点：发送方用系统时钟前沿**发信号**，接收方用系统时钟后沿**判断、识别**

异步特点：允许不同速度的模块一同工作，增加了一条“等待”响应信号$\overline {WAIT}$

![半同步通信读取](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8D%8A%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.png)

+ $T_1$的上升沿之前：主设备发出地址信号并持续
+ $T_2$的上升沿之前：给出读命令
+ $T_3$的上升沿之前：如果从设备无法准备好数据，则给出$\overline {WAIT}$告知 CPU 进行等待，CPU会插入$T_w$时钟周期。直到某次检测$WAIT$信号为1，则进入$T_3$
+ $T_4$的上升沿之前：撤销读命令、撤销数据
+ $T_4$的上升沿之前：撤销地址

#### 分离式通信

上述三种通信控制方式，准备数据的时候总线都没有被占用，这就造成了浪费。于是乎，我们将一个完整的总线传输周期分为两个小周期，**放弃等待数据这段时间的总线占用**。那么这么判断何时从设备准备好数据了呢？所以在分离式通信中，**每个设备都能作为主设备发出请求信号**，这样从设备就能正常地提供数据以继续流程。

1. 主设备 发出地址和命令占用总线，使用完后主设备放弃总线，从设备进行准备。

2. 如果 从设备 准备好数据，**从设备会化身为主设备**向总线发出请求

   

## 存储器 

### 存储器分类

#### 按存储介质分类

1. 半导体存储器（易丢失）：TTL（集成度低，功耗高），MOS（集成度高，功耗低）
2. 磁表面存储器：磁头(读/写)、载磁体(存储)
3. 磁芯存储器：硬磁材料，环状元件
4. 光盘存储器：激光(读/写)，磁光材料(存储)

#### 按存取方式分类

1. 存取时间与物理地址无关 (随机访问)

   - 随机存储器（**在程序执行过程中**可读可写）

   - 只读存储器（**在程序执行过程中**只读）

2. 存取时间与物理地址有关(串行访问)

   - 顺序存取存储器，如磁带

   - 直接存取存储器，如磁盘

#### 按在计算机中的作用分类

![按在计算机中的作用分类](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%8C%89%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%88%86%E7%B1%BB.png)

+ Cache：高速缓冲存储器，位于CPU和主存之间，用于缓存主存的数据。本质上是一块集成到CPU的SRAM。

+ RAM：

  - 静态RAM(SRAM)

  - 动态RAM(DRAM)

+ ROM：

  - MROM(掩膜ROM)

  - PROM(可编程ROM)

  - EPROM(电可编程ROM)

  - EEPROM(电可编程可擦除ROM)

+ Flash Memory（闪存）：可用于固态硬盘

### 存储器的层次结构

![image-20220628201956665](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AD%98%E5%82%A8%E5%99%A8%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE.png)

+ 速度：从快到慢
+ 容量：从小到大
+ 价格：从高到低
+ 寄存器：集成在CPU当中，I/O端口中也存在。
  + 从体系结构的角度，供给给机器语言程序员使用的称为体系结构寄存器。
+ 缓存：一部分集成在CPU当中。如果CPU需要读取或写入数据，缓存的速度更快

![缓存 主存层次和主存 辅存层次](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%BC%93%E5%AD%98%20%E4%B8%BB%E5%AD%98%E5%B1%82%E6%AC%A1%E5%92%8C%E4%B8%BB%E5%AD%98%20%E8%BE%85%E5%AD%98%E5%B1%82%E6%AC%A1.png)

+ 缓存到辅存的管理由CPU提供的硬件来完成，通常软件开发者不需要了解其中的细节。
+ 主存到辅存的管理由CPU提供的**MMU**以及操作系统提供的**内存管理模块**共同完成，不仅可以为每个进程提供**独立的地址空间**，还可以借助辅存让那些比主存容量还要大的程序得以运行。

### 主存储器

#### 概述

1. 主存的基本结构

  ![主存的基本结构](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%BB%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png)

  + MAR：记录了我们要访问的存储单元地址
  + MDR：记录了我们要读出或者写入的数据
  + 具体的读还是写，则是由控制电路控制读写电路实现

2. 主存和CPU联系

  ![主存和CPU联系](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%BB%E5%AD%98%E5%92%8CCPU%E8%81%94%E7%B3%BB.png)

  + MDR和MAR都是集成在CPU上的，但属于主存
  + 数据总线完成CPU和主存的信息传输
  + 地址总线是单向的，CPU给定要访问的内存单元地址
  + 控制信号：读取或者写入

3. 主存中存储单元地址的分配

   假设当前使用的存储器字长为32位，要存储的数为12345678H。首先根据8位一个字节，每个字节都要有一个**字地址**，那么一个存储单元就可以分为4个字节。**字地址的选择是当前字节的第一个地址**，所以根据数据的存放顺序，可以分为两种方式。

   ![大端和小端方式](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D.png)

   + 如图，每一个格子都有八位（存储两个16进制数），一行就是一个存储单元（字长为32）
   + 字地址从0开始编号
   + **主存的寻址方式**：按字节寻址（每个地址对应一个字节）和按字寻址（每个地址对应一个字）

4. 主存的技术指标

   - 存储容量：存放二进制数据的总位数或总字节数

   - 存储速度：
     - 存取时间：存储器的访问(读/写)时间，即给出地址信号到访问完成所需的时间
     - 存取周期：**连续**两次**独立**的存储器访问操作所需的**最小**时间间隔，通常**大于**存取时间
   - 存储器的带宽：单位时间内写入的位数

#### 半导体芯片简述

1. 半导体芯片的存储结构

   ![半导体芯片的存储结构](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8D%8A%E5%AF%BC%E4%BD%93%E8%8A%AF%E7%89%87%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png)

   + 地址线：单向，由CPU或I/O设备
   + 数据线：双向，读取向外，写入向内
   + **芯片容量**：假设地址线有$n$条，数据线有$m$条。则芯片容量为$m*2^n$位，通常将$2^n$表示为$K$的形式，即$2^{10}$为$1K$。然后写为 $\alpha K \times m$位 ，其中$\alpha$为系数
   + 片选线：传输片选信号，用来选中具体的芯片（存储器可能由多个存储芯片构成）。表示为$\overline{CS},\overline{CE}$
   + 读写控制线：$\overline {WE}$（低电平写，高电平读），或者用两根线表示：$\overline{OE},\overline{WE}$

2. 半导体存储芯片扩展

   ![存储芯片扩展](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E6%89%A9%E5%B1%95.png)

   首先是位扩展：将8片一位的并为一组，则得到$16K \times 8$位存储器

   然后是字扩展：复制为4组即可得到$64K \times 8$位存储器

   所以一共使用了32片存储芯片，即其存储容量的倍数关系

3. 半导体芯片的译码驱动方式

   线选法

   ![线选法](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%BA%BF%E9%80%89%E6%B3%95.png)

   线选法主要是通过地址译码器，走指定字线到目标的存储单元。并且根据读写控制电路选择数据的流通方向。显然这样做系统的结构非常清晰，但是内部字线的数量会随着地址增加而变得非常臃肿。

   重合法

   ![重合法](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E9%87%8D%E5%90%88%E6%B3%95.png)

   重合法将所有的存储单元形成一个矩阵布局。通过行（X地址）列（Y地址）分别进行译码操作。

#### 随机存取存储器（RAM）

1. 静态RAM（SRAM）

   SRAM使用**触发器**来保存0和1这两个状态。具体的电路实现就省略了。下面开始举例：

   ![Intel 2114](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/Intel%202114.png)

   + $\overline {WE}$：读写控制
   + $\overline {CS}$：片选信号，只有当其为低电平时，该芯片被选中
   + $A$：地址线，一共有10条，说明是地址位为$1K$
   + $I/O$：数据线，一共有4条，说明数据位为4

   下面举个例子，将2114拼成一个64X64的存储阵列，通过重合法，一次**读取同一行的四列数据**

   ![64X64 2114](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/64X64%202114.png)

   + 不难发现，行地址全部正常编号。列地址只使用了4位，即编号16个地址。那么将列数64与16相除，得到四组。这样一来每次就能实现选取同一行的四列数据

2. 动态RAM（DRAM）

   DRAM使**用电容存储电荷的方式来存储1，0**。读数据时，当电容是高电平的时候为1，低电平的时候为0。写数据时，写1就是为电容充电，写0则是电容放电。由于电容会通过电路漏电，时间一久电荷就会流失，导致信息丢失，因此需要周期性的刷新电容(为电容充电)。其具体电路实现分为**单管**和**三管**

   ![Intel1103-DRAM三管读取数据](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/20220629125609.png)

   + 由图易得，是$1K \times 1$位的存储器。通过重合法进行译码
   + 首先是行地址，注意这里除了5位行地址，还包括一位读取信号。列地址同理
   + 得到数据后，通过读写控制电路向外界传输

3. 动态RAM的刷新

   回想动态RAM的操作过程，首先是行地址取出一整行的数据到某条选择线上。这时我们在选择线上加装一个刷新放大器，即可保存原本的数值。所以，**刷新只与行地址有关，每次刷新一行**

   1. 集中刷新：存在死区
   2. 分散刷新：无死区，但读写周期加长，性能变差
   3. 异步刷新：存在小死区，但是如果安排得当。比如放置在CPU进行指令译码时，则无死区。

4. 动态RAM和静态RAM比较

   1. 存储原理：输出DRAM使用电容存储数据；SRAM使用触发器存储数据
   2. 集成度：DRAM的基本单元电路结构更简单，方便大规模集成，因此DRAM集成度更高
   3. 引脚数量：DRAM通常将行列地址复用引脚，因此引脚数量少(进而芯片封装的体积较小)；而SRAM出于速度的考虑，一般不会这样做
   4. 功耗：DRAM的功耗主要消耗在电容充放电，功耗较小；SRAM的使用触发器存放数据，而构成触发器的管子有部分是一直导通的，也就一直消耗功率，因此功耗较大
   5. 价格：同样存储一个bit，DRAM的单元电路简单，价格低；SRAM的单元电路复杂，用的管子多，因此价格高
   6. 速度：访问DRAM伴随着电容的充放电，因此速度较慢；而SRAM采用chu'fa，访问速度快
   7. 刷新：DRAM需要周期性的刷新其中的电容，才能保持数据；SRAM则没有这个需要。

#### 只读存储器（ROM）

**ROM的发展历程**

1. 早期的ROM在出厂时就会被厂家烧写好内容，且不支持用户再次对ROM进行编程
2. 用户可以使用专门的擦写设备对芯片进行一次擦写，**仅可擦写一次**
3. 用户可以使用专门的擦写设备对芯片进行多次擦写，比如用紫外线擦写的EPROM，这时候擦写还比较麻烦
4. EEPROM的出现使得用户可以多次擦写ROM，且无需使用专门的擦写设备

**几种ROM的简介**

+ MROM（掩模式只读存储器）：**行列选择线交叉处有MOS管则表示1，无MOS管则表示0。**因为有无MOS管在芯片生产出来后就决定了，因此不可编程。
+ PROM（可编程只读存储器）：通常实现为在行列选择线之间**添加一根熔丝**，编程时需要写0则加大电流让熔丝熔断，否则熔丝连通表示1。由于熔丝熔断后不可在连接，因此**只可进行一次编程**。
+ EPROM（可擦除可编程式只读存储器）：EPROM可通过对芯片中的**N型沟道浮动栅MOS管**的D端加电压，形成浮动栅，进而电路不导通表示0，反之表示1。浮动栅可由**紫外线照射后消除**，因此可以利用紫外线实现芯片的全部擦写，从而实现芯片的多次编程。
+ EEPROM（电子式可擦除可编程只读存储器）：EEPROM改进了芯片的擦写功能，实现了电可擦写，且既可局部擦写也可全局擦写。
+ Flash Memory（闪存）：，较EEPROM成本更低，单元电路更为简单，集成度高，访问速度也更快。不过寿命不如EEPROM，因此闪存通常用于保存大量数据，而EEPROM则用于存放不需要经常改变的一些系统参数(数据量少)。只有少数支持片上执行(XIP)的闪存(如NorFlash)才可以作为主存储器，存放程序(不可以随机写，因此无法存放程序运行时加工的数据)。而大部分闪存一般用作辅存。

#### 存储器的扩展

1. 位扩展：电路连接时，两块或多块芯片共用地址线，数据线则分别与CPU的不同数据线连接，片选和读写控制连接在一起，实现同时读，同时写。

   ![2片1Kx4组成1Kx8](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%BD%8D%E6%89%A9%E5%B1%95.png)

   

2. 字扩展：电路连接时，共用低位的地址线，片选信号则通过译码器连接CPU地址线的高位，芯片数量少时，也可以不用译码器，直接使用非门

   ![2片1Kx8组成2Kx8](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AD%97%E6%89%A9%E5%B1%95.png)

3. 字、位扩展：先按位扩展将多个芯片组成一个位数更多的芯片组，各组之间再按照字扩展的连接方式与CPU连接

![8片1Kx4组成4Kx8](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/8%E7%89%871Kx4%E7%BB%84%E6%88%904Kx8.png)

#### 存储器与CPU的连接

1. 地址线的连接
2. 数据线的连接
3. 读/写命令线的连接
4. 片选线的连接
5. 合理选择存储芯片：系统配置和系统程序使用ROM，用户程序选择RAM。
6. 其他 时序、负载

#### 对存储器进行校验

复杂的电磁环境下，工作中的存储器受到干扰，可能导致其内部存储的1、0发生翻转，即1变成0、0变成1，这样存储的信息就出错了。如果我们无法得知这一情况，而在程序中使用了错误的数据，那么就可能造成损失。

一个编码集合中，任意两个合法编码之间**二进制位数**的**最少差异**称为**编码的最小距离**，编码的纠错和检错能力与其最小距离有关。具体关系如下：
$$
L - 1 = D + C (D >= C)
$$

+ L：编码的最小距离
+ D：能够检错的位数
+ C：能够纠错的位数

常用的检验方法有奇偶校验，海明码，CRC循环校验

**奇偶校验**

奇校验：使待校验bit串和校验位共有**奇数**个1

偶校验：使待校验bit串和校验位共有**偶数**个1

**海明码**（汉明码）

是一种多重分组奇偶校验。将数据组织为$k$个分组，每组进行奇偶校验。不仅能检验是否出错，也能定位错误，但定位代价较大，假设有$n$位有效码，设置了$k$位校验码，则$n$与$k$关系为
$$
2^k≥n + k + 1
$$

+ 假设有$k$个校验位，一位有0或1两种情况，$k$位就有$2^k$种排列情况，能表示$2^k$种状态。其中一个状态用来表示正确（没有错误发生）的这种情况。其余的$2^k-1$种状态来表示错误发生在哪一位。总共有$n+k$位，所以$2^k-1$要大等于$n+k$。

+ 海明码的校验码总是放在$2^i,i=0,1,2,3...$

+ 把海明码（有效码和校验码的结合）从左到右，从**1**开始编号$C_1C_2n_3C_4n_5n_6n_7C_8...$

+ 各检验码负责的部分：$C_i$负责检验第$i$位为1的编号

+ 校验码的数值 = 它所负责的有效码的异或（偶校验规则下）或者凑偶数个1
+ 海明码的纠错过程：
  1. 接收方先根据数据长度确定$k$
  2. 增设检验位$P_i$，比如假设此时$k=3$，则新的检验码为$P_4P_2P_1$
  3. 根据检验码的规则计算$P_i$，比如偶规则下，$P_1 = 1\oplus 3 \oplus 5\oplus7$
  4. 得到二进制表示的检验码$P$，换算成10进制即可得到哪一位出错了。如果是全0则表示无错误
+ 海明距离：是字符串相对于同样长度的零字符串的汉明距离，也就是说，它是字符串中非零的元素个数：对于二进制字符串来说，就是1的个数，所以11101的汉明重量是4。

#### 提高访存速度的措施

>1. 采用高速组件
>2. 采用层次结构 Cache-主存
>3. 调整主存结构

下面介绍通过调整主存结构的方式：

1. 单体多字系统

   将存储器的和CPU的存储控制器的位宽设置为CPU字长(寄存器宽度)的整数倍，一次性可以读出多条指令或数据，缺点是写的时候，如果仅写一个字的内容比较麻烦，需要相应的硬件配合。

2. 多体并行系统
   主要思想是采用多个存储器并行工作，CPU访问第一个存储器后，在读到数据前，无需等待，直接访问下一个存储器。这样一轮下来，第一个存储器已经准备好了数据，并能够接收下一次访问(存取周期已到)，于是再来一轮。如此，CPU和存储器都不会空闲。


### 高速缓存存储器-Cache

#### 概述

##### 问题的提出

CPU的发展速度非常快，而存储器的速度则会成为瓶颈，则CPU存在**空等**现象。通过在CPU和主存之间增加一个Cache缓存，其由静态RAM组成，和主存相比容量小，速度快。

>Cache之所以行之有效，就不得不提**程序访问的局部性原理**，这个原理的内含分两部分，一是时间的局部性：当前访问到的指令和数据在不久的将来很有可能还会被访问到；二是空间的局部性：当前访问的指令和数据的附近的指令和数据在不久的将来很可能会被访问到。因此，如果我们把当前访问的指令、数据及其附近的指令和数据都缓存到Cache，那么之后再访问时，CPU就无需访存了，进而提升了系统的性能。

##### 主存和缓存的编址

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/Cache%E7%BB%93%E6%9E%84.png" alt="Cache结构" style="zoom:80%;" />

+ 内存被分为$M$块，缓存被分为$C$块，其块的大小相同都为$B$个字。通常$M \gg C$，这意味着同一时间内，只有一小部分的主存会被缓存
+ 主存中的数据都是按块被缓存的，当某块被缓存时，由硬件为Cache的每一块维护的标记会记录下被缓存的主存块的块号。之后CPU访问该块的数据时，在缓存的标记中可以找到该块的块号，且相应**缓存块有效**，那么就不需要访存了，直接访问相应的缓存块即可

##### 缓存的命中率

所谓Cache的命中，就是指CPU访问某个指令或数据时，其对应的主存块已经被写入缓存（已建立了对应关系/标记），反之则为未命中，CPU必须到主存中去获取对应指令。

> CPU多次访问数据，其中缓存命中的比率称为Cache的**命中率**。命中率与Cahce的容量和块的大小有关，一般来说容量越大，块越大，则命中率越高。当然，凡是不能极端，缓存过大会提升成本和功耗，而块过大会减少块的数量，进而降低同一时间能够被缓存的主存块的数量。

总的来说，命中率 与 Cache 的 容量与块长有关。一般块长取一个存取周期内从主存调出的信息长度

##### 访问效率$e$

$$
\begin{align*}
e &= \frac{t}{\overline t}*100\% 
\\&=\frac{t_c}{h*t_c+(1-h)*t_m}*100\% 
\end{align*}
$$

+ $t$为访问Cache的时间，$\overline t$为平均访问时间
+ 带入命中率$h$后，t_c$为访问Cache的时间，$t_m$为访问主存的时间

##### 	Cache的基本结构

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/Cache%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" alt="image-20220721105528285" style="zoom:80%;" />

##### Cache读写操作

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/Cache%E8%AF%BB.png" alt="image-20220721110412863" style="zoom:80%;" />

写操作主要有两种方式：

+ 写直达法：写操作时既写入Cache也写入主存，写操作时间即为访问主存的时间，Cache块退出时，不需要对主存执行写操作，因此Cache块的更新策略比较容易实现。
+ 写回法：写操作时只把数据写入Cache而不写入主存，写操作时间即为访问Cache的时间，当Cache数据被替换出去时需要写回主存，因此增加了Cache的复杂性。

##### Cache改进

+ 增加Cache的层次级数：Cache本质上通常是SRAM，不过不同的单元电路组成的SRAM是有区别的，有的速度快、功耗高、成本高，有的速度慢、功耗低、成本低、且易于集成(具体内容可搜索LVT HVT关键字)。因此，参照整个存储系统的层次结构，Cache也可以细分出不同层次，比如L1 Cache、L2 Cache等，以此来获得性能、功耗、芯片面积、成本等方面的平衡。
+ 参照哈佛架构分立缓存：采用独立的数据Cache和指令Cache。现代处理器基本上都采用了流水线结构，如果单独为数据和指令设置Cache，则在某条指令执行需要访问数据时，不会影响后面的指令的取指(一个是访问数据Cache，一个是访问指令Cache)，从而提高计算机的性能。

#### 主存地址映射

##### 直接映射

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84.png" alt="image-20220721112338281" style="zoom:80%;" />

首先要对主存按照缓存块的大小进行划分成不同的区，每个区的第一个字块都放置于Cache存储体中的第0块。CPU给出的主存地址可以分成三个部分：区号（主存字块标记），块号（Cache字块地址），偏移地址（字块内地址）。这种结构的优点是结构简单、速度快，缺点是在Cache有很多空闲的情况下仍出现Cache冲突，影响Cache利用率。

##### 全相联映射

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%85%A8%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84.png" alt="全相联映射" style="zoom:80%;" />

从全相联的结构可知，这种结构相较直接映射能够提高Cache的利用率，因为一个主存块可以被缓存到任一缓存块。但缺点也正是源于此，无法根据主存地址确定地址所在主存块会被缓存到哪个缓存块，因此在检查缓存是否命中时，需要多个比较器同时比较主存地址中主存块的块号和所有缓存标记，造成电路结构复杂，功耗也更高。

##### 组相联映射

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84.png" alt="image-20220721115852678" style="zoom:80%;" />

直接映射中，一个主存块只可能被缓存到某个特定的缓存块；全相联映射正好相反，一个主存块可以被缓存到任一缓存块。可以说这两种方式走了两个极端，各有优缺点，而组相联映射是前两种映射方式的折中，实现了一个主存块可以被缓存到若干个缓存块(**一组缓存块**)中：

#### 替换算法

##### FIFO

先进先出置换算法。这个就是类似于队列，先装入的页面先被置换掉。易于实现但是有可能淘汰频繁使用的页面，效果不好。

##### LRU

将近期内最久末被访问过的Cache块置换出去。

LRU算法是指:会为每一个Cache块设置一个“计数器”，用于记录每个Cache块究竟有多长时间没有被访问了。在替换时直接选取“计数器”最大的替换即可。

-   命中时，所命中的行的计数器清零，比其低的计数器+1，其余不变
-   未命中且还有空闲行时，新装入的行的计数器置为0，其余非空闲行全+1
-   未命中且没有空闲行时，计数器最大的行的信息块被淘汰，新装入行的计数器置为0，其余全+1

##### LFU

将一段时间内被访问次数最少的那块从Cache中置换出去

LFU算法会为每一个Cache块设置一个计数器，用于记录每个Cache块被访问过几次，当Cache块满后会替换计数器最小的

-   新调入的块计数器为0，之后每访问一次计数器就+1。需要替换时，选择计数器最小的一行替换
-   若有多个计数器最小的行，可以按照行号递增或FIFO策略进行选择

##### 随机替换

随机确定将哪块从Cache中替换出去。

### 辅助存储器

其不能直接与CPU进行信息交换，最常用的辅助存储器是**磁表面辅助存储器**

#### 磁表面辅助存储器

##### 技术指标

1. 记录密度：
   1. 道密度$D_t$：沿磁盘半径方向单位长度上的磁道数，单位为道/英寸
   2. 位密度$D_b$：磁道单位长度上能记录的二进制代码位数，单位为位/英寸
2. 存储容量：一个硬盘存储器所能存储的字节长度，$C=n*k*s$
3. 平均存取时间：存取时间是指从发出读写命令后。磁头从某一起始位置移动至新的记录位置，到开始从盘片表而读出或写入信息所需要的时间。**这段时间由两个数值决定，一个是将磁头定位至所要求的磁道所需的时间，称为定位时间或寻道时间：另一个是寻道完成后至磁道上需要访问的信息到达磁头下的时间，称为等待时间**，这两个时间都是随机变化的，因此往往使用平均值来表示。平均存取时间等于平均寻道时间与平均等待时间之和。平均寻道时间是最大寻道时间与最小寻道时间的平均值。
4. 数据传输率：磁盘存储器在单位时间内向主机传送数据的字节数，叫数据传输率， 传输率与存储设备和主机接口逻辑有关。从存储设备考虑，假设磁盘旋转速度为$n$转/秒，每条磁道容量为$N$个字节，则数据传输率$D_r=D_b*V(Bps)$, 其中$D_b$为位密度，$V$为磁盘旋转的线速度。
5. 误码率：出错的信息位数与读出信息位总数之比 

##### 磁记录原理

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A3%81%E7%9B%98%E5%86%99.png" alt="image-20220723131552620" style="zoom:80%;" />

通过写线圈通入方向不一样的电流来写入改变局部磁化单元的朝向，从而记录0与1

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A3%81%E7%9B%98%E8%AF%BB.png" alt="image-20220723131807182" style="zoom:80%;" />

读写头在磁场中运动，切割磁力线，产生不同方向的电流，磁通与电势都发生变化，从而读取0和1。

#### 硬磁盘存储器

硬磁盘存储器的类型：

1. 固定磁头和移动磁头
2. 可换盘和固定盘

硬磁盘存储器的结构：

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A1%AC%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84.png" alt="image-20220723132957919" style="zoom:80%;" />

+ 磁盘控制器接受来自主机的指令，转换为磁盘驱动器的控制命令。实现主机与驱动器之间的数据格式转换
+ 盘片由硬质铝合金材料制成

#### 软磁盘存储器

时代的眼泪，就速度而言不如硬盘，磁头来说软盘的磁头都是活动的，盘片为可更换，价格低廉但是容易损坏。

#### 光盘存储器

采用光存储技术，利用激光进行读写，第一代技术采用非磁性介质，不可擦写。第二代技术采用磁性介质后可以擦写。

## 输入输出系统

### 概述

#### 输入输出系统的发展概况

早期的计算机数目较少，应用少，外设也少。所以早期使用**分散连接**的方式，即每一个设备都有专门的控制电路，甚至与CPU的控制电路高度耦合。所以对外设增删都非常麻烦。外部设备与主机的连接主要采用**程序查询方式**，即CPU和I/O设备**串行工作**。

随着计算机发展，分散连接逐步被淘汰。出现了**I/O接口**与**DMA控制器**，采用**总线**方式进行连接，一条总线连接多个设备，总线与I/O设备的传输方式也变成了**并行工作**。

为了进一步使得I/O操作独立于CPU之外，又出现了具有**通道结构**的I/O，可以看成**小型的DMA控制器**，具有自己的指令系统，可以控制连接在通道上的I/O设备直接与主机交互。

现代的超级计算机可以使用专门的处理器作为I/O处理机，甚至能帮助CPU进行运算。

#### 输入输出系统的组成

**I/O软件**

1. I/O指令：CPU指令集的一部分，其格式为操作码+命令码+设备码
2. 通道指令：通道能够指令由通道指令构成的程序，指出数组的首地址、传送字数、操作命令

**I/O硬件**

1. 设备–I/O接口–总线–主机
2. 设备–设备控制器–子通道–通道–主机

#### I/O设备与主机的联系方式

I/O设备是有地址的，主机必须要给出其地址才能操作。所以要对I/O设备编址，其编址方式有：

**统一编址**：将I/O设备地址编写在内存区域，用取数和读数到对应区域则为I/O操作。显然会节省命令集，但是对于寻址空间的要求较高。

**单独编址**：在内存地址之外，专门设置一个地址空间给外部设备。为了区分指令是对内存还是对I/O设备，此时需要有专门的I/O指令进行操作。

编址之后，需要选址。采用**设备选择电路**识别是否被选中，只要把CPU给出的地址和设备中保存的地址进行比较，相同则为选中。然后就可以开始数据传送：

**串行**：数据一位一位进行传输，传输速度慢，适合远程上传输

**并行**：同时有多位数据进行传输，通常情况下为8的倍数。

联络方式：外设接受或发送数据的响应情况

**立即响应**：直接发生响应

**异步工作**：一般采用应答信号的方式，分为并行传输和串行传输。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B8%80%E8%88%AC%E9%87%87%E7%94%A8%E5%BA%94%E7%AD%94%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%96%B9%E5%BC%8F.png" alt="image-20220724133812663" style="zoom:80%;" />

**同步工作**：采用同步时标

#### I/O设备与主机信息传送的控制方式

程序查询方式：CPU和外设串行工作

程序中断方式：CPU和外设做到部分并行

DMA方式：使得外部设备和内存之间建立直接连接，无需CPU额外处理

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F.png" alt="image-20220724135731680" style="zoom:80%;" />

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD.png" alt="image-20220724140401331" style="zoom:80%;" />

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD2.png" alt="image-20220724140459014" style="zoom:80%;" />

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/DMAa.png" alt="image-20220724141208316" style="zoom:80%;" />



### 外部设备

#### 概述

外部设备（I/O设备）通过I/O接口与主机相连，其主要包含两个部分：设备控制器与物理部分。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%A4%96%E9%83%A8%E8%AE%BE%E5%A4%87.png" alt="image-20220725101402068" style="zoom:80%;" />

#### 外部设备的分类

1. 人机交互设备：键盘、鼠标、打印机、显示器
2. 计算机信息存储设备：磁盘、光盘、磁带
3. 机-机通信设备：调制解调器

### I/O接口

#### 接口的功能

1. 实现设备的选择
2. 实现数据的缓冲平衡不同外部设备速度匹配
3. 实现数据串-并格式转换
4. 实现电平转换
5. 传送控制命令
6. 反映设备的工作状态。

#### 接口的组成

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%84%E6%88%90.png" alt="image-20220725103240038" style="zoom:80%;" />

+ 设备选择线（单向）：传送本次参与信息传输的设备码（设备地址）或端口地址给I/O接口进行匹配
+ 数据线（双向）：完成数据的输入输出
+ 命令线（单向）：主机发送命令进过缓冲和译码之后，控制设备操作
+ 状态线（单向）：从I/O接口发送给主机，告知设备的状态

#### 接口的功能和组成

| 功能         | 组成                   |
| ------------ | ---------------------- |
| 选址功能     | 设备选择电路           |
| 传送命令     | 命令寄存器、命令译码器 |
| 传送数据     | 数据缓冲寄存器         |
| 反映设备状态 | 设备状态标记           |

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/I/O%E6%8E%A5%E5%8F%A3%E7%BB%84%E6%88%90.png" alt="image-20220725104935351" style="zoom:80%;" />

#### 接口分类

1. 数据传送方式分类：并行接口、串行接口
2. 选择的灵活性分类：可编程接口、不可编程接口
3. 通用性分类：通用接口、专用接口
4. 数据传送的控制方式：中断方式接口、DMA接口

## 计算机的运算方法

### 无符号数和有符号数

#### 无符号数

计算机中的数均放在**寄存器**中，通常称寄存器的位数为**机器字长**。**所谓无符号数，即没有符号的数**，在寄存器中的每一位均可用来存放数值。当存放有符号数时，则需留出位置存放符号。因此，在机器字长相同时，无符号数与有符号数所对应的数值范围是不同的。比如用一个八位的寄存器保存无符号数，则可以表示0~255。

#### 有符号数

##### 机器数与真值

因为计算机没有办法直接识别正负号，所以需要将正负号转化为数字来存储。保存在计算机中将正负号“数字化”之后的数称为**机器数**，而**真值**是我们日常生活中包含了正负号的数值。注意：以下内容默认都为2进制数

##### 原码表示法

原码是机器数中最简单的一种表示形式，符号位为0表示正数，符号位为1表示负数，**数值位即真值的绝对值**，故原码表示又称为带符号的绝对值表示。为了书写方便以及区别整数和小数，约定整数的符号位与数值位之间用逗号隔开；小数的符号位与数值位之间用小数点隔开。由此可得原码的定义：
$$
[x]_{\text {原}}=\left\{\begin{array}{cc}
0, \ x & 2^{n}>x \geqslant 0 \\
2^{n}-x & 0 \geqslant x> -2^{n}
\end{array}\right.
$$
例如，当$x= -1110$时，$[x]_{\text {原}} = 2^4 - (-1110) = 1,1110$

对于小数部分：
$$
[x]_{\text {原 }}=\left\{\begin{array}{cc}
x & 1>x \geqslant 0 \\
1-x & 0 \geqslant x>-1
\end{array}\right.
$$
例如，当$x= +0.1101$时，$[x]_{\text {原}} = 0.1101$，注意这里两个$0.$的含义不同，后者表示正数+区分符

+ 不难发现，对于$0$而言，$[+0000]_{\text {原}} = 0,0000 ;\ [-0000]_{\text {原}} = 1,0000$，两者并不相同

+ 原码特点：简单且直观，但运算复杂。当两个操作数符号不同且要作加法运算时，先要判断两数绝对值大小，然后将绝对值大的数减去绝对值小的数，结果的符号以绝对值大的数为准。而且用到的是减法器实现。

  

##### 补码表示法

为了解决原码在计算中的问题，即用一个与负数等价的正数表示负数，使得运算中只需要加法器。

所谓补数，就是其本身加上**模**。正数的补数是其自身，负数的补数是其本身加上模，当一个正数和一个负数互为补数的时候，其绝对值之和为模数。那么对于2进制数而言，模就是$2^n$，但是为了能表示正负，即负数的首位为1，选择将模设置为$2^{n+1}$。
$$
[x]_{\text {补 }}= \begin{cases}0,\ x & 2^{n}>x \geqslant 0 \\ 2^{n+1}+x & 0>x \geqslant-2^{n} \quad\left(\bmod 2^{n+1}\right)\end{cases}
$$
例如，$x = -1011000$，则$[x]_{\text{补}} = 2^{7+1} + (-1011000) = 1,0101000$

小数：
$$
[x]_{\text {补 }}= \begin{cases}x & 1>x \geqslant 0 \\ 2+x & 0>x \geqslant-1 \quad(\bmod 2)\end{cases}
$$

例如，$x = -0.1100000$，则$[x]_{\text{补}} = 2+(-0.1100000) = 1.0100000$

+ 我们也可以通过口诀“**原码取反（变为反码）再加1**”快速计算一个数的补码
+ 不难发现，对于$0$而言，$[+0000]_{\text {补}} = 0,0000 ;\ [-0000]_{\text {补}} = 2^{4+1} - 0000=100000 -0000 = 0,0000$，最高位溢出舍去，所以补码的0表现形式是一致的

##### 反码表示法

反码通常用来作为由原码求补码或者由补码求原码的中间过渡。反码的定义如下：
$$
[x]_{\text {反 }}=\left\{\begin{array}{ll}
0,\  x & 2^{n}>x \geqslant 0 \\
\left(2^{n+1}-1\right)+x & 0 \geqslant x>-2^{n}\left(\bmod 2^{n+1}-1\right)
\end{array}\right.
$$
小数：
$$
[x]_{\text {反 }}= \begin{cases}x & 1>x \geqslant 0 \\ \left(2-2^{-n}\right)+x & 0 \geqslant x>-1 \quad\left(\bmod \left(2-2^{-n}\right)\right)\end{cases}
$$
例如，$x = -0.1010$，则
$$
\begin{align*}
[x]_{\text{反}} &= (2 - 2 ^{-4}) + (-0.1010)) \\
&= (10 - 0.0001) -0.1010 \\
&= 1.1111 - 0.1010 \\
&= 1.0101 
\end{align*}
$$

+ 简而言之为，符号位不变，正数不变，负数取反
+ 不难发现，对于$0$而言，$[+0000]_{\text {反}} = 0,0000 ;\ [-0000]_{\text {反}} = 2^{4+1}-1 - 0000=11111 - 0000 = 1,1111$，两者并不一致。

##### 小结

1. 最高位为符号位，书写上用“,”或“.”将数值部分与符号位分隔开
2. 对于正数，原码 = 反码 = 补码
3. 对于负数，符号位为1。其数值部分原码取反得反码，反码加1得补码

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8E%9F%E5%8F%8D%E8%A1%A5%E5%B0%8F%E7%BB%93.png" alt="image-20220726222748948" style="zoom:80%;" />

##### 移码表示法

补码虽然计算机计算方便，但是人类和机器并不能直观地判断大小。所以选择加上$2^n$，（这里的$n$同样是不包含符号位的）。因此得到移码的定义
$$
[x]_{\text {移 }}=2^{n}+x\left(2^{n}>x \geqslant-2^{n}\right)
$$
例如，
$$
\begin{aligned}
&{[+0]_{\text {移 }}=2^{5}+0=1,00000} \\
&{[-0]_{\text {移 }}=2^{5}-0=1,00000}
\end{aligned}
$$

+ 可见在移码中0的表示唯一。
+ 移码只有整数形式的定义，而无小数定义。因为移码在数据表示中负责浮点数的**阶码**部分，其只有整数。
+ 最小值为全0，最大值为全1，非常直观
+ **同一真值的移码和补码只有符号位不同**

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E7%A7%BB%E7%A0%81%E6%AF%94%E8%BE%83.png" alt="image-20220726224410850" style="zoom:80%;" />



### 数的定点表示和浮点表示

在计算机中，小数点**不用专门的器件表示，而是按约定的方式标出**，共有两种方法表示小数点的存在，即**定点表示**和**浮点表示**。定点表示的数称为定点数，浮点表示的数称为浮点数。

#### 定点表示

所谓定点表示，即小数点固定在某一位置。其有两种形式，分别是小数点在数符（正负号）后，和小数点在数值后。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%AE%9A%E7%82%B9%E8%A1%A8%E7%A4%BA.png" alt="image-20220727145024898" style="zoom:80%;" />

+ 根据机器选择的小数点位置的不同，分为**小数定点机**和**整数定点机**

| 定点机 | 小数定点机                  | 整数定点机            |
| ------ | --------------------------- | --------------------- |
| 原码   | $[-(1-2^{-n}),+(1-2^{-n})]$ | $[-(2^n-1),+(2^n-1)]$ |
| 补码   | $[-1,+(1-2^{-n})]$          | $[-2^n,+(2^n-1)]$     |
| 反码   | $[-(1-2^{-n}),+(1-2^{-n})]$ | $[-(2^n-1),+(2^n-1)]$ |

+ 不难发现，原码的范围与反码表示的范围一致，这也与上一篇的结论相符合。而补码的最小值会发生改变，也与上篇相符。

#### 浮点表示

实际上计算机中处理的数不一定是纯小数或纯整数（如圆周率），而且有些数据的数值范围相差很大，它们都不能直接用定点小数或定点整数表示，除非疯狂加长机器字长，这显然是不现实的。但其均可用浮点数表示。**浮点数即小数点的位置可以浮动的数**，比如：
$$
\begin{aligned}
352.47 &=3.5247 \times 10^{2} \\
&=3524.7 \times 10^{-1} \\
&=0.35247 \times 10^{3}
\end{aligned}
$$
其实就类似我们学过的科学计数法，其一般形式为$N = S*r^j$，其中$S$称为**尾数**，$j$称为**阶码**，$r$称为**基值**。

+ 尾数$S$的绝对值小于等于1，为小数
+ 阶码$j$为整数
+ 基值$r$在计算机中一般取2的次幂

当$r=2$时，举个例子：
$$
\begin{aligned}
N &=11.0101 \\
&=0.110101 \times 2^{10} \\
&=1.10101 \times 2^{1} \\
&=1101.01 \times 2^{-10} \\
&=0.00110101 \times 2^{100}
\end{aligned}
$$

+ 注意，这里的阶码同样为2进制。
+ 注意，尾数的绝对值限制
+ 将尾数最高位为1的数称为**规格化数**，此时精度最高

##### 浮点数的表现形式

在设计计算机的过程中，如果事先约定好了基值$r$，那么存储浮点数只需要记录另外两个数值即可：

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%BD%A2%E5%BC%8F.png" alt="image-20220727152107973" style="zoom:80%;" />

+ $j_f$和$S_f$表示正负
+ $n$，尾数位数，即反映浮点数精度
+ $m$，阶码位数，即反映浮点数范围

##### 浮点数的表示范围

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%B5%AE%E7%82%B9%E8%8C%83%E5%9B%B41.png" alt="image-20220727153145219" style="zoom:80%;" />

+ 上溢：阶码大于最大阶码，则报错进行中断溢出处理
+ 下溢：阶码小于最小阶码，则按照机器0处理

##### 浮点数的规格化

规格化形式与$r$的取值有直接联系，当$r=2$时，要求首位为1，当$r=4$时，要求首两位不全为0。

**事实上，可以总结出当$r = 2^i$时，要求首$i$位不全为0**，推广到其他码制：

| 码制 | S>0规格化形式 | S<0规格化形式 |
| ---- | ------------- | ------------- |
| 真值 | 0.1XXX        | -0.1XXX       |
| 原码 | 0.1XXX        | 1.1XXX        |
| 补码 | 1.0XXX        | 1.0XXX        |
| 反码 | 0.1XXX        | 1.0XXX        |

+ **原码：无论正负首位都为1**
+ **补码：符号位与首位不同**，有特例$[-\frac{1}{2}]_\text{补}=1.100$不是规格化数，$[-1]_\text{补} = 1.000$是规格化数

很容易想到，通过左移右移就可以使得浮点数规格化。这被称为**左规右规**，但是要注意基值$r$对于阶码的影响。 

比如 $r = 4$，左规2位，尾数左移2位，阶码减1。此时就不能左规3位，因为要保证阶码为整数。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E6%B5%AE%E7%82%B9%E4%BE%8B%E5%AD%90.png" alt="image-20220727160349750" style="zoom:80%;" />

+ 值得注意的是，当一个浮点数尾数为0时，不论其阶码为何值；或阶码等于或小于它所能表 示的最小数时，不管其尾数为何值，机器都把该浮点数作为零看待，并称之为“机器零”。

#### 定点数和浮点数的比较

1. 当浮点机和定点机中，数的位数相同时，浮点数的表示范围比定点数的大得多。

2. 当浮点数为规格化数时，其相对精度远比定点数高。

3. 浮点数运算要分阶码部分和尾数部分，而且运算结果都要求规格化，故浮点运算步骤比定点运算步骤多，运算速度比定点运算的低，运算线路比定点运算的复杂。

4. 在溢出的判断方法上，浮点数是对规格化数的阶码进行判断，而定点数是对数值本身进行判断。
5. 总之，浮点数在数的表示范围、数的精度、溢出处理和程序编程方面（不取比例因子）均优于定点数。但在运算规则、运算速度及硬件成本方面又不如定点数。因此，究竟选用定点数还是浮点数，应根据具体应用综合考虑。一般来说，通用的大型计算机大多采用浮点数，或同时采用定、浮点数；小型、微型及某些专用机、控制机则大多采用定点数。当需要作浮点运算时，可通过软件实现，也可外加浮点扩展硬件（如协处理器）来实现。

#### IEEE 754标准

![image-20220727161122768](https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/IEEE.png)

+ 尾数必须规格化，非0的有效位最高位为1（隐含）。所以尾数有一个最高位为隐藏位，其值恒为1
+ 在实际应用中分为短实数（float）和长实数（double）以及临时实数（不采用隐藏位）

| 类型     | 符号位S | 阶码 | 尾数 | 总位数 |
| -------- | ------- | ---- | ---- | ------ |
| 短实数   | 1       | 8    | 23   | 32     |
| 长实数   | 1       | 11   | 52   | 64     |
| 临时实数 | 1       | 15   | 64   | 80     |

### 定点运算

#### 移位运算

移位运算指**小数点不动，数据左移或者右移**，其中左移绝对值变大，右移绝对值减小。对计算机来说，左移一位意味着数据变为原先的两倍，右移则为二分之一。移位运算有很大的实用价值。例如，当某计算机没有乘（除） 法运算线路时，可以采用移位和加法相结合，实现乘（除）运算。

##### 算术移位

>计算机中机器数的字长往往是固定的，当机器数左移n位或右移n位时，必然会使其n位低位或n位高位出现空位。那么，对空出的空位应该添补0还是1呢？这**与机器数采用有符号数还是无符号数有关**。对有符号数的移位称为算术移位。

| 真值 | 码制             | 填补代码         |
| ---- | ---------------- | ---------------- |
| 正数 | 原码、反码、补码 | 0                |
| 负数 | 原码             | 0                |
| 负数 | 反码             | 1                |
| 负数 | 补码             | 左移为0，右移为1 |

+ 算术移位保证**符号位不变**，约定数值部分移位后能够存储的下
+ 机器数为正时，不论是左移还是右移，添补代码均为0。
+ 由于负数的**原码数值部分与真值相同**，故在移位时只要使符号位不变，其空位均添0即可。
+ 由于负数的**反码各位除符号位外与负数的原码正好相反**，故移位后所添的代码应与原码相反，即全部添1。
+ 分析任意负数的补码可发现，当对其由低位向高位找到第一个“1”时，在此“1”左边的各位均与对应的反码相同，而在此“1”右边的各位（包括此“1”在内）均与对应的原码相同。故负数的补码左移时，因空位出现在低位，则添补的代码与原码相同，即添0；右移时因空位出现在高位，则添补的代码应与反码相同，即添1。
+ 对于负数，三种机器数算术移位后符号位均不变。负数的原码左移时，高位丢1，结果出错；右移时，低位丢1，影响精度。负数的补码左移时，高位丢0，结果出错；右移时，低位丢1,，影响精度。负数的反码左移时，高位丢0，结果出错；右移时，低位丢0，影响精度。

##### 逻辑移位

有符号数的移位称为算术移位，无符号数的移位称为逻辑移位。换言之，算术移位不会移动符号位，而逻辑移位会。逻辑移位的规则是：逻辑左移时，高位移丢，低位添0；逻辑右移时，低位移丢，高位添0。

#### 加减运算

之所以引进补码，就是因为其可以将减法运算转换为加法运算。而现代计算机也确实采用补码做加减法运算

##### 补码加减法

整数加法： $[A]_{\text {补 }}+[B]_{\text {补 }}=[A+B]_{\text {补 }}\left(\bmod 2^{n+1}\right)$

小数加法： $[A]_{\text {补 }}+[B]_{\text {补 }}=[A+B]_{\text {补 }}(\bmod 2)$

整数减法： $[A-B]_{\text {补 }}=[A+(-B)]_{\text {补 }}=[A]_{\text {补 }}+[-B]_{\text {补 }}\left(\bmod 2^{n+1}\right)$ 

小数减法： $[A-B]_{\text {补 }}=[A+(-B)]_{\text {补 }}=[A]_{\text {补 }}+[-B]_{\text {补 }}(\bmod 2)$

+ 注意**符号位需要参与计算**，丢弃符号位的进位

##### 溢出判断

1. 一位符号位判断：参加操作的两个数（减法时即为被减数和“求补” 以后的减数）符号相同，其结果的符号与原操作数的符号不同，即为溢出。换言之，数值部分最高位的进位$\oplus$符号位的进位 = 1 即为溢出。

2. 两位符号位判溢出：首先使用变形补码，其公式如下。简而言之，对于正数其变形补码（符号位）为$00$，对于负数其变形补码（符号位）为$11$。数值部分可以用原本的取反加一计算。
   $$
   [x]_\text{补}= \begin{cases}x & 1>x \geq 0 \\ 4+x & 0>x \geq-1(\bmod 4)\end{cases}
   $$

$$
[x]_{\text {补 }}= \begin{cases}0,\ x & 2^{n}>x \geqslant 0 \\ 2^{n+2}+x & 0>x \geqslant-2^{n} \quad\left(\bmod 2^{n+2}\right)\end{cases}
$$

+ 在用变形补码作加法时，2位符号位要连同数值部分一起参加运算，而且**高位符号位产生的进位自动丢失**，便可得正 确结果。变形补码判断溢出的原则是：**当2位符号位不同时，表示溢出**，否则，无溢出。不论是否发生溢出，高位符号位永远代表其结果真正的符号。

#### 乘法运算

先来看一个乘法的改进算法，其计算$0.1101 * 0.1011$的值，具体过程[哈工大计组p85](https://www.bilibili.com/video/BV1t4411e7LH?p=85)。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E4%B9%98%E6%B3%95%E6%94%B9%E8%BF%9B.png" alt="image-20220730234454703" style="zoom:80%;" />

再通过异或电路判断正负，结果为$0.10001111$

通过乘法运算的改进算法可归纳如下：

1. **符号位单独判断。**
2. **乘法运算可用逻辑移位和加法来实现**，比如两个4位数相乘，总共需要进行4次加法运算和4次**逻辑移位**。
3. 由乘数的末位值确定被乘数是否与原部分积相加，然后右移一位，形成新的部分积；同时，乘数也右移一位，**空出高位存放部分积的低位。**
4. 每次做加法时，被乘数仅仅与原部分积的高位（被乘数的位数）相加，**其低位被移至乘数所空出的高位位置**。

计算机很容易实现这种运算规则。用一个**X寄存器**存放被乘数，一个**ACC寄存器**存放乘积的高位，另一个**MQ寄存器**存放乘数及乘积的低位，再配上加法器及其他相应电路，就可组成乘法器。又因加法只在部分积的高位进行，故不但节省了器材，而且还缩短了运算时间。

>+ ACC：累加器，用于存放操作数，或运算结果。
>
>+ MQ：乘商寄存器，在乘、除运算时，用于存放操作数或运算结果。
>
>+ X：通用的操作数寄存器，用于存放操作数
>
>+ ALU：算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算

##### 原码一位乘法

1. 符号位用异或单独判断

2. 数值部分按照绝对值相乘（先加再**逻辑右移**）

3. 每次加法根据**MQ寄存器**（存放乘数及乘积低位）的末位确定：

   + 1：$ACC+[\abs {x}]_\text{原}$

   + 0：$ACC + 0 $

4. 用右移的次数（等于乘数的位数，或者机器字长）判断是否结束

##### 补码一位乘法

1. 符号位参与运算
2. 先加再**补码的算术右移**，最后再加
3. 辅助位：指**MQ寄存器**扩展的一位末位，其初始值为0。每次右移时其值被更新为末位的值
4. **ACC寄存器**和**X寄存器**存放的乘积高位和被乘数，都是用**双符号位记录**
5. 每次加法根据**MQ寄存器**的末位和**辅助位**确定，使用辅助位 - MQ最低位的值判断：
   + 1：$ACC+[x]_\text{补}\rightarrow ACC$
   + 0：$ACC+0\rightarrow ACC$
   + -1：$ACC+[-x]_\text{补}\rightarrow ACC$

#### 除法运算

回忆一下手算除法，不难总结出二进制手算除法的规律：使用数值部分进行计算，根据除数和余数的大小确定一位商，进行一次减法操作并得到余数。再余数后补零，重复计算直到满足精度或者整除。那么如何在计算机中实现上述过程呢？

为了方便说明，定义被除数$x$，除数$y$，当前的余数$R$

##### 原码恢复余数法

1. 符号位用异或单独判断
2. 数值部分按照**绝对值**进行计算，还需要计算除数的绝对值补码和除数相反数的绝对值补码。即$[\abs{y}]_\text{补}$和$[\abs{-y}]_\text{补}$
3. 使用**ACC**存储被除数（当前的余数$R$），使用**X**存储除数$y$，使用**MQ**存储商
4. 这个方法的精髓就在于：计算机不会直接比较$R$和$y$的大小，而是直接**商1**（在MQ的末位写入）。然后计算$ R - y = R + [\abs{-y}]_\text{补} \rightarrow ACC$，将结果写入**ACC**后，通过电路判断符号位是否为0（正数）。如果为1，则进行$ R + y \rightarrow ACC$恢复余数，再改成**商0**。
5. 对**ACC**和**MQ**进行**逻辑左移**，**MQ**的最高位填充到$ACC$的末位，末位补零。**最后一次上商后无需左移**
6. 重复4-5步，直到商的位数达到机器字长长度。假设得到余数为00111，则真值为$0.0111 * 2^{-n} = 0.0111 * 2^{-4}$。商为$01101$，则商为$0.1101$。再用符号位异或确定商的符号位（余数一定是正数）。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%9B%9E%E5%A4%8D%E4%BD%99%E6%95%B0%E6%B3%95.png" alt="image-20220803184738585" style="zoom:80%;" />

##### 原码加减交替法

对恢复余数法进行总结可以发现：

+ 上商1后：$2* R -y$
+ 上商0后：$2*(R+y) -y = 2*R +y$

通过这样的化简，我们可以精简恢复余数法上商0的操作，即**省略恢复余数的步骤**。故又称不恢复余数法。同样也是移位n次，上商n+1次。

<img src="https://imgbed-1304793179.cos.ap-nanjing.myqcloud.com/typora/%E5%8A%A0%E5%87%8F%E4%BA%A4%E6%9B%BF%E6%B3%95.png" alt="image-20220803191510289" style="zoom:80%;" />

##### 补码除法

1. 使用双符号位表示正负，符号位参与运算
2. 被除数$x$和除数$y$同号，则$R= x -y = x+[-y]_\text{补}$，否则$R= x+y =x+ [y]_\text{补}$
3. 若余数$R$与除数$y$同好，则商1，余数左移一位减去除数$2*R - y = 2*R +[-y]_\text{补}$，否则商0，余数左移一位加上除数$2*R + y = 2*R +[y]_\text{补}$。重复n次
4. 如果对商的精度没有特殊要求，一般可采用“末位恒置1”法，这种方法操作简单，易于实现，而且最大误差仅为$2^{-n}$

### 浮点四则运算

#### 浮点加减运算

> 由于浮点数尾数的小数点均固定在第一数值位前，所以尾数的加减运算规则与定点数的完全相同。但由于其阶码的大小又直接反映尾数有效值小数点的实际位置，因此当两浮点数阶码不等时，因两尾数小数点的实际位置不一样，尾数部分无法直接进行加减运算。为此，浮点数加减运算必须按以下几步进行。

1. 对阶：使两数的小数点对齐
2. 尾数求和：将对阶后的两尾数按定点加减运算规则求和（差）。
3. 规格化，为增加有效数字的位数，提高运算精度，必须将求和（差）后的尾数规格化。
4. 舍入，为提高精度，要考虑尾数右移时丢失的数值位。
5. 溢出判断，即判断结果是否溢出。

例子：$x= 0.1101*2^{01} \quad y=(-0.1010)*2^{11}$，计算 $x+y$

##### 对阶

对阶的目的是使两操作数的小数点位置对齐，即使两数的阶码相等。为此，首先要求出**阶差**，再按**小阶向大阶看齐**的原则，使阶小的尾数向右移位，每右移一位，阶码加1，直到两数的阶码相等为止。**右移的次数正好等于阶差**。尾数右移时可能会发生数码丢失，影响精度。（如果选择大阶向小阶看齐，则需要让尾数变大左移，这可能导致最高位丢失造成数据错误）

首先将数据用浮点数补码表示：
$$
[x]_\text{补} = 00,01;\ 00.1101\\
[y]_\text{补} = 00,11;\ 11.0110
$$

+ 四位阶码（两位阶符），六位尾数（两位尾符）

求阶差：
$$
[\Delta j]_\text{补} =[j_x]_\text{补} - [j_y]_\text{补} = 00,01 + 11,01 = 11,10<0
$$

+ 阶差为$11,10 = -2$，所以$j_x+2\quad S_x \rightarrow 2$

对阶：$[x]_\text{补'} = 00,11;00.0011 \quad [y]_\text{补} = 00,11;\ 11.0110$

##### 尾数求和

将对阶后的两个尾数按定点加（减）运算规则进行运算
$$
[S_x +S_y]_\text{补} =[S_x]_\text{补'}+[S_y]_\text{补} = 00.0011 + 11.0110 =11.1001
$$

+ $[x+y]_\text{补} = 00,11;11.1001$

##### 规格化

当前基值 $r$ 为2，那么要求前1位即首位不为0。通过**左规和右规**进行规格化，直到尾符和首位不同为止（机器数为补码，且考虑特例$-1 \ and\  -\frac{1}{2}$）

左规：尾数左移，阶码减一
$$
[x+y]_\text{补} = 00,10;11.0011
$$
右规：尾数右移，阶码加一。只有当尾数的符号位溢出，俩符号位数值不等，即形如$10.XXX \quad 01.XXX$时才进行右规

##### 舍入

在**对阶和右规**的过程中，可能会将尾数的低位丢失，引起误差，影响精度。为此可用舍入法来提高尾数的精度。常用的舍入方法有以下两种。

1. “0舍1人”法：类似于十进制数运算中的“四舍五入”法，即在尾数右移时，被移去的最高数值位为0，则舍去；被移去的最高数值位为1，则在尾数的末位加1。这样做可能使尾数又溢出，此时需再做一次右规。
2. “恒置1”法：尾数右移时，不论丢掉的最高数值位是“1”或“0”，都使右移后的尾数末位恒置“1”。这种方法同样有使尾数变大和变小的两种可能。





## 指令系统

## CPU的结构和功能

## 控制单元的功能

## 控制单元的设计

